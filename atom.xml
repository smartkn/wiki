<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知识库</title>
  
  
  <link href="/wiki/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-11T14:38:19.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>TK</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    <id>http://yoursite.com/计算机基础/字符编码/</id>
    <published>2020-08-15T09:01:58.228Z</published>
    <updated>2020-05-11T14:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、ASCII-码"><a href="#一、ASCII-码" class="headerlink" title="一、ASCII 码"></a>一、ASCII 码</h2><p>我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有<code>0</code>和<code>1</code>两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从<code>00000000</code>到<code>11111111</code>。</p><p>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。</p><p>ASCII 码一共规定了128个字符的编码，比如空格<code>SPACE</code>是32（二进制<code>00100000</code>），大写的字母<code>A</code>是65（二进制<code>01000001</code>）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为<code>0</code>。</p><h2 id="二、非-ASCII-编码"><a href="#二、非-ASCII-编码" class="headerlink" title="二、非 ASCII 编码"></a>二、非 ASCII 编码</h2><p>英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的<code>é</code>的编码为130（二进制<code>10000010</code>）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。</p><p>但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了<code>é</code>，在希伯来语编码中却代表了字母<code>Gimel</code> (<code>ג</code>)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127表示的符号是一样的，不一样的只是128–255的这一段。</p><p>至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。</p><p>中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。</p><h2 id="三-Unicode"><a href="#三-Unicode" class="headerlink" title="三. Unicode"></a>三. Unicode</h2><p>正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。</p><p>可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。</p><p>Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，<code>U+0639</code>表示阿拉伯字母<code>Ain</code>，<code>U+0041</code>表示英语的大写字母<code>A</code>，<code>U+4E25</code>表示汉字<code>严</code>。</p><h2 id="四、Unicode-的问题"><a href="#四、Unicode-的问题" class="headerlink" title="四、Unicode 的问题"></a>四、Unicode 的问题</h2><p>需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</p><p>比如，汉字<code>严</code>的 Unicode 是十六进制数<code>4E25</code>，转换成二进制数足足有15位（<code>100111000100101</code>），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。</p><p>这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是<code>0</code>，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p><p>它们造成的结果是：1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。2）Unicode 在很长一段时间内无法推广，直到互联网的出现。</p><h2 id="五、UTF-8"><a href="#五、UTF-8" class="headerlink" title="五、UTF-8"></a>五、UTF-8</h2><p>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。<strong>重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。</strong></p><p>UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p><p>UTF-8 的编码规则很简单，只有二条：</p><p>1）对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p><p>2）对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p><p>下表总结了编码规则，字母<code>x</code>表示可用编码的位。</p><blockquote><div><pre><br>Unicode符号范围      |        UTF-8编码方式<br>(十六进制)           |       （二进制）<br>———————-+————————————<br>0000 0000-0000 007F | 0xxxxxxx<br>0000 0080-0000 07FF | 110xxxxx 10xxxxxx<br>0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx<br>0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx<br></pre></div></blockquote><p>跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。</p><p>下面，还是以汉字<code>严</code>为例，演示如何实现 UTF-8 编码。</p><p><code>严</code>的 Unicode 是<code>4E25</code>（<code>0100 1110 0010 0101</code>），根据上表，可以发现<code>4E25</code>处在第三行的范围内（<code>0000 0800 - 0000 FFFF</code>），因此<code>严</code>的 UTF-8 编码需要三个字节，即格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>严</code>的最后一个二进制位开始，依次从后向前填入格式中的<code>x</code>，多出的位补<code>0</code>。这样就得到了，<code>严</code>的 UTF-8 编码是<code>11100100 10111000 10100101</code>，转换成十六进制就是<code>E4B8A5</code>。</p><p>可以看到<code>严</code>的 Unicode码 是<code>4E25</code>，UTF-8 编码是<code>E4B8A5</code>，两者是不一样的。它们之间的转换可以通过程序实现</p><h2 id="六、Little-endian-和-Big-endian"><a href="#六、Little-endian-和-Big-endian" class="headerlink" title="六、Little endian 和 Big endian"></a>六、Little endian 和 Big endian</h2><p>Unicode 的编码方式有 Little endian 和 Big endian 之分</p><p>以汉字<code>严</code>为例，Unicode 码是<code>4E25</code>，需要用两个字节存储，一个字节是<code>4E</code>，另一个字节是<code>25</code>。存储的时候，<code>4E</code>在前，<code>25</code>在后，这就是 Big endian 方式；<code>25</code>在前，<code>4E</code>在后，这是 Little endian 方式。</p><p>这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-endian)敲开还是从小头(Little-endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。</p><p>第一个字节在前，就是”大头方式”（Big endian），第二个字节在前就是”小头方式”（Little endian）。</p><p>那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？</p><p>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用<code>FEFF</code>表示。这正好是两个字节，而且<code>FF</code>比<code>FE</code>大<code>1</code>。</p><p>如果一个文本文件的头两个字节是<code>FE FF</code>，就表示该文件采用大头方式；如果头两个字节是<code>FF FE</code>，就表示该文件采用小头方式。</p><h2 id="七、实例"><a href="#七、实例" class="headerlink" title="七、实例"></a>七、实例</h2><p><code>严</code>字，依次采用<code>Unicode</code>，<code>Unicode big endian</code>和<code>UTF-8</code>编码方式保存。</p><p>1）Unicode：编码是四个字节<code>FF FE 25 4E</code>，其中<code>FF FE</code>表明是小头方式存储，真正的编码是<code>4E25</code>。</p><p>2）Unicode big endian：编码是四个字节<code>FE FF 4E 25</code>，其中<code>FE FF</code>表明是大头方式存储。</p><p>3）UTF-8：编码是六个字节<code>EF BB BF E4 B8 A5</code>，前三个字节<code>EF BB BF</code>表示这是UTF-8编码，后三个<code>E4B8A5</code>就是<code>严</code>的具体编码，它的存储顺序与编码顺序是一致的。（注意 UTF-8 并没有 Little endian 和 Big endian 之分）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、ASCII-码&quot;&gt;&lt;a href=&quot;#一、ASCII-码&quot; class=&quot;headerlink&quot; title=&quot;一、ASCII 码&quot;&gt;&lt;/a&gt;一、ASCII 码&lt;/h2&gt;&lt;p&gt;我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有&lt;co
      
    
    </summary>
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%8E%9F%E7%A0%81,%20%E5%8F%8D%E7%A0%81,%20%E8%A1%A5%E7%A0%81/"/>
    <id>http://yoursite.com/计算机基础/原码, 反码, 补码/</id>
    <published>2020-08-15T09:01:58.223Z</published>
    <updated>2020-05-11T14:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 32 位机器上，int 的范围是 <code>[-2^31, 2^31-1]</code>，为什么正数和负数的范围不对称？</p><h2 id="一、机器数和真值"><a href="#一、机器数和真值" class="headerlink" title="一、机器数和真值"></a>一、机器数和真值</h2><p>在学习原码，反码和补码之前，需要先了解机器数和真值的概念</p><h3 id="机器数"><a href="#机器数" class="headerlink" title="机器数"></a>机器数</h3><p>机器数：一个数在计算机中的二进制表示形式。其最高位存放符号，正数为0，负数为1</p><p>比如 -3 的机器数就是 10000011</p><h3 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h3><p>第一位是符号位，真值就是将符号考虑进去进行计算的值。</p><p>比如：1000 0001 的真值是 -1，而不是 129</p><h2 id="二、原码，反码，补码的基础概念和计算方法"><a href="#二、原码，反码，补码的基础概念和计算方法" class="headerlink" title="二、原码，反码，补码的基础概念和计算方法"></a>二、原码，反码，补码的基础概念和计算方法</h2><p>在探求为何机器要使用补码之前，让我们先了解原码，反码和补码的概念。对于一个数，计算机要使用一定的编码方式进行存储。原码，反码，补码是机器存储一个具体数字的编码方式</p><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p><strong>原码就是用第一位表示符号，其余位表示值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1]原 = 0000 0001</span><br><span class="line">[-1]原 = 1000 0001</span><br></pre></td></tr></table></figure><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><ul><li><strong>正数的反码是其本身</strong></li><li><strong>负数的反码是在其原码的基础上，符号位不变，其余各个位取反</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1]反 = 0000 0001</span><br><span class="line">[-1]反 = 1111 1110</span><br></pre></td></tr></table></figure><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><ul><li><strong>正数的补码就是其本身</strong></li><li><strong>负数的补码是在反码的基础上+1</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[+1]补 = 0000 0001</span><br><span class="line">[-1]补 = 1111 1111</span><br><span class="line">[0] 补 = 0000 0000</span><br><span class="line">[-8]补 = 1000 0000</span><br></pre></td></tr></table></figure><h2 id="三、为何要使用原码，反码和补码"><a href="#三、为何要使用原码，反码和补码" class="headerlink" title="三、为何要使用原码，反码和补码"></a>三、为何要使用原码，反码和补码</h2><p>对于正数三种编码方式的结果都相同</p><p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p><p>但是对于负数:</p><p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p><p>原码是被人脑直接识别并用于计算表示方式，为何还会有反码和补码呢?</p><p>由于计算机识别符号位会变复杂，因此计算时<strong>使用加法替代减法</strong></p><p><strong>如果用原码表示，对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</span><br></pre></td></tr></table></figure><p>为了能够使正负相加得 0，出现了反码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 - 1 = 1 + (-1) = [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</span><br></pre></td></tr></table></figure><p><strong>发现用反码计算减法，结果的真值部分是正确的，却会出现 +0 和 -0</strong></p><p>虽然人们理解上+0和-0是一样的，但是0带符号是没有任何意义的。而且会有[0000 0000]原和[1000 0000]原两个编码表示0</p><p><strong>我们希望只有一个 0，所以发明了补码</strong></p><p>之前相加会得到各个位都是 1，所以规定补码为在反码的基础上 +1，这样相加之后每个 1 都会变成 0，多出的进位直接抛弃</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 - 1 = 1 + (-1) = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原</span><br></pre></td></tr></table></figure><p>这样0用 <code>[0000 0000]</code> 表示，而以前出现问题的-0则不存在了。而且可以用[1000 0000]表示-128:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</span><br></pre></td></tr></table></figure><p><strong>使用补码，不仅仅修复了0的符号，而且还能够多表示一个最小值</strong></p><p>这就是为什么8位机器下，使用原码或反码表示的范围为[-127,+127]，而使用补码表示的范围为[-128,127]</p><blockquote><p>因为机器使用补码，所以对于编程中常用到的32位int类型，可以表示范围是: [-2^31,2^31-1] 因为第一位表示的是符号位。而使用补码表示时又可以多保存一个最小值</p></blockquote><h2 id="四、补码是怎么来的"><a href="#四、补码是怎么来的" class="headerlink" title="四、补码是怎么来的"></a>四、补码是怎么来的</h2><h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><p>首先介绍一个数学中相关的概念: 同余</p><p>两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余</p><p>记作 a ≡ b (mod m)</p><p>读作 a 与 b 关于模 m 同余</p><p>举例说明:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 mod 12 = 4</span><br><span class="line">16 mod 12 = 4</span><br><span class="line">28 mod 12 = 4</span><br></pre></td></tr></table></figure><p>所以4，16，28关于模 12 同余</p><h3 id="负数取模"><a href="#负数取模" class="headerlink" title="负数取模"></a>负数取模</h3><p>加上 mod 右边的数的倍数即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-3 mod 2 = (-3+2*2) mod 2 = 1</span><br><span class="line">-2 mod 12 = (-2+12) mod 12 = 10</span><br></pre></td></tr></table></figure><h3 id="补码与取模"><a href="#补码与取模" class="headerlink" title="补码与取模"></a>补码与取模</h3><p>如果当前时间是6点，我希望将时间设置成4点，我们可以:</p><ol><li><p>往回拨2个小时: 6 - 2 = 4</p></li><li><p>往前拨10个小时: (6 + 10) mod 12 = 4</p></li></ol><p>在这个例子中，我们忽略了钟表是否多转了一圈，只考虑了当前时间点对不对，实际上就是只考虑对 12 个小时取余的结果对不对</p><p>-2 被我们看成是 +10，因为 -2 和 +10 是关于模 12 同余</p><p>同理，在补码的计算中，在 n 位机器上，补码与原码是关于模 2^(n-1) 同余</p><p>以 8 位为例，负数的补码与原码相加得到 1000 0000，即 128，这个 128 就好比钟表的 12 个小时</p><p>我们首先忽略符号位，只考虑剩下7位的值对不对。比如加 -1 和加 +127 就是等价的</p><p>2-1 = 2+(-1) = [0000 0010]原 + [1000 0001]原= [0000 0010]补 + [1111 1111]补</p><p>忽略符号位，-1 的原码是 000 0001，好比向前拨 2 个小时；补码是 111 1111，好比向后拨 10 个小时</p><p>那么， 2 + (-1) 与 2 + (127) 在 7 位比特位中的值一定是一样的。我们忽略了溢出，只考虑了对 111 1111 取余；正如我们忽略钟表多转一圈还是少转一圈，只考虑了对 12 个小时取余</p><h3 id="符号位"><a href="#符号位" class="headerlink" title="符号位"></a>符号位</h3><p>在补码和取模的讨论中，包括钟表的例子，我们都只看了余数，而回避了符号位的问题，现在着重看下符号位的计算</p><p>我们知道，在补码中，正数的符号位是 0，负数是 1</p><p>正数和正数、负数和负数相加可能会有溢出问题，比如 127+1，-127-1，此时的符号位都是不对的，溢出的情况我们不考虑</p><p>a+b，有以下 3 种可能</p><ul><li>a+b = 0</li><li>a+b &lt; 0</li><li>a+b &gt; 0</li></ul><p>以 8 位为例</p><p>我们知道由于引入了补码，所以 a+b = 0 的结果必然是 <code>[0000 0000]</code></p><p>以 -3+1 为例，-3+1 = -2+(-1)+1 = -2 + 0，由于 0 是 <code>[0000 0000]</code>，注意我们舍弃了相加等于0的进位，所以符号位由 -2 确定</p><p>a+b &gt; 0 同理</p><p>这就是补码运算中符号位是正确的原因</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 32 位机器上，int 的范围是 &lt;code&gt;[-2^31, 2^31-1]&lt;/code&gt;，为什么正数和负数的范围不对称？&lt;/p&gt;
&lt;h2 id=&quot;一、机器数和真值&quot;&gt;&lt;a href=&quot;#一、机器数和真值&quot; class=&quot;headerlink&quot; title=&quot;一、机器数
      
    
    </summary>
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/RESTful%20API/"/>
    <id>http://yoursite.com/计算机基础/RESTful API/</id>
    <published>2020-08-15T09:01:58.220Z</published>
    <updated>2020-05-11T14:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-REST"><a href="#什么是-REST" class="headerlink" title="什么是 REST"></a>什么是 REST</h2><p>REST：REpresentational State Transfer，直译就是 “表现层状态转移”</p><p>通俗地讲就是，URL 定位资源，用 HTTP 动词（GET,POST,PUT,DELETE）描述操作</p><ul><li>Resource：资源，即数据</li><li>Representational：某种表现形式，比如用 JSON，XML，JPEG 等</li><li>State Transfer：状态变化。通过 HTTP 动词实现</li></ul><p>REST 本身不实用，实用的是如何设计 RESTful API</p><h2 id="什么是-RESTful-API"><a href="#什么是-RESTful-API" class="headerlink" title="什么是 RESTful API"></a>什么是 RESTful API</h2><p>RESTful API 就是 REST 风格的 API，它使用一套协议来规范多种形式的前端和同一个后台的交互方式</p><p>RESTful 是基于 HTTP 协议，设计原则如下：</p><ol><li><p>对资源的操作。资源就是一段文本、一张图片或一段视频。资源总是要通过一种载体来反应它的内容，比如文本用 txt，图片用 png 或 jpg，而 JSON 是现在最常用的资源表现形式</p></li><li><p>使用 HTTP 动词来实现增删改查。RESTful API 对资源的 CRUD（create,read,update,delete）分别对应 HTTP 的方法：GET 用来获取资源，POST 用来新建资源（也可以用于更新资源），PUT 用来更新资源，DELETE 用来删除资源</p></li><li><p>使用 URI（统一资源定位符）。每个 URI 都对应一个特定的资源，最典型的 URI 就是 URL。每个网址代表一种资源，所以网址中不能有动词，只能有名词</p></li><li><p>无状态。所有的资源都可以 URI 定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而变化。比如查询工资的接口必须在员工请求登录接口之后才能查询，它就不属于无状态的</p></li></ol><p>其他规范：</p><ul><li>将 API 的版本号放入 URL，比如 <code>https://api.example.com/v1/</code></li><li><p>一般 API 中的名字都使用复数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com/v1/zoos</span><br><span class="line">https://api.example.com/v1/animals</span><br><span class="line">https://api.example.com/v1/posts</span><br></pre></td></tr></table></figure></li></ul><h2 id="For-Example"><a href="#For-Example" class="headerlink" title="For Example"></a>For Example</h2><p>GET:<code>http://api.example.com/posts/123</code> 表示获取 ID 为 123 的帖子</p><p>GET:<code>http://api.example.com/posts</code> 表示获取所有帖子列表</p><p>DELETE:<code>http://api.example.com/posts/123</code> 则为对应的删除操作</p><p>错误的示例：<code>http://api.example.com/getPosts/123</code> or <code>http://api.example.com/getPosts/123</code>，这里网址中有了动词，并不是通过 HTTP 动词来实现增删改查</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/hjc1984117/article/details/77334616" target="_blank" rel="noopener">《什么是 RESTful API？》</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">《RESTful API 设计指南》</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是-REST&quot;&gt;&lt;a href=&quot;#什么是-REST&quot; class=&quot;headerlink&quot; title=&quot;什么是 REST&quot;&gt;&lt;/a&gt;什么是 REST&lt;/h2&gt;&lt;p&gt;REST：REpresentational State Transfer，直译就是 “表现层
      
    
    </summary>
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://yoursite.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Git/"/>
    <id>http://yoursite.com/计算机基础/Git/</id>
    <published>2020-08-15T09:01:58.217Z</published>
    <updated>2020-05-11T14:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2><h3 id="列出本地-Tag"><a href="#列出本地-Tag" class="headerlink" title="列出本地 Tag"></a>列出本地 Tag</h3><p><code>git tag</code></p><h3 id="本地添加-Tag"><a href="#本地添加-Tag" class="headerlink" title="本地添加 Tag"></a>本地添加 Tag</h3><p><code>git tag v1.0.0</code></p><h3 id="删除本地-Tag"><a href="#删除本地-Tag" class="headerlink" title="删除本地 Tag"></a>删除本地 Tag</h3><p><code>git tag -d v1.0.0</code></p><h3 id="把本地-Tag-推送到远程"><a href="#把本地-Tag-推送到远程" class="headerlink" title="把本地 Tag 推送到远程"></a>把本地 Tag 推送到远程</h3><p><code>git push --tags</code></p><h3 id="删除远程-Tag"><a href="#删除远程-Tag" class="headerlink" title="删除远程 Tag"></a>删除远程 Tag</h3><p><code>git push origin -d tag 0.0.2</code></p><h3 id="远程-Tag-删除，本地还在"><a href="#远程-Tag-删除，本地还在" class="headerlink" title="远程 Tag 删除，本地还在"></a>远程 Tag 删除，本地还在</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -l | xargs git tag -d</span><br><span class="line">git fetch --tags</span><br></pre></td></tr></table></figure><h3 id="重命名远程-Tag"><a href="#重命名远程-Tag" class="headerlink" title="重命名远程 Tag"></a>重命名远程 Tag</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git tag new old</span><br><span class="line">git tag -d old</span><br><span class="line">git push origin :refs/tags/old</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><h3 id="一个-Log-只占一行，用于快速浏览"><a href="#一个-Log-只占一行，用于快速浏览" class="headerlink" title="一个 Log 只占一行，用于快速浏览"></a>一个 Log 只占一行，用于快速浏览</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline</span><br></pre></td></tr></table></figure><h3 id="展示某个提交的具体细节"><a href="#展示某个提交的具体细节" class="headerlink" title="展示某个提交的具体细节"></a>展示某个提交的具体细节</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show ace518d5172459d95cad6a21efe2ac6068011f2d</span><br></pre></td></tr></table></figure><h3 id="修改最后一次-Commit-信息"><a href="#修改最后一次-Commit-信息" class="headerlink" title="修改最后一次 Commit 信息"></a>修改最后一次 Commit 信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><h3 id="撤销本地未-add-的更改"><a href="#撤销本地未-add-的更改" class="headerlink" title="撤销本地未 add 的更改"></a>撤销本地未 add 的更改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -df</span><br></pre></td></tr></table></figure><h3 id="撤销本地已-add-没-commit-的更改"><a href="#撤销本地已-add-没-commit-的更改" class="headerlink" title="撤销本地已 add 没 commit 的更改"></a>撤销本地已 add 没 commit 的更改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard</span><br></pre></td></tr></table></figure><h2 id="git-stauts-中文乱码"><a href="#git-stauts-中文乱码" class="headerlink" title="git stauts 中文乱码"></a>git stauts 中文乱码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Tag&quot;&gt;&lt;a href=&quot;#Tag&quot; class=&quot;headerlink&quot; title=&quot;Tag&quot;&gt;&lt;/a&gt;Tag&lt;/h2&gt;&lt;h3 id=&quot;列出本地-Tag&quot;&gt;&lt;a href=&quot;#列出本地-Tag&quot; class=&quot;headerlink&quot; title=&quot;列出本地 
      
    
    </summary>
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E7%BD%91%E7%BB%9C/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/网络/重放攻击/</id>
    <published>2020-08-15T09:01:58.206Z</published>
    <updated>2020-05-11T14:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天想从【今日热榜】这个 App 中获取榜单的 Get 请求，从而可以“借”它们的数据做个榜单类的小程序。用 Charles 抓手机的包之后，发现可以抓取到一个 Get 请求，回包的内容也正确被抓取了，可是当我复制这段 Get 请求的 url 到浏览器的时候，发现没有对应的回包了</p><p>奇怪，为什么会这样呢，决定开始研究下</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>url 是类似以下结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://api.tophub.today/nodes/128?nonce=xxx&amp;sign=yyy&amp;timestamp=123</span><br></pre></td></tr></table></figure><p>主要有 3 个字段：<code>nonce</code>、<code>sign</code> 和 <code>timestamp</code></p><p>基于这几个关键词去搜索，发现原来我这种行为属于【重放攻击】</p><h2 id="什么是重放攻击"><a href="#什么是重放攻击" class="headerlink" title="什么是重放攻击"></a>什么是重放攻击</h2><p>假如我们要通过 Get 请求传递用户的用户名和密码，明文传输的例子如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://api.tophub.today/nodes/128?id=hello&amp;password=1234</span><br></pre></td></tr></table></figure><p>这是裸奔，我们没这么蠢，于是对 password 进行 MD5 加密之后再传输，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://api.tophub.today/nodes/128?id=hello&amp;sign=md5(password)</span><br></pre></td></tr></table></figure><p>其中 sign 的常用加密算法为 MD5，MD5 算法是一种不可逆算法，也就是说你加密之后就不能解密了</p><p>服务器的验证方法就是根据 id 从数据库查出用户的密码，再对其进行 MD5 加密，得到的结果与 sign 的值进行对比，如果相同则请求合法，反之则 sign 被篡改过</p><p>黑客通过抓包获取到该链接，他无法破解加密信息得到用户密码；但是他只要模拟此次的正常请求，就可以伪装成客户端同服务器通信。这样至少可以做两件事，第一件是跟我一样，可以随时随地模拟客户端取服务器的数据；第二件事是可以疯狂发送该请求致使服务器繁忙</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/16/162cd376398b884c" alt></p><h2 id="如何防止重放攻击"><a href="#如何防止重放攻击" class="headerlink" title="如何防止重放攻击"></a>如何防止重放攻击</h2><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>首先我们假设一次 HTTP 请求从发出到到达服务器的时间是不会超过 60s 的，而黑客获取链接到篡改链接再发送到服务的时间会超过 60s（不要问为什么是 60s，继续往下看）</p><p>当你发送一个请求时必须携带一个当前的时间戳 timestamp。假设值为 10</p><p>为了防止黑客修改时间戳，需要将 timestamp 也进行 MD5，放到 sign 中，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=hello&amp;sign=md5(password+timestamp)&amp;timestamp=10</span><br></pre></td></tr></table></figure><p>当请求到达服务器之后，服务器会获取当前时间，假设为 t2 = 80，很明显 t2 - timestamp &gt; 60s，那么服务器就认为请求不合法。因为这个请求从客户端到服务器的时间竟然超过 60s。如果在 60s 内，再进行一次 md5 校验，检查 timestamp 有没有被篡改（一旦 timestamp 被篡改过，算出来的 md5 值一定与 sign 不同）</p><p>问题来了，如果黑客在 60s 内发起请求，这种方法就失效了</p><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p>我们加入一个随机数 nonce，每次成功请求，服务器会保存当前成功请求的随机数 nonce 到缓存或数据库中，当请求再次进到服务器，判断携带的随机数 nonce 是否在缓存或者数据库中已经存在，如果存在，则认为请求非法</p><p>url 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=hello&amp;sign=md5(password+nonce)&amp;nonce=31415</span><br></pre></td></tr></table></figure><p>同理，为了防止 nonce 被篡改，需要将 nonce 进行 MD5 加密到 sign</p><p>随机数的出现保证了请求的唯一性，但是存储 nonce 的集合会越来越大，为了防止 nonce 集合无限大，需要定期清理该集合，但是一旦该集合被清理，我们就无法验证被清理了的 nonce 参数了。<br>比如，假设该集合平均1天清理一次的话，我们抓取到的该 url，虽然当时无法进行重放攻击，但是我们还是可以每隔一天进行一次重放攻击的。而且存储24小时内，所有请求的 nonce 参数，也是一笔不小的开销</p><p>当然随机数还得确保唯一性</p><h3 id="时间戳-随机数"><a href="#时间戳-随机数" class="headerlink" title="时间戳+随机数"></a>时间戳+随机数</h3><p>时间戳屏蔽了 60s 后的请求，而 60s 内重复的请求可以用随机数来过滤</p><p>url 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=hello&amp;sign=md5(password+timestamp+nonce)&amp;timestamp=10&amp;nonce=31415</span><br></pre></td></tr></table></figure><p>配合时间戳，服务器只要每次有新的请求进来的时候，确保此次请求没有被篡改的前提下，如果新请求带来的 timestamp 比最后一次更新 nonce 集合的时间晚 60秒，那么就可以清除 nonce 缓存了</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 time 参数是否有效</span></span><br><span class="line"><span class="keyword">if</span> ($curTime - $time &gt; <span class="number">60</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"请求超时"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 nonce 参数是否在集合已存在</span></span><br><span class="line"><span class="keyword">if</span> (in_array($nonce, $nonceArray))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"请求仅一次有效"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证数字签名    </span></span><br><span class="line"><span class="keyword">if</span> ($sign != md5($password.$time.$nonce))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"数字签名验证失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否需要清理nonce集合</span></span><br><span class="line"><span class="keyword">if</span> ($curTime - $nonceArray-&gt;lastModifyTime &gt; <span class="number">60</span>)</span><br><span class="line">&#123;</span><br><span class="line">    $nonceArray = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录本次请求的 nonce 参数</span></span><br><span class="line">$nonceArray.push($nonce);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始处理合法的请求</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://juejin.im/post/5ad43b86f265da239236cedc" target="_blank" rel="noopener">Web安全防范—–防止重放攻击</a></p></li><li><p><a href="https://juejin.im/entry/5a616e836fb9a01ca602de40" target="_blank" rel="noopener">基于timestamp和nonce的防止重放攻击方案</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;今天想从【今日热榜】这个 App 中获取榜单的 Get 请求，从而可以“借”它们的数据做个榜单类的小程序。用 Charles 抓手机的包之后
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/网络/计算机网络基础/</id>
    <published>2020-08-15T09:01:58.203Z</published>
    <updated>2020-05-11T14:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OSI-七层模型、TCP-IP-五层模型、与-TCP-IP-四层模型"><a href="#OSI-七层模型、TCP-IP-五层模型、与-TCP-IP-四层模型" class="headerlink" title="OSI 七层模型、TCP/IP 五层模型、与 TCP/IP 四层模型"></a>OSI 七层模型、TCP/IP 五层模型、与 TCP/IP 四层模型</h2><p><img src="https://imgedu.lagou.com/1564356-20190114213911224-1280776162.jpg" alt="七层、五层、四层模型"></p><h2 id="数据传递时，每层都会在上一层的报文添加自己的头部"><a href="#数据传递时，每层都会在上一层的报文添加自己的头部" class="headerlink" title="数据传递时，每层都会在上一层的报文添加自己的头部"></a>数据传递时，每层都会在上一层的报文添加自己的头部</h2><p><img src="https://images0.cnblogs.com/blog/453763/201411/181457256295966.png" alt></p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>HTTP、FTP、SMTP、DNS</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>TCP、UDP</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>IP、ICMP（Internet 控制报文协议）</p><blockquote><p>ping 使用的是 ICMP 协议</p></blockquote><h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><p>ARP、RARP</p><p>ARP：IP 地址 -&gt; MAC 地址<br>RARP：MAC 地址 -&gt; IP 地址</p><h3 id="问：ARP-属于哪一层"><a href="#问：ARP-属于哪一层" class="headerlink" title="问：ARP 属于哪一层"></a>问：ARP 属于哪一层</h3><p>TCP/IP 模型中，它所有定义的协议是在网络层上的</p><p>按照 OSI 的标准，数据在传递时每层会加上自己的信息。当网络层的 IP 包进入链路层时，链路层通过 ARP 协议添加链路信息，因此属于链路层</p><p>在 OSI 七层模型中 ARP 协议属于链路层；而在 TCP/IP 模型中，ARP 协议属于网络层</p><h3 id="问：当在浏览器中输入-www-baidu-com-的时候发生了什么"><a href="#问：当在浏览器中输入-www-baidu-com-的时候发生了什么" class="headerlink" title="问：当在浏览器中输入 www.baidu.com 的时候发生了什么"></a>问：当在浏览器中输入 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 的时候发生了什么</h3><p>一、DNS 域名解析<br>先查本地 hosts 文件，如果没命中则主机会向 DNS 服务器发送一条 DNS 查询报文以查询该域名对应的 IP</p><blockquote><p>注意，该报文是 UDP 报文，不需要与 DNS 服务器建立 TCP 连接；我们这台主机本来就知道 DNS 服务器的 IP 地址，要么是写好的静态 IP，要么是路由器动态分配的 IP，不是域名，所以 DNS 查询这个过程也不需要去解析域名</p></blockquote><p>二、建立 TCP 连接<br>传输层拿到了应用层解析到的 IP 地址，开始与服务器进行三次握手，建立 TCP 连接</p><p>三、发送 HTTP 请求<br>建立连接后，应用层开始向服务器发送请求，服务器返回相应的结果</p><p>四、关闭 TCP 连接<br>为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建 TCP 连接的 3 次握手类似，关闭 TCP 连接，需要 4 次握手。</p><p>五、浏览器解析 HTML、JS、CSS、Json<br>Dom 数、CSS 规则集、Render 树</p><p><img src="https://pic3.zhimg.com/80/v2-f7473c255fd30b53cb32e08da905b2fe_1440w.jpg" alt="Webkit 主流程"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;OSI-七层模型、TCP-IP-五层模型、与-TCP-IP-四层模型&quot;&gt;&lt;a href=&quot;#OSI-七层模型、TCP-IP-五层模型、与-TCP-IP-四层模型&quot; class=&quot;headerlink&quot; title=&quot;OSI 七层模型、TCP/IP 五层模型、与 T
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E7%BD%91%E7%BB%9C/TCP%20%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://yoursite.com/网络/TCP 四次挥手/</id>
    <published>2020-08-15T09:01:58.199Z</published>
    <updated>2020-05-11T14:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="四次挥手的过程"><a href="#四次挥手的过程" class="headerlink" title="四次挥手的过程"></a>四次挥手的过程</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/8/16da9fd28b49f652" alt></p><p>TCP 三次握手，一定是客户端先发起连接；而 TCP 四次挥手，发起中断连接的既可以是客户端，也可以是服务器。</p><p>本文以客户端先发起请求为例，刚开始双方都处于 ESTABLISHED 状态。</p><ol><li>从报文的角度上看，四次挥手的过程如下：</li></ol><ul><li><p>第一次挥手：客户端发送一个 FIN 报文（FIN=1，seq=u），进入 FIN_WAIT1 状态，等待服务端的确认，并停止发送数据</p></li><li><p>第二次挥手：服务端回复 ACK 报文（ACK=1，ack=u+1，seq=v），表明已经收到客户端的报文了，进入 CLOSE_WAIT 状态</p><p>  客户端收到服务端的确认后，进入 FIN_WAIT2 状态，等待服务端的 FIN 报文。</p></li><li><p>第三次挥手：如果服务端数据发送完毕想断开连接了，发送 FIN 报文（FIN=1，ACK=1，seq=w，ack=u+1）。进入 LAST_ACK 的状态，等待客户端的确认。</p></li><li><p>第四次挥手：客户端回复 ACK 报文（ACK=1，seq=u+1，ack=w+1），进入 TIME_WAIT 状态，等待 <code>2MSL</code> 后进入 CLOSED 状态；服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状</p></li></ul><ol start="2"><li>从发送和接受数据的能力上看，四次挥手的过程如下：</li></ol><ul><li><p>第一次挥手：客户端不再发送数据；服务器知道客户端不再发送数据</p></li><li><p>第二次挥手：服务器对客户端 FIN 的确认，依然可能继续发送数据；客户端收到后会继续接收数据</p></li><li><p>第三次挥手：服务器数据发送完毕后发起第三次挥手，表示服务器不再发送数据；客户端收到后会等 2MSL 后关闭连接，不再接收数据</p></li><li><p>第四次挥手：服务器收到后关闭连接</p></li></ul><h2 id="什么是-MSL，为什么需要等-2MSL"><a href="#什么是-MSL，为什么需要等-2MSL" class="headerlink" title="什么是 MSL，为什么需要等 2MSL"></a>什么是 MSL，为什么需要等 2MSL</h2><p>MSL（Maximum Segment Lifetime），即报文段最大生存时间。可以简单理解为，报文段在网络内存在的最长时间，如果超过这个时间，报文段就会被丢弃。</p><p>根据第三版《UNIX 网络编程 卷 1》2.7 节，TIME_WAIT 状态的主要目的有两个：</p><ul><li>优雅的关闭 TCP 连接，也就是尽量保证被动关闭的一端收到它自己发出去的 FIN 报文的 ACK 确认报文；</li><li>处理延迟的重复报文，这主要是为了避免前后两个使用相同四元组的连接中的前一个连接的报文干扰后一个连接。</li></ul><blockquote><p>注：很多博文只讨论了第一点，并且轻易的给出了错误的理由：最坏情况，ACK 报文的发送和 FIN 报文的重传各自需要 1MSL，因此是 2MSL。仔细想想之后，这些人的文章简直就是不经脑子的生搬硬套</p></blockquote><p>假设 A 是主动关闭的一方，B 是被动关闭。</p><p>假如现在 A 收到 FIN 之后，为了实现目标 1，即保证 B 能够收到自己的 ACK 报文。那么 A 完美的等待时间不是 2MSL，而应该是从 B 发送第一个 FIN 报文开始计时到它最后一次重传 FIN 报文这段时长加上 MSL。但这个计算方式过于保守，只有在所有的 ACK 报文都丢失的情况下才需要这么长的时间；另外，第一个目标虽然重要，但并不十分关键，因为既然已经到了关闭连接的最后一步，说明在这个 TCP 连接上的所有用户数据已经完成可靠传输，所以要不要完美的关闭这个连接其实已经不是那么关键了。因此，（我猜）RFC 标准的制定者才决定以网络丢包不太严重为前提条件，然后根据第二个目标来计算 TIME_WAIT 状态应该持续的时长。</p><p>等待 2MSL 的真正目的是为了避免前后两个使用相同四元组的连接中的前一个连接的报文干扰后一个连接，换句话说，就是为了让此次 TCP 连接中的所有报文在网络中消失。</p><p>假如现在 A 发送 ACK 后，最坏情况下，这个 ACK 在 1MSL 时到达 B；此时 B 在收到这个 ACK 的前一刹那，一直在重传 FIN，这个 FIN 最坏会在 1MSL 时间内消失。因此从 A 发送 ACK 的那一刹那开始，等待 2MSL 可以保证 A 发送的最后一个 ACK，和 B 发送的最后一个 FIN 都在网络中消失</p><blockquote><p>注：B 超时重传的时间并不是 2MSL；2MSL 时间为 240 秒，这是协议标准，一般超时重传只有 0.5 秒、1 秒、2 秒、4 秒……小于 MSL</p></blockquote><h2 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h2><p>类比 TCP 的三次握手，这个问题可以理解为为什么服务器的 ACK 报文和 FIN 报文不能合并在一起发送？</p><p>原因是第一次挥手仅仅代表着客户端不再发送数据，而服务器收到 ACK 之后，可能还有数据想要发送给客户端，所以等待服务器发送完毕数据之后，才会继续发送 FIN 报文，因此无法合并发送</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://juejin.im/post/5d9c284b518825095879e7a5" target="_blank" rel="noopener">面试官，不要再问我三次握手和四次挥手</a></li><li><a href="https://cloud.tencent.com/developer/article/1450264" target="_blank" rel="noopener">为什么 tcp 的 TIME_WAIT 状态要维持 2MSL</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;四次挥手的过程&quot;&gt;&lt;a href=&quot;#四次挥手的过程&quot; class=&quot;headerlink&quot; title=&quot;四次挥手的过程&quot;&gt;&lt;/a&gt;四次挥手的过程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/10/8/
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E7%BD%91%E7%BB%9C/TCP%20%E4%B8%8E%20UDP/"/>
    <id>http://yoursite.com/网络/TCP 与 UDP/</id>
    <published>2020-08-15T09:01:58.196Z</published>
    <updated>2020-05-11T14:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><table><thead><tr><th></th><th>UDP</th><th>TCP</th></tr></thead><tbody><tr><td>是否连接</td><td>无连接</td><td>面向连接（三次握手）</td></tr><tr><td>是否可靠</td><td>不可靠传输，不使用流量控制和拥塞控制</td><td>可靠传输，有序列号，确认号，超时重传等，使用流量控制和拥塞控制</td></tr><tr><td>连接对象个数</td><td>支持一对一，一对多，多对一和多对多通信</td><td>只能是一对一</td></tr><tr><td>传输方式</td><td>面向报文</td><td>面向字节流</td></tr><tr><td>首部开销</td><td>首部开销小，仅 8 字节</td><td>首部最小 20 字节，最大 60 字节</td></tr><tr><td>适用场景</td><td>适用于实时应用（微信语音、视频聊天）</td><td>适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>UDP <strong>无连接，不可靠，传输快</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对比&quot;&gt;&lt;a href=&quot;#对比&quot; class=&quot;headerlink&quot; title=&quot;对比&quot;&gt;&lt;/a&gt;对比&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;UDP&lt;/th&gt;
&lt;th&gt;TCP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E7%BD%91%E7%BB%9C/TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    <id>http://yoursite.com/网络/TCP 三次握手/</id>
    <published>2020-08-15T09:01:58.191Z</published>
    <updated>2020-05-11T14:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三次握手的过程"><a href="#三次握手的过程" class="headerlink" title="三次握手的过程"></a>三次握手的过程</h2><p><img src="https://segmentfault.com/img/remote/1460000020610340" alt></p><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。</p><ul><li><p>第一次握手：客户端发送 SYN=1，seq=x（SYN=1 的报文段不能携带数据，但要消耗掉一个序号），此时客户端处于 <code>SYN_SENT</code> 状态</p></li><li><p>第二次握手：服务器回复 SYN=1，ACK=1，ack=x+1，seq=y，此时服务器处于 <code>SYN_RCVD</code> 的状态</p></li><li><p>第三次握手：客户端回复 ACK=1，ack=y+1，seq=x+1，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</p></li></ul><p>ACK 报文段可以携带数据，不携带数据则不消耗序号</p><blockquote><p>注意：不要混淆 ACK 标志位和 ack 确认序列号，ACK 标记位为 1 表示这是包一个确认包，而 ack 确认序列号是 Acknowledgement Number，是对对方初始序列号的回复（ack = x+1），对方以此确认该报文是对其 SYN 报文的回复。ack 确认序列号只有在 ACK 标记位为 1 时才有效</p></blockquote><h2 id="为什么是三次握手"><a href="#为什么是三次握手" class="headerlink" title="为什么是三次握手"></a>为什么是三次握手</h2><p>TCP 的可靠连接是靠 seq（sequence numbers 序列号）来达成的。</p><p>TCP 设计中一个基本设定就是，通过 TCP 连接发送的每一个包，都有一个 sequence number。而因为每个包都是有序列号的，所以都能被确认收到这些包。</p><p>确认机制是累计的，所以一个对 sequence number X 的确认，意味着 X 序列号之前 (不包括 X) 包都是被确认接收到的。</p><p>所以这样就有一个问题：这条连接突然断开重连后，TCP 怎么样识别之前旧链接重发的包？这就需要独一无二的 ISN（初始序列号）机制。</p><p>那么 TCP 连接握手，握的是啥？</p><p><strong>三次握手是为了双方确定彼此的初始序列号</strong></p><blockquote><p>注意：seq = x，这个 x 就是初始序列号</p></blockquote><ol><li><p>如果是四次握手：</p><p> 1.1 A 发送同步信号 SYN + A 的初始序列号（Initial sequence number，简称 ISN）</p><p> 1.2 B 收到后回包，并记录 A 的初始序列号到本地</p><p> 1.3 B 发送同步信号 SYN + B 的初始序列号</p><p> 1.4 A 收到后回包，并记录 B 的初始序列号到本地</p><p> 这样，A 和 B 就互相确认了彼此的初始序列号。但很显然 1.2 和 1.3 这两个步骤可以合并，只需要三次握手</p></li><li><p>如果是两次握手</p><p> 2.1 A 发送同步信号 SYN + A 的初始序列号</p><p> 2.2 B 收到后，发送同步信号 SYN + B 的初始序列号</p><p> 这种情况，A 的初始序列号双方都知道；但是 B 的初始序列号，B 无法确定 A 是否知道</p></li></ol><h2 id="中途丢包的情况"><a href="#中途丢包的情况" class="headerlink" title="中途丢包的情况"></a>中途丢包的情况</h2><ol><li><p>第一个包，即 A 发给 B 的 SYN 中途被丢，没有到达 B</p><p> A 会周期性超时重传，直到收到 B 的确认</p></li><li><p>第二个包，即 B 发给 A 的 SYN+ACK 中途被丢，没有到达 A</p><p> B 会周期性超时重传，直到收到 A 的确认</p></li><li><p>第三个包，即 A 发给 B 的 ACK 中途被丢，没有到达 B</p><p> A 发完 ACK，单方面认为 TCP 为 Established 状态，而 B 显然认为 TCP 为 Active 状态</p><p> 这种情况下 A 会超时重传这个 ACK 吗？不会！TCP 不会为没有数据的 ACK 超时重传</p><p> a. 假定此时双方都没有数据发送，B 会周期性超时重传，直到收到 A 的确认，收到之后 B 的 TCP 连接也为 Established 状态，双向可以发包</p><p> b. 假定此时 A 有数据发送，B 收到 A 的 Data + ACK，自然会切换为 established 状态，并接受 A 的 Data</p><p> c. 假定 B 有数据发送，数据发送不了，会一直周期性超时重传 SYN + ACK，直到收到 A 的确认才可以发送数据</p></li></ol><h2 id="三次握手过程中可以携带数据吗？"><a href="#三次握手过程中可以携带数据吗？" class="headerlink" title="三次握手过程中可以携带数据吗？"></a>三次握手过程中可以携带数据吗？</h2><p>其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据</p><p>为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p><p>也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。</p><p>对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病</p><h2 id="SYN-攻击是什么？"><a href="#SYN-攻击是什么？" class="headerlink" title="SYN 攻击是什么？"></a>SYN 攻击是什么？</h2><p><strong>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的</strong>，所以服务器容易受到 SYN 洪泛攻击。</p><p>SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。</p><p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener">TCP 为什么是三次握手，而不是两次或四次？</a></li><li><a href="https://www.zhihu.com/question/63264012" target="_blank" rel="noopener">TCP 为什么是四次挥手，而不是三次？</a></li><li><a href="https://juejin.im/post/5d9c284b518825095879e7a5" target="_blank" rel="noopener">面试官，不要再问我三次握手和四次挥手</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;三次握手的过程&quot;&gt;&lt;a href=&quot;#三次握手的过程&quot; class=&quot;headerlink&quot; title=&quot;三次握手的过程&quot;&gt;&lt;/a&gt;三次握手的过程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://segmentfault.com/img/remote/1460
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E7%BD%91%E7%BB%9C/HTTPS/"/>
    <id>http://yoursite.com/网络/HTTPS/</id>
    <published>2020-08-15T09:01:58.188Z</published>
    <updated>2020-05-11T14:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>假如客户端要登录，将用户名和密码传到服务器</p><h3 id="如果使用-HTTP，会有什么问题"><a href="#如果使用-HTTP，会有什么问题" class="headerlink" title="如果使用 HTTP，会有什么问题"></a>如果使用 HTTP，会有什么问题</h3><p>HTTP 是明文传输，有以下问题</p><ol><li><p><strong>窃听风险</strong>：第三方可以获知通信内容（<strong>需要加密</strong>）</p></li><li><p><strong>篡改风险</strong>：第三方可以修改通信内容（<strong>需要校验</strong>）</p></li><li><p><strong>冒充风险</strong>：第三方可以冒充他人身份参与通信（<strong>需要信任——证书</strong>）</p></li></ol><h3 id="那我可以在客户端先加密，这样就不是明文传输了呀"><a href="#那我可以在客户端先加密，这样就不是明文传输了呀" class="headerlink" title="那我可以在客户端先加密，这样就不是明文传输了呀"></a>那我可以在客户端先加密，这样就不是明文传输了呀</h3><p>你这种属于对称加密，如果你的密钥是在通信过程中传输，那可能被截获，这样你的信息就泄漏了</p><h3 id="那服务器和客户端事先约定好密钥，而不是在通信时才传输，这样就不会泄漏了"><a href="#那服务器和客户端事先约定好密钥，而不是在通信时才传输，这样就不会泄漏了" class="headerlink" title="那服务器和客户端事先约定好密钥，而不是在通信时才传输，这样就不会泄漏了"></a>那服务器和客户端事先约定好密钥，而不是在通信时才传输，这样就不会泄漏了</h3><p>可以的，但是实际上这样做会很麻烦</p><h3 id="那你有什么更好的方法吗"><a href="#那你有什么更好的方法吗" class="headerlink" title="那你有什么更好的方法吗"></a>那你有什么更好的方法吗</h3><p>使用非对称加密，服务器维护公钥和密钥，通信时，客户端先向服务器端索要公钥，然后用公钥加密信息再传输，服务器收到密文后，用自己的私钥解密</p><h3 id="这里的公钥和私钥是什么"><a href="#这里的公钥和私钥是什么" class="headerlink" title="这里的公钥和私钥是什么"></a>这里的公钥和私钥是什么</h3><p>公开秘钥：简称公钥；私人秘钥：简称私钥</p><p>非对称加密的特点就是：</p><ol><li>私钥加密后的密文，所有公钥都可以解密（比如数字证书的生成）</li><li>公钥加密后的密文，只有私钥可以解密（比如服务器和客户端的加密流程）</li><li>私钥只有一个人有，而公钥可以发给所有的人</li></ol><p>那看起来很完美了呀</p><p>其实这样还有一个安全问题</p><h3 id="非对称加密还存在什么安全问题"><a href="#非对称加密还存在什么安全问题" class="headerlink" title="非对称加密还存在什么安全问题"></a>非对称加密还存在什么安全问题</h3><p>如果第三方拦截住了客户端的公钥请求，然后模仿了服务器的行为，传输给你他自己的公钥</p><p>同时，第三方也模拟了客户端向服务器发送公钥请求，得到了服务器的公钥</p><p>接着客户端就会把攻击者当做服务器，用假公钥把信息加密传给第三方，第三方再使用自己的私钥解密得到信息</p><p>同时，第三方得到了信息之后，模拟客户端使用服务器的公钥进行加密，再传给服务器</p><p>这个就是所谓的“中间人攻击”，通过这样的手段，便可以获取客户端和服务器之间通信的所有内容。</p><p><img src="https://s1.51cto.com/oss/201712/04/ada3b126f879a95e1e76edc0540b2597.jpg" alt></p><h3 id="那有什么方法防止中间人攻击吗"><a href="#那有什么方法防止中间人攻击吗" class="headerlink" title="那有什么方法防止中间人攻击吗"></a>那有什么方法防止中间人攻击吗</h3><p>有，使用<strong>CA（数字证书认证机构）</strong>颁发的<strong>数字证书</strong></p><p>证书就是服务器将信息（公钥、姓名、邮件等）提供给 CA，CA 把信息写到证书里，再用自己的私钥对这些信息进行加密形成证书的签名，再返回给服务器</p><blockquote><p>简单理解：证书 = CA 私钥对服务器公钥的加密结果</p></blockquote><p>现在服务器不再返回公钥给客户端，而是返回证书</p><p>客户端收到证书之后，只需要用 CA 的公钥解密证书的签名得到加密之前的散列值，再计算数字证书中信息（公钥、姓名、邮件等）的散列值，将两者进行对比，只要散列值一致，就证明这张证书没有被篡改过</p><h3 id="这个中间人攻击看起来很像-Charles-WireShark-的抓包"><a href="#这个中间人攻击看起来很像-Charles-WireShark-的抓包" class="headerlink" title="这个中间人攻击看起来很像 Charles/WireShark 的抓包"></a>这个中间人攻击看起来很像 Charles/WireShark 的抓包</h3><p>没错，抓包软件的原理就是中间人攻击，怪不得每次得信任证书是，只要客户端信任了 Charles 的证书，客户端就会把 Charles 当成服务器，Charles 变成了中间人，因此可以监听 HTTPS 的内容</p><h3 id="那客户端怎么得到正确的-CA-的公钥呢"><a href="#那客户端怎么得到正确的-CA-的公钥呢" class="headerlink" title="那客户端怎么得到正确的 CA 的公钥呢"></a>那客户端怎么得到正确的 CA 的公钥呢</h3><p>简单点说，操作系统和浏览器在设备出厂的时候就会内置很多根证书</p><h3 id="非对称加密计算量太大，如何减少耗用的时间？"><a href="#非对称加密计算量太大，如何减少耗用的时间？" class="headerlink" title="非对称加密计算量太大，如何减少耗用的时间？"></a>非对称加密计算量太大，如何减少耗用的时间？</h3><p>客户端得到正确的公钥之后，就可以使用对称加密来传播信息</p><p>客户端生成一个“会话密钥”，使用服务器的公钥对该密钥进行加密，将密钥密文传递给服务器。</p><p>服务器使用自己的密钥对密钥密文进行解密得到客户端密钥</p><p>接下来双方利用会话密钥，来实现对称加密的通信</p><p>每一次对话，客户端和服务器端都生成一个”会话密钥”（session key），用它来加密信息。由于”会话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”会话密钥”本身，这样就减少了加密运算的消耗时间</p><h3 id="HTTPS-整个工作流程"><a href="#HTTPS-整个工作流程" class="headerlink" title="HTTPS 整个工作流程"></a>HTTPS 整个工作流程</h3><p>HTTPS 主要分为两个过程：</p><ol><li><p>握手阶段：客户端向服务器端索要公钥；并协商 “会话密钥”</p></li><li><p>通信阶段：双方采用 “会话密钥” 进行加密通信</p></li></ol><p>其中握手阶段的流程图如下：</p><!-- ![](https://user-gold-cdn.xitu.io/2018/1/21/16117c2bdbee0af3) --><p><img src="http://ww1.sinaimg.cn/large/99e3e31egy1gb5jiuow58j20it0i2myg.jpg" alt="HTTPS.png"></p><p>我们看看整个流程：</p><ol><li>客户端生成一个随机数 RNc（即 Random Number of Client）并发送给服务器【Client-Hello 阶段】</li><li>服务器收到后生成 RNs（即 Random Number Of Server），并把 RNs 和证书（含公钥）返回给客户端【Server-Hello 阶段】</li><li>客户端校验证书提取公钥并验证；生成 PMS（即 Pre Master Secret），使用公钥加密发送给服务器</li><li>服务器使用私钥进行解密得到 PMS</li><li>客户端和服务器都使用 RNc、RNs 和 PMS 生成会话密钥，接下来使用会话密钥对通信内容进行对称加密</li></ol><p>为什么要使用三个随机数</p><blockquote><p>不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于 SSL 协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。<br>对于 RSA 密钥交换算法来说，pre-master-secret 本身就是一个随机数，再加上 hello 消息中的两个随机数，三个随机数通过一个密钥导出器最终导出一个对称密钥。<br>pre-master-secret 的存在在于 SSL 协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么 pre-master-secret 就有可能被猜出来，那么仅适用 pre-master-secret 作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上 pre-master-secret 三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了</p></blockquote><h3 id="关于安全信任"><a href="#关于安全信任" class="headerlink" title="关于安全信任"></a>关于安全信任</h3><ul><li>双方通信内容的安全性是靠公钥加密、私钥解密来保证的，这一安全性由非对称加密的特性，即由公钥加密的信息只能使用对应的私钥才能解开来保证。由于私钥不会传递，只有拥有者知道，所以安全性就由公钥的正确性来保证</li><li>公钥由对方在通信初始所提供，但是这时很容易被中间人替换掉，为了保证公钥的正确性，所以在发送公钥的时候也会提供对应的数字证书，用于验证这个公钥是对方的而不是中间人的。那么安全性就是由数字证书的正确性来保证了</li><li>数字证书是由上级 CA 签发给个人 / 组织的，上级 CA 用自己的私钥给个人证书进行签名，保证证书中的公钥不被篡改，而接受者需要用上级 CA 证书中的公钥来解密个人数字证书中的数字签名来验证证书中的公钥是否是正确的。那么安全性就是由上级 CA 证书的正确性保证的了</li><li>但是，上级 CA 证书也是由其上级 CA 签发的，这种信任关系一直到根证书。根证书没有上级 CA 为其签名，而是自签名的，也就是说，它自身为自身签名，保证正确性。所以根证书就是这个信任链最重要的部分。如果根证书泄露的话，其签名的所有证书及使用其签名的证书所签名的证书的安全性将不复存在。现在，安全性就是靠系统根证书的私钥不被泄露或者其公钥不被篡改来保证的了</li><li>根证书不应该通过网络分发，因为通过网络分发的话，可能会被中间人攻击。一般根证书都通过操作系统或者浏览器分发，在操作系统中会内置很多根证书，但是最初的操作系统也不能通过网络分发，因为中间人可以修改操作系统中的根证书。所以要保证安全只能靠最原始的方法，当面交流。硬件厂商会和证书签发机构合作，在电脑、手机等设备出厂的时候在其操作系统中内置签发机构的根证书，再将这些设备分发出去，这样，这些设备的用户就可以安全地进行信息交换了。所以，安全性就依赖于这些设备在分发到消费者手中之前不会被恶意修改来保证了</li></ul><h3 id="关于完整性校验"><a href="#关于完整性校验" class="headerlink" title="关于完整性校验"></a>关于完整性校验</h3><p>HTTPS 通过证书解决了冒充风险，通过加密解决了窃听风险，那么篡改风险如何规避呢？</p><p>当握手阶段结束后，双方进入数据通信阶段。在这个阶段：</p><ol><li>发送方会使用协商出来的“会话密钥”对原始消息进行加密，形成<strong>密文</strong>；同时也会使用<strong>哈希算法</strong>对原始消息进行计算，形成<strong>消息摘要</strong>；并将消息摘要和密文同时发送出去</li><li>接收方会使用“会话密钥”对密文进行解密，得到原始消息，然后对原始消息使用同样的哈希算法进行计算，将得到的值与消息摘要比较，以此判断是否被篡改过</li></ol><blockquote><p>哈希算法是不可逆的，可以把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射。无论多长的消息都被映射成长度固定的散列值，因此消息长短不会影响完整性校验的性能</p></blockquote><h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><ul><li><p>对称加密：客户端用密钥将对信息进行加密，服务器用同一把密钥将对信息进行解密</p><ol><li><p>发送方和接收方如何共享相同的密钥比较麻烦。一种方法是通过事先协商好而不是通过通信进行协商，避免被监听和截获；另一种是通过非对称加密通道进行对称加密的密钥的传输</p></li><li><p>对称加密的密钥是一对一的，若服务器要跟多个客户端通信则需要维护多对密钥</p></li></ol></li></ul><ul><li><p>非对称加密：公钥和私钥；客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密</p><ol><li><p>不存在密钥分发的问题，解码方可以自己生成密钥对，一个做私钥存起来，另外一个作为公钥进行发布</p></li><li><p>解决了密钥管理的复杂度问题，多个加密方都可以使用一个已知的公钥进行加密，但只有拥有私钥的一方才能解密</p><p>缺点是比对称加密慢</p></li></ol></li></ul><h3 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h3><ul><li>常见的对称加密算法：DES、AES、RC2、RC4</li><li>常见的非对称加密算法：RSA、DSA</li><li>常见的完整性校验算法：MD5、SHA1、SHA256</li></ul><h3 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h3><ul><li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a></li><li><a href="https://juejin.im/entry/5a644a61f265da3e4c07e334" target="_blank" rel="noopener">一文完全理解HTTPS</a></li><li><a href="https://juejin.im/post/5c441073e51d455226654d60" target="_blank" rel="noopener">完全图解 HTTPS</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假如客户端要登录，将用户名和密码传到服务器&lt;/p&gt;
&lt;h3 id=&quot;如果使用-HTTP，会有什么问题&quot;&gt;&lt;a href=&quot;#如果使用-HTTP，会有什么问题&quot; class=&quot;headerlink&quot; title=&quot;如果使用 HTTP，会有什么问题&quot;&gt;&lt;/a&gt;如果使用 HTTP
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/算法/数据结构/链表/</id>
    <published>2020-08-15T09:01:58.176Z</published>
    <updated>2020-05-11T14:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="删除单向链表中的指定节点"><a href="#删除单向链表中的指定节点" class="headerlink" title="删除单向链表中的指定节点"></a>删除单向链表中的指定节点</h2><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-node-in-a-linked-list/</a></p><p>只能访问当前节点，当前节点不是末尾节点</p><p>借尸还魂：将当前节点的值和 next 全部更新为其 next，再删除 next</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode *node)</span> </span>&#123;</span><br><span class="line">    ListNode *next = node-&gt;next;</span><br><span class="line">    node-&gt;val = next-&gt;val;    </span><br><span class="line">    node-&gt;next = next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="移除未排序链表中的重复节点"><a href="#移除未排序链表中的重复节点" class="headerlink" title="移除未排序链表中的重复节点"></a>移除未排序链表中的重复节点</h2><p>遍历的同时使用 map 记录；</p><p>或者</p><p>使用双指针，current 用于迭代，runner 用于检查后续节点有无重复</p><h2 id="寻找链表中倒数第-K-个元素"><a href="#寻找链表中倒数第-K-个元素" class="headerlink" title="寻找链表中倒数第 K 个元素"></a>寻找链表中倒数第 K 个元素</h2><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</a></p><p>快慢指针</p><h2 id="删除链表中某个节点，只能访问该节点，不能访问-head"><a href="#删除链表中某个节点，只能访问该节点，不能访问-head" class="headerlink" title="删除链表中某个节点，只能访问该节点，不能访问 head"></a>删除链表中某个节点，只能访问该节点，不能访问 head</h2><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-node-in-a-linked-list/</a></p><p>删除后续节点，并将后续节点的值复制到该节点</p><h2 id="链表的加法，数字反向存放"><a href="#链表的加法，数字反向存放" class="headerlink" title="链表的加法，数字反向存放"></a>链表的加法，数字反向存放</h2><p><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers/</a></p><p>迭代，记录进位</p><h2 id="链表的加法，数字正向存放"><a href="#链表的加法，数字正向存放" class="headerlink" title="链表的加法，数字正向存放"></a>链表的加法，数字正向存放</h2><p><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers-ii/</a></p><ol><li>对短的链表补 0</li><li>封装 pair 结构记录 ListNode 和进位</li><li>递归求解</li></ol><h2 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle/</a></p><p>双指针必相遇</p><h2 id="判断有环链表的环路起始点"><a href="#判断有环链表的环路起始点" class="headerlink" title="判断有环链表的环路起始点"></a>判断有环链表的环路起始点</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p><p>假如链表起点距离环路起点为 k</p><ol><li>创建双指针：fast 和 slow；slow 每走一步，fast 走两步</li><li>两者相碰时的节点必然距离环路起点 k</li><li>slow 重置到 head，再以相同的速度移动 slow 和 fast 相碰时必是环路起点</li></ol><h2 id="两个链表的相交节点"><a href="#两个链表的相交节点" class="headerlink" title="两个链表的相交节点"></a>两个链表的相交节点</h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p><p>双指针：先得到两个链表的长度，然后得到长度的差值 distance，两个指针分别从两个链表头部遍历，其中较长链表指针先走 distance 步，然后同时向后走，当两个指针相遇的时候，即链表的交点</p><h2 id="链表的中间节点"><a href="#链表的中间节点" class="headerlink" title="链表的中间节点"></a>链表的中间节点</h2><p><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/middle-of-the-linked-list/</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1-&gt;2-&gt;3-&gt;4 则返回 3；1-&gt;2-&gt;3 则返回 2</span></span><br><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *fast = head, *slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><p>反转链表的递归解法非常直观；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode *next = head-&gt;next;</span><br><span class="line">    <span class="comment">// reverseList 作用：传入 1-&gt;2-&gt;3，结果为 1&lt;-2&lt;-3，并返回 3</span></span><br><span class="line">    ListNode *after = reverseList(next);</span><br><span class="line">    next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> after;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代解法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *last = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *next = curNode-&gt;next;</span><br><span class="line">        cur-&gt;next = last;</span><br><span class="line">        last = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否回文链表"><a href="#判断是否回文链表" class="headerlink" title="判断是否回文链表"></a>判断是否回文链表</h2><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-linked-list/</a></p><ol><li>寻找后半部分的起点</li><li>反转后半部分链表</li><li>双指针比较前半部分和后半部分的是否相同</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;删除单向链表中的指定节点&quot;&gt;&lt;a href=&quot;#删除单向链表中的指定节点&quot; class=&quot;headerlink&quot; title=&quot;删除单向链表中的指定节点&quot;&gt;&lt;/a&gt;删除单向链表中的指定节点&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.c
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    <id>http://yoursite.com/算法/数据结构/树/</id>
    <published>2020-08-15T09:01:58.172Z</published>
    <updated>2020-05-11T14:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    TreeNode *l = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    TreeNode *r = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (l &amp;&amp; r) </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l) </span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否是相同的树"><a href="#判断是否是相同的树" class="headerlink" title="判断是否是相同的树"></a>判断是否是相同的树</h2><p><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/same-tree/</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否是另一个树的子树"><a href="#判断是否是另一个树的子树" class="headerlink" title="判断是否是另一个树的子树"></a>判断是否是另一个树的子树</h2><p><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subtree-of-another-tree/</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!s || !t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (isSameTree(s, t)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否对称二叉树"><a href="#判断是否对称二叉树" class="headerlink" title="判断是否对称二叉树"></a>判断是否对称二叉树</h2><p><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree/</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isMirror(root, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMirror</span><span class="params">(TreeNode *left, TreeNode *right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!left &amp;&amp; !right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!left || !right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isMirror(left-&gt;left, right-&gt;right) &amp;&amp; isMirror(left-&gt;right, right-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/invert-binary-tree/</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode *left = root-&gt;left;</span><br><span class="line">    TreeNode *right = root-&gt;right;</span><br><span class="line">    root-&gt;left = right;</span><br><span class="line">    root-&gt;right = left;</span><br><span class="line">    invertTree(left);</span><br><span class="line">    invertTree(right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p><p>BFS 时不携带层级信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        TreeNode *cur = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        ret.push_back(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) q.push(cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) q.push(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BFS 时携带层级信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curLevel;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *cur = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            curLevel.push_back(cur-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) q.push(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right) q.push(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        ret.push_back(curLevel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉树的最近公共祖先&quot;&gt;&lt;a href=&quot;#二叉树的最近公共祖先&quot; class=&quot;headerlink&quot; title=&quot;二叉树的最近公共祖先&quot;&gt;&lt;/a&gt;二叉树的最近公共祖先&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/probl
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/算法/数据结构/动态规划/</id>
    <published>2020-08-15T09:01:58.169Z</published>
    <updated>2020-05-11T14:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode/</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.size();</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="comment">// 单个字符属于回文，例如 abcd</span></span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连续两个字符相同属于回文，例如 abb</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; m - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                start = i;</span><br><span class="line">                length = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= m; len++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + len;</span><br><span class="line">            <span class="comment">// 扩展长度</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span> &amp;&amp; s[i] == s[j]) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j - i + <span class="number">1</span> &gt; length) &#123;</span><br><span class="line">                    start = i;</span><br><span class="line">                    length = j - i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.substr(start, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最长回文子串&quot;&gt;&lt;a href=&quot;#最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;最长回文子串&quot;&gt;&lt;/a&gt;最长回文子串&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-pali
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/算法/搜索/回溯算法/</id>
    <published>2020-08-15T09:01:58.156Z</published>
    <updated>2020-05-11T14:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回溯算法的框架"><a href="#回溯算法的框架" class="headerlink" title="回溯算法的框架"></a>回溯算法的框架</h2><p>解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题：</p><p>1、路径：也就是已经做出的选择。</p><p>2、选择列表：也就是你当前可以做的选择。</p><p>3、结束条件：也就是到达决策树底层，无法再做选择的条件。</p><p>如果你不理解这三个词语的解释，没关系，我们后面会用「全排列」和「N皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。</p><p>代码方面，回溯算法的框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」，特别简单。</p><h2 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h2><p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">Leetcode：46.全排列</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 满足结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (path.size() == nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        ret.push_back(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="comment">// 这一步可以优化为 swap，但是理解起来比较复杂</span></span><br><span class="line">        <span class="keyword">if</span> (find(path.begin(), path.end(), num) != path.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        path.push_back(num);</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        backtrack(path, nums);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    backtrack(path, nums);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="N-皇后问题"><a href="#N-皇后问题" class="headerlink" title="N 皇后问题"></a>N 皇后问题</h2><p><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">N 皇后</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入棋盘边长 n，返回所有合法的放置 */</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// '.' 表示空，'Q' 表示皇后，初始化空棋盘。</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">board</span><span class="params">(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>))</span></span>;</span><br><span class="line">    backtrack(board, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径：board 中小于 row 的那些行都已经成功放置了皇后</span></span><br><span class="line"><span class="comment">// 选择列表：第 row 行的所有列都是放置皇后的选择</span></span><br><span class="line"><span class="comment">// 结束条件：row 超过 board 的最后一行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (row == board.size()) </span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(board);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; board[row].size(); col++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 排除不合法选择</span></span><br><span class="line">        <span class="keyword">if</span> (!isValid(board, row, col)) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">        <span class="comment">// 进入下一行决策</span></span><br><span class="line">        backtrack(board, row + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = board.size();</span><br><span class="line">    <span class="comment">// 检查【列】是否有皇后互相冲突（board 中大于 row 的那些行没有放置皇后）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= row; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查【右上方】是否有皇后互相冲突（board 中大于 row 的那些行没有放置皇后）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; </span><br><span class="line">            i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查【左上方】是否有皇后互相冲突（board 中大于 row 的那些行没有放置皇后）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>;</span><br><span class="line">            i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字母大小全排列"><a href="#字母大小全排列" class="headerlink" title="字母大小全排列"></a>字母大小全排列</h2><p><a href="https://leetcode-cn.com/problems/letter-case-permutation" target="_blank" rel="noopener">784. 字母大小写全排列</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">string</span> path, <span class="built_in">string</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size() == S.size())</span><br><span class="line">    &#123;</span><br><span class="line">        ret.push_back(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c = S[path.size()];</span><br><span class="line">    path += c;</span><br><span class="line">    backtrack(path, S);</span><br><span class="line">    <span class="comment">// 字母需要回溯，数字不需要</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isalpha</span>(c))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 回退再选择一次</span></span><br><span class="line">        path = path.substr(<span class="number">0</span>, path.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 大写转小写；小写转大写</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            path += <span class="built_in">tolower</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">        &#123;</span><br><span class="line">            path += <span class="built_in">toupper</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(path, S);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCasePermutation</span><span class="params">(<span class="built_in">string</span> S)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ret = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (S.size() == <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> path;</span><br><span class="line">    backtrack(path, S);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/" target="_blank" rel="noopener">回溯算法详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;回溯算法的框架&quot;&gt;&lt;a href=&quot;#回溯算法的框架&quot; class=&quot;headerlink&quot; title=&quot;回溯算法的框架&quot;&gt;&lt;/a&gt;回溯算法的框架&lt;/h2&gt;&lt;p&gt;解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题：&lt;/p&gt;
&lt;p&gt;1、路径
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="搜索" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/算法/排序/快速排序/</id>
    <published>2020-08-15T09:01:58.139Z</published>
    <updated>2020-05-11T14:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = l, j = r, x = s[l];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (s[j] &gt;= x &amp;&amp; i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i++] = s[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (s[i] &lt; x &amp;&amp; i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            s[j--] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s[i] = x;</span><br><span class="line">    quickSort(s, l, i<span class="number">-1</span>);</span><br><span class="line">    quickSort(s, i+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/算法/排序/堆排序/</id>
    <published>2020-08-15T09:01:58.133Z</published>
    <updated>2020-05-11T14:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图解堆排序"><a href="#图解堆排序" class="headerlink" title="图解堆排序"></a>图解堆排序</h2><p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">堆排序是什么</a></p><h2 id="堆排序的步骤"><a href="#堆排序的步骤" class="headerlink" title="堆排序的步骤"></a>堆排序的步骤</h2><ol><li>将无序数组就地交换，堆化为最大堆</li><li>将堆顶元素与末尾元素交换，将最大元素沉到数组末端；</li><li>重复步骤 1 和 2，直到整个数组有序</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造小顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> n, <span class="keyword">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = s[cur];</span><br><span class="line">    <span class="comment">// 从 cur 的左子节点开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * cur + <span class="number">1</span>; i &lt; n; i = i * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果存在右子节点且右子节点更小</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; s[i + <span class="number">1</span>] &lt; s[i])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到左右节点中最小的元素与当前元素交换</span></span><br><span class="line">        <span class="keyword">if</span> (tmp &gt; s[i])</span><br><span class="line">        &#123;</span><br><span class="line">            s[cur] = s[i]; <span class="comment">// 暂时不需要处理最初被交换的那个</span></span><br><span class="line">            cur = i; <span class="comment">// 以同样的方法处理子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素比子节点都小，满足条件，退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s[cur] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 步骤 1：建堆</span></span><br><span class="line">    <span class="comment">// 从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        adjustHeap(s, n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 2：交换元素，重新调整堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(s[<span class="number">0</span>], s[i]);</span><br><span class="line">        adjustHeap(s, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ol><li>建堆的复杂度是 O(N)</li><li>交换 N 次，调整的复杂度为 O(logN)</li></ol><p>所以堆排序复杂度为：O(NlogN)</p><p><a href="https://www.zhihu.com/question/20729324" target="_blank" rel="noopener">建堆时间复杂度为什么是 O(N)</a></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="找出无序数组中位数，要求O-N-复杂度"><a href="#找出无序数组中位数，要求O-N-复杂度" class="headerlink" title="找出无序数组中位数，要求O(N)复杂度"></a><a href="https://zhuanlan.zhihu.com/p/29595813" target="_blank" rel="noopener">找出无序数组中位数，要求O(N)复杂度</a></h3><h3 id="找出无序数组中第-K-大元素"><a href="#找出无序数组中第-K-大元素" class="headerlink" title="找出无序数组中第 K 大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">找出无序数组中第 K 大元素</a></h3><p>考虑 K = 1 的时候如何处理，K = 2、3 呢？最终会考虑到最大堆的建立</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图解堆排序&quot;&gt;&lt;a href=&quot;#图解堆排序&quot; class=&quot;headerlink&quot; title=&quot;图解堆排序&quot;&gt;&lt;/a&gt;图解堆排序&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chengxiao/p/6129630.html&quot;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/算法/排序/基本排序/</id>
    <published>2020-08-15T09:01:58.129Z</published>
    <updated>2020-05-11T14:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>每次挑最小的放左边</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] &lt; s[minIndex])</span><br><span class="line">            &#123;</span><br><span class="line">                minIndex = j;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        swap(s[i], s[minIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>从左往右遍历，取出当前元素有序地插到其左半部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] &lt; s[j<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(s[j], s[j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>从左往右进行两两比较，每一趟可以使最大值在最右边</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] &gt; s[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(s[j], s[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改进冒泡排序：优化外层循环"><a href="#改进冒泡排序：优化外层循环" class="headerlink" title="改进冒泡排序：优化外层循环"></a>改进冒泡排序：优化外层循环</h2><p>如果某一趟比较没有数值交换，则说明已经排好序；处理在排序过程中数组整体已经有序的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> isSorted = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] &gt; s[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(s[j], s[j+<span class="number">1</span>]);</span><br><span class="line">                isSorted = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isSorted)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改进冒泡排序：优化内层循环"><a href="#改进冒泡排序：优化内层循环" class="headerlink" title="改进冒泡排序：优化内层循环"></a>改进冒泡排序：优化内层循环</h2><p>每一趟遍历记录最后一次交换的位置，这个位置后的元素其实都是有序的，不需要再次比较</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort3</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> endPos = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> lastExchangeIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; endPos; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] &gt; s[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(s[j], s[j+<span class="number">1</span>]);</span><br><span class="line">                lastExchangeIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        endPos = lastExchangeIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h2&gt;&lt;p&gt;每次挑最小的放左边&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A/%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E9%9B%B6%E7%A2%8E/"/>
    <id>http://yoursite.com/不务正业/设计/设计零碎/</id>
    <published>2020-08-15T09:01:58.068Z</published>
    <updated>2020-05-11T14:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="http://www.woshipm.com/pd/1825045.html" target="_blank" rel="noopener">《大标题设计原则：不要为了用大标题而做大标题》</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.woshipm.com/pd/1825045.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《大标题设计原则：不要为了用大标题而做大标题》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="不务正业" scheme="http://yoursite.com/categories/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A/"/>
    
      <category term="设计" scheme="http://yoursite.com/categories/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A/%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>知识碎片</title>
    <link href="http://yoursite.com/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A/%E6%9C%AA%E5%88%86%E7%B1%BB/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/"/>
    <id>http://yoursite.com/不务正业/未分类/知识碎片/</id>
    <published>2020-08-15T09:01:58.059Z</published>
    <updated>2020-05-11T14:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><p>命令行下展示目录结构的神器——tree，使用 <code>brew install tree</code> 来安装</p><h2 id="使用-ll-作为-ls-l-的别名"><a href="#使用-ll-作为-ls-l-的别名" class="headerlink" title="使用 ll 作为 ls -l 的别名"></a>使用 ll 作为 ls -l 的别名</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">touch .bash_profile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"alias l='ls -alhF'"</span> &gt;&gt;.bash_profile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"alias la='ls -AFh'"</span> &gt;&gt;.bash_profile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"alias ll='ls -lhAF'"</span> &gt;&gt;.bash_profile</span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><h2 id="如何优雅地使用-KVO"><a href="#如何优雅地使用-KVO" class="headerlink" title="如何优雅地使用 KVO"></a>如何优雅地使用 KVO</h2><ul><li><a href="https://draveness.me/kvocontroller" target="_blank" rel="noopener">如何优雅地使用 KVO</a></li><li><a href="https://github.com/facebook/KVOController/" target="_blank" rel="noopener">Facebook/KVOController</a></li></ul><h2 id="使用-kindof"><a href="#使用-kindof" class="headerlink" title="使用 __kindof"></a>使用 <code>__kindof</code></h2><p>如果以下代码不加 <code>__kindof</code> 就会产生 Warning</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span>&lt;__kindof <span class="built_in">UIView</span> *&gt; *subviews = @[].mutableCopy;</span><br><span class="line"></span><br><span class="line">[subviews addObject:[[<span class="built_in">UIView</span> alloc] init]]; <span class="comment">// Works</span></span><br><span class="line">[subviews addObject:[[<span class="built_in">UIImageView</span> alloc] init]]; <span class="comment">// Also works</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">UIView</span> *sameView = subviews[<span class="number">0</span>]; <span class="comment">// No problem</span></span><br><span class="line"><span class="built_in">UIImageView</span> *sameImageView = subviews[<span class="number">1</span>]; <span class="comment">// No complaints now!</span></span><br></pre></td></tr></table></figure><h2 id="预览-Github-的-html"><a href="#预览-Github-的-html" class="headerlink" title="预览 Github 的 html"></a>预览 Github 的 html</h2><p>在 html 的源地址前面添加 <code>http://htmlpreview.github.io/?</code> 即可</p><h2 id="return-前执行"><a href="#return-前执行" class="headerlink" title="return 前执行"></a>return 前执行</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OnExit \</span></span><br><span class="line">__<span class="keyword">strong</span> <span class="keyword">void</span>(^block)(<span class="keyword">void</span>) __attribute__((cleanup(blockCleanUp), unused)) = ^</span><br></pre></td></tr></table></figure><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><ul><li><a href="https://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener">尾调用优化</a></li><li><a href="https://juejin.im/post/5b7e9efee51d4538b63d158d" target="_blank" rel="noopener">iOS objc_msgSend尾调用优化机制详解</a></li></ul><h2 id="iOS-Bug-定位"><a href="#iOS-Bug-定位" class="headerlink" title="iOS Bug 定位"></a>iOS Bug 定位</h2><ol><li>.dSYM + .app + .crash 的 UUID 必须一致</li></ol><p>查看 app 的 UUID</p><blockquote><p>dwarfdump –uuid XXX.app/XXX</p></blockquote><p><a href="https://www.cnblogs.com/ningxu-ios/p/4141783.html" target="_blank" rel="noopener">https://www.cnblogs.com/ningxu-ios/p/4141783.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Tree&quot;&gt;&lt;a href=&quot;#Tree&quot; class=&quot;headerlink&quot; title=&quot;Tree&quot;&gt;&lt;/a&gt;Tree&lt;/h2&gt;&lt;p&gt;命令行下展示目录结构的神器——tree，使用 &lt;code&gt;brew install tree&lt;/code&gt; 来安装&lt;/p&gt;

      
    
    </summary>
    
      <category term="不务正业" scheme="http://yoursite.com/categories/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A/"/>
    
      <category term="未分类" scheme="http://yoursite.com/categories/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>查找日志技巧</title>
    <link href="http://yoursite.com/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A/%E6%9C%AA%E5%88%86%E7%B1%BB/%E6%9F%A5%E6%89%BE%E6%97%A5%E5%BF%97%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/不务正业/未分类/查找日志技巧/</id>
    <published>2020-08-15T09:01:58.056Z</published>
    <updated>2020-05-11T14:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="将文本中带有-viewWillAppear-的所有行打印出来"><a href="#将文本中带有-viewWillAppear-的所有行打印出来" class="headerlink" title="将文本中带有 viewWillAppear 的所有行打印出来"></a>将文本中带有 viewWillAppear 的所有行打印出来</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test.log | grep -n -i <span class="string">'viewWillAppear'</span> &gt; result.log</span><br></pre></td></tr></table></figure><p>其中，-n:显示行号；-i 忽略大小写</p><h2 id="将文本中带有-QLASIHTTPRequest-的所有行过滤掉"><a href="#将文本中带有-QLASIHTTPRequest-的所有行过滤掉" class="headerlink" title="将文本中带有 QLASIHTTPRequest 的所有行过滤掉"></a>将文本中带有 QLASIHTTPRequest 的所有行过滤掉</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'/QLASIHTTPRequest/d'</span> test.log &gt; result.log</span><br></pre></td></tr></table></figure><p><code>/QLASIHTTPRequest/d</code> 表示对所有匹配到 QLASIHTTPRequest 的行执行 delete 命令</p><p>关于 <code>sed</code> 的更多用法，见 <a href="https://coolshell.cn/articles/9104.html" target="_blank" rel="noopener">SED 简明教程</a></p><h2 id="使用正则表达式查找-C-所有的复制构造函数"><a href="#使用正则表达式查找-C-所有的复制构造函数" class="headerlink" title="使用正则表达式查找 C++ 所有的复制构造函数"></a>使用正则表达式查找 C++ 所有的复制构造函数</h2><p>以 QVNContext::QVNContext(const QVNContext &amp;context) 为例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(.+)::\1\(.*\1\s.*</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;将文本中带有-viewWillAppear-的所有行打印出来&quot;&gt;&lt;a href=&quot;#将文本中带有-viewWillAppear-的所有行打印出来&quot; class=&quot;headerlink&quot; title=&quot;将文本中带有 viewWillAppear 的所有行打印出来&quot;&gt;
      
    
    </summary>
    
      <category term="不务正业" scheme="http://yoursite.com/categories/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A/"/>
    
      <category term="未分类" scheme="http://yoursite.com/categories/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
</feed>

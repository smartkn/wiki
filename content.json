{"pages":[{"title":"About","date":"2020-08-15T07:59:32.852Z","path":"about/index.html","text":""},{"title":"Categories","date":"2020-08-15T07:59:32.855Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2020-08-15T07:59:32.859Z","path":"tags/index.html","text":""}],"posts":[{"title":"","date":"2020-08-15T09:01:58.228Z","path":"计算机基础/字符编码/","text":"一、ASCII 码我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。 上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。 ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。 二、非 ASCII 编码英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。 但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127表示的符号是一样的，不一样的只是128–255的这一段。 至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。 中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。 三. Unicode正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。 可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。 Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。 四、Unicode 的问题需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 它们造成的结果是：1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。2）Unicode 在很长一段时间内无法推广，直到互联网的出现。 五、UTF-8互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。 UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8 的编码规则很简单，只有二条： 1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2）对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 下表总结了编码规则，字母x表示可用编码的位。 Unicode符号范围 | UTF-8编码方式(十六进制) | （二进制）———————-+————————————0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。 下面，还是以汉字严为例，演示如何实现 UTF-8 编码。 严的 Unicode 是4E25（0100 1110 0010 0101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。 可以看到严的 Unicode码 是4E25，UTF-8 编码是E4B8A5，两者是不一样的。它们之间的转换可以通过程序实现 六、Little endian 和 Big endianUnicode 的编码方式有 Little endian 和 Big endian 之分 以汉字严为例，Unicode 码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，这就是 Big endian 方式；25在前，4E在后，这是 Little endian 方式。 这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-endian)敲开还是从小头(Little-endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。 第一个字节在前，就是”大头方式”（Big endian），第二个字节在前就是”小头方式”（Little endian）。 那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？ Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。 如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。 七、实例严字，依次采用Unicode，Unicode big endian和UTF-8编码方式保存。 1）Unicode：编码是四个字节FF FE 25 4E，其中FF FE表明是小头方式存储，真正的编码是4E25。 2）Unicode big endian：编码是四个字节FE FF 4E 25，其中FE FF表明是大头方式存储。 3）UTF-8：编码是六个字节EF BB BF E4 B8 A5，前三个字节EF BB BF表示这是UTF-8编码，后三个E4B8A5就是严的具体编码，它的存储顺序与编码顺序是一致的。（注意 UTF-8 并没有 Little endian 和 Big endian 之分）","tags":[],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}]},{"title":"","date":"2020-08-15T09:01:58.223Z","path":"计算机基础/原码, 反码, 补码/","text":"在 32 位机器上，int 的范围是 [-2^31, 2^31-1]，为什么正数和负数的范围不对称？ 一、机器数和真值在学习原码，反码和补码之前，需要先了解机器数和真值的概念 机器数机器数：一个数在计算机中的二进制表示形式。其最高位存放符号，正数为0，负数为1 比如 -3 的机器数就是 10000011 真值第一位是符号位，真值就是将符号考虑进去进行计算的值。 比如：1000 0001 的真值是 -1，而不是 129 二、原码，反码，补码的基础概念和计算方法在探求为何机器要使用补码之前，让我们先了解原码，反码和补码的概念。对于一个数，计算机要使用一定的编码方式进行存储。原码，反码，补码是机器存储一个具体数字的编码方式 原码原码就是用第一位表示符号，其余位表示值 12[+1]原 = 0000 0001[-1]原 = 1000 0001 反码 正数的反码是其本身 负数的反码是在其原码的基础上，符号位不变，其余各个位取反 12[+1]反 = 0000 0001[-1]反 = 1111 1110 补码 正数的补码就是其本身 负数的补码是在反码的基础上+1 1234[+1]补 = 0000 0001[-1]补 = 1111 1111[0] 补 = 0000 0000[-8]补 = 1000 0000 三、为何要使用原码，反码和补码对于正数三种编码方式的结果都相同 [+1] = [00000001]原 = [00000001]反 = [00000001]补 但是对于负数: [-1] = [10000001]原 = [11111110]反 = [11111111]补 原码是被人脑直接识别并用于计算表示方式，为何还会有反码和补码呢? 由于计算机识别符号位会变复杂，因此计算时使用加法替代减法 如果用原码表示，对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数 11 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2 为了能够使正负相加得 0，出现了反码： 11 - 1 = 1 + (-1) = [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0 发现用反码计算减法，结果的真值部分是正确的，却会出现 +0 和 -0 虽然人们理解上+0和-0是一样的，但是0带符号是没有任何意义的。而且会有[0000 0000]原和[1000 0000]原两个编码表示0 我们希望只有一个 0，所以发明了补码 之前相加会得到各个位都是 1，所以规定补码为在反码的基础上 +1，这样相加之后每个 1 都会变成 0，多出的进位直接抛弃 11 - 1 = 1 + (-1) = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原 这样0用 [0000 0000] 表示，而以前出现问题的-0则不存在了。而且可以用[1000 0000]表示-128: 1(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补 使用补码，不仅仅修复了0的符号，而且还能够多表示一个最小值 这就是为什么8位机器下，使用原码或反码表示的范围为[-127,+127]，而使用补码表示的范围为[-128,127] 因为机器使用补码，所以对于编程中常用到的32位int类型，可以表示范围是: [-2^31,2^31-1] 因为第一位表示的是符号位。而使用补码表示时又可以多保存一个最小值 四、补码是怎么来的同余首先介绍一个数学中相关的概念: 同余 两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余 记作 a ≡ b (mod m) 读作 a 与 b 关于模 m 同余 举例说明: 1234 mod 12 = 416 mod 12 = 428 mod 12 = 4 所以4，16，28关于模 12 同余 负数取模加上 mod 右边的数的倍数即可 12-3 mod 2 = (-3+2*2) mod 2 = 1-2 mod 12 = (-2+12) mod 12 = 10 补码与取模如果当前时间是6点，我希望将时间设置成4点，我们可以: 往回拨2个小时: 6 - 2 = 4 往前拨10个小时: (6 + 10) mod 12 = 4 在这个例子中，我们忽略了钟表是否多转了一圈，只考虑了当前时间点对不对，实际上就是只考虑对 12 个小时取余的结果对不对 -2 被我们看成是 +10，因为 -2 和 +10 是关于模 12 同余 同理，在补码的计算中，在 n 位机器上，补码与原码是关于模 2^(n-1) 同余 以 8 位为例，负数的补码与原码相加得到 1000 0000，即 128，这个 128 就好比钟表的 12 个小时 我们首先忽略符号位，只考虑剩下7位的值对不对。比如加 -1 和加 +127 就是等价的 2-1 = 2+(-1) = [0000 0010]原 + [1000 0001]原= [0000 0010]补 + [1111 1111]补 忽略符号位，-1 的原码是 000 0001，好比向前拨 2 个小时；补码是 111 1111，好比向后拨 10 个小时 那么， 2 + (-1) 与 2 + (127) 在 7 位比特位中的值一定是一样的。我们忽略了溢出，只考虑了对 111 1111 取余；正如我们忽略钟表多转一圈还是少转一圈，只考虑了对 12 个小时取余 符号位在补码和取模的讨论中，包括钟表的例子，我们都只看了余数，而回避了符号位的问题，现在着重看下符号位的计算 我们知道，在补码中，正数的符号位是 0，负数是 1 正数和正数、负数和负数相加可能会有溢出问题，比如 127+1，-127-1，此时的符号位都是不对的，溢出的情况我们不考虑 a+b，有以下 3 种可能 a+b = 0 a+b &lt; 0 a+b &gt; 0 以 8 位为例 我们知道由于引入了补码，所以 a+b = 0 的结果必然是 [0000 0000] 以 -3+1 为例，-3+1 = -2+(-1)+1 = -2 + 0，由于 0 是 [0000 0000]，注意我们舍弃了相加等于0的进位，所以符号位由 -2 确定 a+b &gt; 0 同理 这就是补码运算中符号位是正确的原因","tags":[],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}]},{"title":"","date":"2020-08-15T09:01:58.220Z","path":"计算机基础/RESTful API/","text":"什么是 RESTREST：REpresentational State Transfer，直译就是 “表现层状态转移” 通俗地讲就是，URL 定位资源，用 HTTP 动词（GET,POST,PUT,DELETE）描述操作 Resource：资源，即数据 Representational：某种表现形式，比如用 JSON，XML，JPEG 等 State Transfer：状态变化。通过 HTTP 动词实现 REST 本身不实用，实用的是如何设计 RESTful API 什么是 RESTful APIRESTful API 就是 REST 风格的 API，它使用一套协议来规范多种形式的前端和同一个后台的交互方式 RESTful 是基于 HTTP 协议，设计原则如下： 对资源的操作。资源就是一段文本、一张图片或一段视频。资源总是要通过一种载体来反应它的内容，比如文本用 txt，图片用 png 或 jpg，而 JSON 是现在最常用的资源表现形式 使用 HTTP 动词来实现增删改查。RESTful API 对资源的 CRUD（create,read,update,delete）分别对应 HTTP 的方法：GET 用来获取资源，POST 用来新建资源（也可以用于更新资源），PUT 用来更新资源，DELETE 用来删除资源 使用 URI（统一资源定位符）。每个 URI 都对应一个特定的资源，最典型的 URI 就是 URL。每个网址代表一种资源，所以网址中不能有动词，只能有名词 无状态。所有的资源都可以 URI 定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而变化。比如查询工资的接口必须在员工请求登录接口之后才能查询，它就不属于无状态的 其他规范： 将 API 的版本号放入 URL，比如 https://api.example.com/v1/ 一般 API 中的名字都使用复数 123https://api.example.com/v1/zooshttps://api.example.com/v1/animalshttps://api.example.com/v1/posts For ExampleGET:http://api.example.com/posts/123 表示获取 ID 为 123 的帖子 GET:http://api.example.com/posts 表示获取所有帖子列表 DELETE:http://api.example.com/posts/123 则为对应的删除操作 错误的示例：http://api.example.com/getPosts/123 or http://api.example.com/getPosts/123，这里网址中有了动词，并不是通过 HTTP 动词来实现增删改查 参考文章 《什么是 RESTful API？》 《RESTful API 设计指南》","tags":[],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}]},{"title":"Git","date":"2020-08-15T09:01:58.217Z","path":"计算机基础/Git/","text":"Tag列出本地 Taggit tag 本地添加 Taggit tag v1.0.0 删除本地 Taggit tag -d v1.0.0 把本地 Tag 推送到远程git push --tags 删除远程 Taggit push origin -d tag 0.0.2 远程 Tag 删除，本地还在12git tag -l | xargs git tag -dgit fetch --tags 重命名远程 Tag1234git tag new oldgit tag -d oldgit push origin :refs/tags/oldgit push --tags History一个 Log 只占一行，用于快速浏览1git log --pretty=oneline 展示某个提交的具体细节1git show ace518d5172459d95cad6a21efe2ac6068011f2d 修改最后一次 Commit 信息1git commit --amend 撤销撤销本地未 add 的更改1git clean -df 撤销本地已 add 没 commit 的更改1git reset --hard git stauts 中文乱码1git config --global core.quotepath false","tags":[],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}]},{"title":"","date":"2020-08-15T09:01:58.206Z","path":"网络/重放攻击/","text":"背景今天想从【今日热榜】这个 App 中获取榜单的 Get 请求，从而可以“借”它们的数据做个榜单类的小程序。用 Charles 抓手机的包之后，发现可以抓取到一个 Get 请求，回包的内容也正确被抓取了，可是当我复制这段 Get 请求的 url 到浏览器的时候，发现没有对应的回包了 奇怪，为什么会这样呢，决定开始研究下 分析url 是类似以下结构 1http://api.tophub.today/nodes/128?nonce=xxx&amp;sign=yyy&amp;timestamp=123 主要有 3 个字段：nonce、sign 和 timestamp 基于这几个关键词去搜索，发现原来我这种行为属于【重放攻击】 什么是重放攻击假如我们要通过 Get 请求传递用户的用户名和密码，明文传输的例子如下 1http://api.tophub.today/nodes/128?id=hello&amp;password=1234 这是裸奔，我们没这么蠢，于是对 password 进行 MD5 加密之后再传输，如下 1http://api.tophub.today/nodes/128?id=hello&amp;sign=md5(password) 其中 sign 的常用加密算法为 MD5，MD5 算法是一种不可逆算法，也就是说你加密之后就不能解密了 服务器的验证方法就是根据 id 从数据库查出用户的密码，再对其进行 MD5 加密，得到的结果与 sign 的值进行对比，如果相同则请求合法，反之则 sign 被篡改过 黑客通过抓包获取到该链接，他无法破解加密信息得到用户密码；但是他只要模拟此次的正常请求，就可以伪装成客户端同服务器通信。这样至少可以做两件事，第一件是跟我一样，可以随时随地模拟客户端取服务器的数据；第二件事是可以疯狂发送该请求致使服务器繁忙 如何防止重放攻击时间戳首先我们假设一次 HTTP 请求从发出到到达服务器的时间是不会超过 60s 的，而黑客获取链接到篡改链接再发送到服务的时间会超过 60s（不要问为什么是 60s，继续往下看） 当你发送一个请求时必须携带一个当前的时间戳 timestamp。假设值为 10 为了防止黑客修改时间戳，需要将 timestamp 也进行 MD5，放到 sign 中，如下 1?id=hello&amp;sign=md5(password+timestamp)&amp;timestamp=10 当请求到达服务器之后，服务器会获取当前时间，假设为 t2 = 80，很明显 t2 - timestamp &gt; 60s，那么服务器就认为请求不合法。因为这个请求从客户端到服务器的时间竟然超过 60s。如果在 60s 内，再进行一次 md5 校验，检查 timestamp 有没有被篡改（一旦 timestamp 被篡改过，算出来的 md5 值一定与 sign 不同） 问题来了，如果黑客在 60s 内发起请求，这种方法就失效了 随机数我们加入一个随机数 nonce，每次成功请求，服务器会保存当前成功请求的随机数 nonce 到缓存或数据库中，当请求再次进到服务器，判断携带的随机数 nonce 是否在缓存或者数据库中已经存在，如果存在，则认为请求非法 url 如下 1?id=hello&amp;sign=md5(password+nonce)&amp;nonce=31415 同理，为了防止 nonce 被篡改，需要将 nonce 进行 MD5 加密到 sign 随机数的出现保证了请求的唯一性，但是存储 nonce 的集合会越来越大，为了防止 nonce 集合无限大，需要定期清理该集合，但是一旦该集合被清理，我们就无法验证被清理了的 nonce 参数了。比如，假设该集合平均1天清理一次的话，我们抓取到的该 url，虽然当时无法进行重放攻击，但是我们还是可以每隔一天进行一次重放攻击的。而且存储24小时内，所有请求的 nonce 参数，也是一笔不小的开销 当然随机数还得确保唯一性 时间戳+随机数时间戳屏蔽了 60s 后的请求，而 60s 内重复的请求可以用随机数来过滤 url 如下 1?id=hello&amp;sign=md5(password+timestamp+nonce)&amp;timestamp=10&amp;nonce=31415 配合时间戳，服务器只要每次有新的请求进来的时候，确保此次请求没有被篡改的前提下，如果新请求带来的 timestamp 比最后一次更新 nonce 集合的时间晚 60秒，那么就可以清除 nonce 缓存了 12345678910111213141516171819202122232425262728// 判断 time 参数是否有效if ($curTime - $time &gt; 60)&#123; die(\"请求超时\");&#125;// 判断 nonce 参数是否在集合已存在if (in_array($nonce, $nonceArray))&#123; die(\"请求仅一次有效\");&#125;// 验证数字签名 if ($sign != md5($password.$time.$nonce))&#123; die(\"数字签名验证失败\");&#125;// 判断是否需要清理nonce集合if ($curTime - $nonceArray-&gt;lastModifyTime &gt; 60)&#123; $nonceArray = null;&#125;// 记录本次请求的 nonce 参数$nonceArray.push($nonce);//开始处理合法的请求 参考 Web安全防范—–防止重放攻击 基于timestamp和nonce的防止重放攻击方案","tags":[],"categories":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/categories/网络/"}]},{"title":"","date":"2020-08-15T09:01:58.203Z","path":"网络/计算机网络基础/","text":"OSI 七层模型、TCP/IP 五层模型、与 TCP/IP 四层模型 数据传递时，每层都会在上一层的报文添加自己的头部 应用层HTTP、FTP、SMTP、DNS 传输层TCP、UDP 网络层IP、ICMP（Internet 控制报文协议） ping 使用的是 ICMP 协议 链路层ARP、RARP ARP：IP 地址 -&gt; MAC 地址RARP：MAC 地址 -&gt; IP 地址 问：ARP 属于哪一层TCP/IP 模型中，它所有定义的协议是在网络层上的 按照 OSI 的标准，数据在传递时每层会加上自己的信息。当网络层的 IP 包进入链路层时，链路层通过 ARP 协议添加链路信息，因此属于链路层 在 OSI 七层模型中 ARP 协议属于链路层；而在 TCP/IP 模型中，ARP 协议属于网络层 问：当在浏览器中输入 www.baidu.com 的时候发生了什么一、DNS 域名解析先查本地 hosts 文件，如果没命中则主机会向 DNS 服务器发送一条 DNS 查询报文以查询该域名对应的 IP 注意，该报文是 UDP 报文，不需要与 DNS 服务器建立 TCP 连接；我们这台主机本来就知道 DNS 服务器的 IP 地址，要么是写好的静态 IP，要么是路由器动态分配的 IP，不是域名，所以 DNS 查询这个过程也不需要去解析域名 二、建立 TCP 连接传输层拿到了应用层解析到的 IP 地址，开始与服务器进行三次握手，建立 TCP 连接 三、发送 HTTP 请求建立连接后，应用层开始向服务器发送请求，服务器返回相应的结果 四、关闭 TCP 连接为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建 TCP 连接的 3 次握手类似，关闭 TCP 连接，需要 4 次握手。 五、浏览器解析 HTML、JS、CSS、JsonDom 数、CSS 规则集、Render 树","tags":[],"categories":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/categories/网络/"}]},{"title":"","date":"2020-08-15T09:01:58.199Z","path":"网络/TCP 四次挥手/","text":"四次挥手的过程 TCP 三次握手，一定是客户端先发起连接；而 TCP 四次挥手，发起中断连接的既可以是客户端，也可以是服务器。 本文以客户端先发起请求为例，刚开始双方都处于 ESTABLISHED 状态。 从报文的角度上看，四次挥手的过程如下： 第一次挥手：客户端发送一个 FIN 报文（FIN=1，seq=u），进入 FIN_WAIT1 状态，等待服务端的确认，并停止发送数据 第二次挥手：服务端回复 ACK 报文（ACK=1，ack=u+1，seq=v），表明已经收到客户端的报文了，进入 CLOSE_WAIT 状态 客户端收到服务端的确认后，进入 FIN_WAIT2 状态，等待服务端的 FIN 报文。 第三次挥手：如果服务端数据发送完毕想断开连接了，发送 FIN 报文（FIN=1，ACK=1，seq=w，ack=u+1）。进入 LAST_ACK 的状态，等待客户端的确认。 第四次挥手：客户端回复 ACK 报文（ACK=1，seq=u+1，ack=w+1），进入 TIME_WAIT 状态，等待 2MSL 后进入 CLOSED 状态；服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状 从发送和接受数据的能力上看，四次挥手的过程如下： 第一次挥手：客户端不再发送数据；服务器知道客户端不再发送数据 第二次挥手：服务器对客户端 FIN 的确认，依然可能继续发送数据；客户端收到后会继续接收数据 第三次挥手：服务器数据发送完毕后发起第三次挥手，表示服务器不再发送数据；客户端收到后会等 2MSL 后关闭连接，不再接收数据 第四次挥手：服务器收到后关闭连接 什么是 MSL，为什么需要等 2MSLMSL（Maximum Segment Lifetime），即报文段最大生存时间。可以简单理解为，报文段在网络内存在的最长时间，如果超过这个时间，报文段就会被丢弃。 根据第三版《UNIX 网络编程 卷 1》2.7 节，TIME_WAIT 状态的主要目的有两个： 优雅的关闭 TCP 连接，也就是尽量保证被动关闭的一端收到它自己发出去的 FIN 报文的 ACK 确认报文； 处理延迟的重复报文，这主要是为了避免前后两个使用相同四元组的连接中的前一个连接的报文干扰后一个连接。 注：很多博文只讨论了第一点，并且轻易的给出了错误的理由：最坏情况，ACK 报文的发送和 FIN 报文的重传各自需要 1MSL，因此是 2MSL。仔细想想之后，这些人的文章简直就是不经脑子的生搬硬套 假设 A 是主动关闭的一方，B 是被动关闭。 假如现在 A 收到 FIN 之后，为了实现目标 1，即保证 B 能够收到自己的 ACK 报文。那么 A 完美的等待时间不是 2MSL，而应该是从 B 发送第一个 FIN 报文开始计时到它最后一次重传 FIN 报文这段时长加上 MSL。但这个计算方式过于保守，只有在所有的 ACK 报文都丢失的情况下才需要这么长的时间；另外，第一个目标虽然重要，但并不十分关键，因为既然已经到了关闭连接的最后一步，说明在这个 TCP 连接上的所有用户数据已经完成可靠传输，所以要不要完美的关闭这个连接其实已经不是那么关键了。因此，（我猜）RFC 标准的制定者才决定以网络丢包不太严重为前提条件，然后根据第二个目标来计算 TIME_WAIT 状态应该持续的时长。 等待 2MSL 的真正目的是为了避免前后两个使用相同四元组的连接中的前一个连接的报文干扰后一个连接，换句话说，就是为了让此次 TCP 连接中的所有报文在网络中消失。 假如现在 A 发送 ACK 后，最坏情况下，这个 ACK 在 1MSL 时到达 B；此时 B 在收到这个 ACK 的前一刹那，一直在重传 FIN，这个 FIN 最坏会在 1MSL 时间内消失。因此从 A 发送 ACK 的那一刹那开始，等待 2MSL 可以保证 A 发送的最后一个 ACK，和 B 发送的最后一个 FIN 都在网络中消失 注：B 超时重传的时间并不是 2MSL；2MSL 时间为 240 秒，这是协议标准，一般超时重传只有 0.5 秒、1 秒、2 秒、4 秒……小于 MSL 为什么需要四次挥手类比 TCP 的三次握手，这个问题可以理解为为什么服务器的 ACK 报文和 FIN 报文不能合并在一起发送？ 原因是第一次挥手仅仅代表着客户端不再发送数据，而服务器收到 ACK 之后，可能还有数据想要发送给客户端，所以等待服务器发送完毕数据之后，才会继续发送 FIN 报文，因此无法合并发送 参考资料 面试官，不要再问我三次握手和四次挥手 为什么 tcp 的 TIME_WAIT 状态要维持 2MSL","tags":[],"categories":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/categories/网络/"}]},{"title":"","date":"2020-08-15T09:01:58.196Z","path":"网络/TCP 与 UDP/","text":"对比 UDP TCP 是否连接 无连接 面向连接（三次握手） 是否可靠 不可靠传输，不使用流量控制和拥塞控制 可靠传输，有序列号，确认号，超时重传等，使用流量控制和拥塞控制 连接对象个数 支持一对一，一对多，多对一和多对多通信 只能是一对一 传输方式 面向报文 面向字节流 首部开销 首部开销小，仅 8 字节 首部最小 20 字节，最大 60 字节 适用场景 适用于实时应用（微信语音、视频聊天） 适用于要求可靠传输的应用，例如文件传输 总结UDP 无连接，不可靠，传输快","tags":[],"categories":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/categories/网络/"}]},{"title":"","date":"2020-08-15T09:01:58.191Z","path":"网络/TCP 三次握手/","text":"三次握手的过程 刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。 第一次握手：客户端发送 SYN=1，seq=x（SYN=1 的报文段不能携带数据，但要消耗掉一个序号），此时客户端处于 SYN_SENT 状态 第二次握手：服务器回复 SYN=1，ACK=1，ack=x+1，seq=y，此时服务器处于 SYN_RCVD 的状态 第三次握手：客户端回复 ACK=1，ack=y+1，seq=x+1，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。 ACK 报文段可以携带数据，不携带数据则不消耗序号 注意：不要混淆 ACK 标志位和 ack 确认序列号，ACK 标记位为 1 表示这是包一个确认包，而 ack 确认序列号是 Acknowledgement Number，是对对方初始序列号的回复（ack = x+1），对方以此确认该报文是对其 SYN 报文的回复。ack 确认序列号只有在 ACK 标记位为 1 时才有效 为什么是三次握手TCP 的可靠连接是靠 seq（sequence numbers 序列号）来达成的。 TCP 设计中一个基本设定就是，通过 TCP 连接发送的每一个包，都有一个 sequence number。而因为每个包都是有序列号的，所以都能被确认收到这些包。 确认机制是累计的，所以一个对 sequence number X 的确认，意味着 X 序列号之前 (不包括 X) 包都是被确认接收到的。 所以这样就有一个问题：这条连接突然断开重连后，TCP 怎么样识别之前旧链接重发的包？这就需要独一无二的 ISN（初始序列号）机制。 那么 TCP 连接握手，握的是啥？ 三次握手是为了双方确定彼此的初始序列号 注意：seq = x，这个 x 就是初始序列号 如果是四次握手： 1.1 A 发送同步信号 SYN + A 的初始序列号（Initial sequence number，简称 ISN） 1.2 B 收到后回包，并记录 A 的初始序列号到本地 1.3 B 发送同步信号 SYN + B 的初始序列号 1.4 A 收到后回包，并记录 B 的初始序列号到本地 这样，A 和 B 就互相确认了彼此的初始序列号。但很显然 1.2 和 1.3 这两个步骤可以合并，只需要三次握手 如果是两次握手 2.1 A 发送同步信号 SYN + A 的初始序列号 2.2 B 收到后，发送同步信号 SYN + B 的初始序列号 这种情况，A 的初始序列号双方都知道；但是 B 的初始序列号，B 无法确定 A 是否知道 中途丢包的情况 第一个包，即 A 发给 B 的 SYN 中途被丢，没有到达 B A 会周期性超时重传，直到收到 B 的确认 第二个包，即 B 发给 A 的 SYN+ACK 中途被丢，没有到达 A B 会周期性超时重传，直到收到 A 的确认 第三个包，即 A 发给 B 的 ACK 中途被丢，没有到达 B A 发完 ACK，单方面认为 TCP 为 Established 状态，而 B 显然认为 TCP 为 Active 状态 这种情况下 A 会超时重传这个 ACK 吗？不会！TCP 不会为没有数据的 ACK 超时重传 a. 假定此时双方都没有数据发送，B 会周期性超时重传，直到收到 A 的确认，收到之后 B 的 TCP 连接也为 Established 状态，双向可以发包 b. 假定此时 A 有数据发送，B 收到 A 的 Data + ACK，自然会切换为 established 状态，并接受 A 的 Data c. 假定 B 有数据发送，数据发送不了，会一直周期性超时重传 SYN + ACK，直到收到 A 的确认才可以发送数据 三次握手过程中可以携带数据吗？其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据 为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。 也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。 对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病 SYN 攻击是什么？服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到 SYN 洪泛攻击。 SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。 检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。 参考资料 TCP 为什么是三次握手，而不是两次或四次？ TCP 为什么是四次挥手，而不是三次？ 面试官，不要再问我三次握手和四次挥手","tags":[],"categories":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/categories/网络/"}]},{"title":"","date":"2020-08-15T09:01:58.188Z","path":"网络/HTTPS/","text":"假如客户端要登录，将用户名和密码传到服务器 如果使用 HTTP，会有什么问题HTTP 是明文传输，有以下问题 窃听风险：第三方可以获知通信内容（需要加密） 篡改风险：第三方可以修改通信内容（需要校验） 冒充风险：第三方可以冒充他人身份参与通信（需要信任——证书） 那我可以在客户端先加密，这样就不是明文传输了呀你这种属于对称加密，如果你的密钥是在通信过程中传输，那可能被截获，这样你的信息就泄漏了 那服务器和客户端事先约定好密钥，而不是在通信时才传输，这样就不会泄漏了可以的，但是实际上这样做会很麻烦 那你有什么更好的方法吗使用非对称加密，服务器维护公钥和密钥，通信时，客户端先向服务器端索要公钥，然后用公钥加密信息再传输，服务器收到密文后，用自己的私钥解密 这里的公钥和私钥是什么公开秘钥：简称公钥；私人秘钥：简称私钥 非对称加密的特点就是： 私钥加密后的密文，所有公钥都可以解密（比如数字证书的生成） 公钥加密后的密文，只有私钥可以解密（比如服务器和客户端的加密流程） 私钥只有一个人有，而公钥可以发给所有的人 那看起来很完美了呀 其实这样还有一个安全问题 非对称加密还存在什么安全问题如果第三方拦截住了客户端的公钥请求，然后模仿了服务器的行为，传输给你他自己的公钥 同时，第三方也模拟了客户端向服务器发送公钥请求，得到了服务器的公钥 接着客户端就会把攻击者当做服务器，用假公钥把信息加密传给第三方，第三方再使用自己的私钥解密得到信息 同时，第三方得到了信息之后，模拟客户端使用服务器的公钥进行加密，再传给服务器 这个就是所谓的“中间人攻击”，通过这样的手段，便可以获取客户端和服务器之间通信的所有内容。 那有什么方法防止中间人攻击吗有，使用CA（数字证书认证机构）颁发的数字证书 证书就是服务器将信息（公钥、姓名、邮件等）提供给 CA，CA 把信息写到证书里，再用自己的私钥对这些信息进行加密形成证书的签名，再返回给服务器 简单理解：证书 = CA 私钥对服务器公钥的加密结果 现在服务器不再返回公钥给客户端，而是返回证书 客户端收到证书之后，只需要用 CA 的公钥解密证书的签名得到加密之前的散列值，再计算数字证书中信息（公钥、姓名、邮件等）的散列值，将两者进行对比，只要散列值一致，就证明这张证书没有被篡改过 这个中间人攻击看起来很像 Charles/WireShark 的抓包没错，抓包软件的原理就是中间人攻击，怪不得每次得信任证书是，只要客户端信任了 Charles 的证书，客户端就会把 Charles 当成服务器，Charles 变成了中间人，因此可以监听 HTTPS 的内容 那客户端怎么得到正确的 CA 的公钥呢简单点说，操作系统和浏览器在设备出厂的时候就会内置很多根证书 非对称加密计算量太大，如何减少耗用的时间？客户端得到正确的公钥之后，就可以使用对称加密来传播信息 客户端生成一个“会话密钥”，使用服务器的公钥对该密钥进行加密，将密钥密文传递给服务器。 服务器使用自己的密钥对密钥密文进行解密得到客户端密钥 接下来双方利用会话密钥，来实现对称加密的通信 每一次对话，客户端和服务器端都生成一个”会话密钥”（session key），用它来加密信息。由于”会话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”会话密钥”本身，这样就减少了加密运算的消耗时间 HTTPS 整个工作流程HTTPS 主要分为两个过程： 握手阶段：客户端向服务器端索要公钥；并协商 “会话密钥” 通信阶段：双方采用 “会话密钥” 进行加密通信 其中握手阶段的流程图如下： 我们看看整个流程： 客户端生成一个随机数 RNc（即 Random Number of Client）并发送给服务器【Client-Hello 阶段】 服务器收到后生成 RNs（即 Random Number Of Server），并把 RNs 和证书（含公钥）返回给客户端【Server-Hello 阶段】 客户端校验证书提取公钥并验证；生成 PMS（即 Pre Master Secret），使用公钥加密发送给服务器 服务器使用私钥进行解密得到 PMS 客户端和服务器都使用 RNc、RNs 和 PMS 生成会话密钥，接下来使用会话密钥对通信内容进行对称加密 为什么要使用三个随机数 不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于 SSL 协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。对于 RSA 密钥交换算法来说，pre-master-secret 本身就是一个随机数，再加上 hello 消息中的两个随机数，三个随机数通过一个密钥导出器最终导出一个对称密钥。pre-master-secret 的存在在于 SSL 协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么 pre-master-secret 就有可能被猜出来，那么仅适用 pre-master-secret 作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上 pre-master-secret 三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了 关于安全信任 双方通信内容的安全性是靠公钥加密、私钥解密来保证的，这一安全性由非对称加密的特性，即由公钥加密的信息只能使用对应的私钥才能解开来保证。由于私钥不会传递，只有拥有者知道，所以安全性就由公钥的正确性来保证 公钥由对方在通信初始所提供，但是这时很容易被中间人替换掉，为了保证公钥的正确性，所以在发送公钥的时候也会提供对应的数字证书，用于验证这个公钥是对方的而不是中间人的。那么安全性就是由数字证书的正确性来保证了 数字证书是由上级 CA 签发给个人 / 组织的，上级 CA 用自己的私钥给个人证书进行签名，保证证书中的公钥不被篡改，而接受者需要用上级 CA 证书中的公钥来解密个人数字证书中的数字签名来验证证书中的公钥是否是正确的。那么安全性就是由上级 CA 证书的正确性保证的了 但是，上级 CA 证书也是由其上级 CA 签发的，这种信任关系一直到根证书。根证书没有上级 CA 为其签名，而是自签名的，也就是说，它自身为自身签名，保证正确性。所以根证书就是这个信任链最重要的部分。如果根证书泄露的话，其签名的所有证书及使用其签名的证书所签名的证书的安全性将不复存在。现在，安全性就是靠系统根证书的私钥不被泄露或者其公钥不被篡改来保证的了 根证书不应该通过网络分发，因为通过网络分发的话，可能会被中间人攻击。一般根证书都通过操作系统或者浏览器分发，在操作系统中会内置很多根证书，但是最初的操作系统也不能通过网络分发，因为中间人可以修改操作系统中的根证书。所以要保证安全只能靠最原始的方法，当面交流。硬件厂商会和证书签发机构合作，在电脑、手机等设备出厂的时候在其操作系统中内置签发机构的根证书，再将这些设备分发出去，这样，这些设备的用户就可以安全地进行信息交换了。所以，安全性就依赖于这些设备在分发到消费者手中之前不会被恶意修改来保证了 关于完整性校验HTTPS 通过证书解决了冒充风险，通过加密解决了窃听风险，那么篡改风险如何规避呢？ 当握手阶段结束后，双方进入数据通信阶段。在这个阶段： 发送方会使用协商出来的“会话密钥”对原始消息进行加密，形成密文；同时也会使用哈希算法对原始消息进行计算，形成消息摘要；并将消息摘要和密文同时发送出去 接收方会使用“会话密钥”对密文进行解密，得到原始消息，然后对原始消息使用同样的哈希算法进行计算，将得到的值与消息摘要比较，以此判断是否被篡改过 哈希算法是不可逆的，可以把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射。无论多长的消息都被映射成长度固定的散列值，因此消息长短不会影响完整性校验的性能 More 对称加密：客户端用密钥将对信息进行加密，服务器用同一把密钥将对信息进行解密 发送方和接收方如何共享相同的密钥比较麻烦。一种方法是通过事先协商好而不是通过通信进行协商，避免被监听和截获；另一种是通过非对称加密通道进行对称加密的密钥的传输 对称加密的密钥是一对一的，若服务器要跟多个客户端通信则需要维护多对密钥 非对称加密：公钥和私钥；客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密 不存在密钥分发的问题，解码方可以自己生成密钥对，一个做私钥存起来，另外一个作为公钥进行发布 解决了密钥管理的复杂度问题，多个加密方都可以使用一个已知的公钥进行加密，但只有拥有私钥的一方才能解密 缺点是比对称加密慢 常见算法 常见的对称加密算法：DES、AES、RC2、RC4 常见的非对称加密算法：RSA、DSA 常见的完整性校验算法：MD5、SHA1、SHA256 参考来源 SSL/TLS协议运行机制的概述 一文完全理解HTTPS 完全图解 HTTPS","tags":[],"categories":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/categories/网络/"}]},{"title":"","date":"2020-08-15T09:01:58.176Z","path":"算法/数据结构/链表/","text":"删除单向链表中的指定节点https://leetcode-cn.com/problems/delete-node-in-a-linked-list/ 只能访问当前节点，当前节点不是末尾节点 借尸还魂：将当前节点的值和 next 全部更新为其 next，再删除 next 123456void deleteNode(ListNode *node) &#123; ListNode *next = node-&gt;next; node-&gt;val = next-&gt;val; node-&gt;next = next-&gt;next; delete next;&#125; 移除未排序链表中的重复节点遍历的同时使用 map 记录； 或者 使用双指针，current 用于迭代，runner 用于检查后续节点有无重复 寻找链表中倒数第 K 个元素https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/ 快慢指针 删除链表中某个节点，只能访问该节点，不能访问 headhttps://leetcode-cn.com/problems/delete-node-in-a-linked-list/ 删除后续节点，并将后续节点的值复制到该节点 链表的加法，数字反向存放https://leetcode-cn.com/problems/add-two-numbers/ 迭代，记录进位 链表的加法，数字正向存放https://leetcode-cn.com/problems/add-two-numbers-ii/ 对短的链表补 0 封装 pair 结构记录 ListNode 和进位 递归求解 判断链表是否有环https://leetcode-cn.com/problems/linked-list-cycle/ 双指针必相遇 判断有环链表的环路起始点https://leetcode-cn.com/problems/linked-list-cycle-ii/ 假如链表起点距离环路起点为 k 创建双指针：fast 和 slow；slow 每走一步，fast 走两步 两者相碰时的节点必然距离环路起点 k slow 重置到 head，再以相同的速度移动 slow 和 fast 相碰时必是环路起点 两个链表的相交节点https://leetcode-cn.com/problems/intersection-of-two-linked-lists/ 双指针：先得到两个链表的长度，然后得到长度的差值 distance，两个指针分别从两个链表头部遍历，其中较长链表指针先走 distance 步，然后同时向后走，当两个指针相遇的时候，即链表的交点 链表的中间节点https://leetcode-cn.com/problems/middle-of-the-linked-list/ 123456789101112// 1-&gt;2-&gt;3-&gt;4 则返回 3；1-&gt;2-&gt;3 则返回 2ListNode* middleNode(ListNode* head) &#123; ListNode *fast = head, *slow = head; while (fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return slow;&#125; 反转链表https://leetcode-cn.com/problems/reverse-linked-list/ 反转链表的递归解法非常直观； 1234567891011121314ListNode *reverseList(ListNode *head)&#123; if (!head || !head-&gt;next) &#123; return head; &#125; ListNode *next = head-&gt;next; // reverseList 作用：传入 1-&gt;2-&gt;3，结果为 1&lt;-2&lt;-3，并返回 3 ListNode *after = reverseList(next); next-&gt;next = head; head-&gt;next = NULL; return after;&#125; 迭代解法 12345678910111213ListNode *reverseList(ListNode *head)&#123; ListNode *last = nullptr; ListNode *cur = head; while (cur) &#123; ListNode *next = curNode-&gt;next; cur-&gt;next = last; last = cur; cur = next; &#125; return last;&#125; 判断是否回文链表https://leetcode-cn.com/problems/palindrome-linked-list/ 寻找后半部分的起点 反转后半部分链表 双指针比较前半部分和后半部分的是否相同","tags":[],"categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"http://yoursite.com/categories/算法/数据结构/"}]},{"title":"","date":"2020-08-15T09:01:58.172Z","path":"算法/数据结构/树/","text":"二叉树的最近公共祖先https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree 12345678910111213TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (!root || root == p || root == q) return root; TreeNode *l = lowestCommonAncestor(root-&gt;left, p, q); TreeNode *r = lowestCommonAncestor(root-&gt;right, p, q); if (l &amp;&amp; r) return root; else if (l) return l; else return r;&#125; 判断是否是相同的树https://leetcode-cn.com/problems/same-tree/ 1234567bool isSameTree(TreeNode* p, TreeNode* q) &#123; if (!p &amp;&amp; !q) return true; if (!p || !q) return false; if (p-&gt;val != q-&gt;val) return false; return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);&#125; 判断是否是另一个树的子树https://leetcode-cn.com/problems/subtree-of-another-tree/ 12345678910111213bool isSubtree(TreeNode* s, TreeNode* t) &#123; if (!s || !t) return false; if (isSameTree(s, t)) return true; return isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t);&#125;bool isSameTree(TreeNode* p, TreeNode* q) &#123; if (!p &amp;&amp; !q) return true; if (!p || !q) return false; if (p-&gt;val != q-&gt;val) return false; return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);&#125; 判断是否对称二叉树https://leetcode-cn.com/problems/symmetric-tree/ 123456789101112bool isSymmetric(TreeNode *root)&#123; return isMirror(root, root);&#125;bool isMirror(TreeNode *left, TreeNode *right)&#123; if (!left &amp;&amp; !right) return true; if (!left || !right) return false; if (left-&gt;val != right-&gt;val) return false; return isMirror(left-&gt;left, right-&gt;right) &amp;&amp; isMirror(left-&gt;right, right-&gt;left);&#125; 翻转二叉树https://leetcode-cn.com/problems/invert-binary-tree/ 12345678910TreeNode* invertTree(TreeNode* root) &#123; if (!root) return NULL; TreeNode *left = root-&gt;left; TreeNode *right = root-&gt;right; root-&gt;left = right; root-&gt;right = left; invertTree(left); invertTree(right); return root;&#125; BFShttps://leetcode-cn.com/problems/binary-tree-level-order-traversal/ BFS 时不携带层级信息 12345678910111213141516vector&lt;int&gt; bfs(TreeNode* root) &#123; vector&lt;int&gt; ret; if (!root) return ret; queue&lt;TreeNode *&gt; q; q.push(root); while (!q.empty()) &#123; TreeNode *cur = q.front(); q.pop(); ret.push_back(cur-&gt;val); if (cur-&gt;left) q.push(cur-&gt;left); if (cur-&gt;right) q.push(cur-&gt;right); &#125; return ret;&#125; BFS 时携带层级信息 123456789101112131415161718192021222324vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if (!root) return ret; queue&lt;TreeNode *&gt; q; q.push(root); while (!q.empty()) &#123; vector&lt;int&gt; curLevel; int size = q.size(); for (int i = 0; i &lt; size; i++) &#123; TreeNode *cur = q.front(); q.pop(); curLevel.push_back(cur-&gt;val); if (cur-&gt;left) q.push(cur-&gt;left); if (cur-&gt;right) q.push(cur-&gt;right); &#125; ret.push_back(curLevel); &#125; return ret;&#125;","tags":[],"categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"http://yoursite.com/categories/算法/数据结构/"}]},{"title":"","date":"2020-08-15T09:01:58.169Z","path":"算法/数据结构/动态规划/","text":"最长回文子串https://leetcode-cn.com/problems/longest-palindromic-substring/ https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode/ 12345678910111213141516171819202122232425262728293031323334353637383940string longestPalindrome(string s) &#123; int m = s.size(); if (m == 0) &#123; return \"\"; &#125; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(m, 0)); int start = 0; int length = 1; for (int i = 0; i &lt; m; i++) &#123; // 单个字符属于回文，例如 abcd dp[i][i] = 1; // 连续两个字符相同属于回文，例如 abb if (i &lt; m - 1) &#123; if (s[i] == s[i + 1]) &#123; dp[i][i + 1] = 1; start = i; length = 2; &#125; &#125; &#125; for (int len = 2; len &lt;= m; len++) &#123; for (int i = 0; i &lt; m - len; i++) &#123; int j = i + len; // 扩展长度 if (dp[i + 1][j - 1] == 1 &amp;&amp; s[i] == s[j]) &#123; dp[i][j] = 1; if (j - i + 1 &gt; length) &#123; start = i; length = j - i + 1; &#125; &#125; &#125; &#125; return s.substr(start, length);&#125;","tags":[],"categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"http://yoursite.com/categories/算法/数据结构/"}]},{"title":"","date":"2020-08-15T09:01:58.156Z","path":"算法/搜索/回溯算法/","text":"回溯算法的框架解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题： 1、路径：也就是已经做出的选择。 2、选择列表：也就是你当前可以做的选择。 3、结束条件：也就是到达决策树底层，无法再做选择的条件。 如果你不理解这三个词语的解释，没关系，我们后面会用「全排列」和「N皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。 代码方面，回溯算法的框架： 12345678910result = []def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」，特别简单。 全排列问题Leetcode：46.全排列 12345678910111213141516171819202122232425262728293031323334vector&lt;vector&lt;int&gt;&gt; ret;void backtrack(vector&lt;int&gt; &amp;path, vector&lt;int&gt; &amp;nums)&#123; // 满足结束条件 if (path.size() == nums.size()) &#123; ret.push_back(path); return; &#125; for (int num : nums) &#123; // 排除不合法的选择 // 这一步可以优化为 swap，但是理解起来比较复杂 if (find(path.begin(), path.end(), num) != path.end()) &#123; continue; &#125; // 做选择 path.push_back(num); // 递归 backtrack(path, nums); // 撤销选择 path.pop_back(); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; path; backtrack(path, nums); return ret;&#125; N 皇后问题N 皇后 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859vector&lt;vector&lt;string&gt;&gt; res;/* 输入棋盘边长 n，返回所有合法的放置 */vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; // '.' 表示空，'Q' 表示皇后，初始化空棋盘。 vector&lt;string&gt; board(n, string(n, '.')); backtrack(board, 0); return res;&#125;// 路径：board 中小于 row 的那些行都已经成功放置了皇后// 选择列表：第 row 行的所有列都是放置皇后的选择// 结束条件：row 超过 board 的最后一行void backtrack(vector&lt;string&gt;&amp; board, int row) &#123; // 触发结束条件 if (row == board.size()) &#123; res.push_back(board); return; &#125; for (int col = 0; col &lt; board[row].size(); col++) &#123; // 排除不合法选择 if (!isValid(board, row, col)) continue; // 做选择 board[row][col] = 'Q'; // 进入下一行决策 backtrack(board, row + 1); // 撤销选择 board[row][col] = '.'; &#125;&#125;bool isValid(vector&lt;string&gt;&amp; board, int row, int col)&#123; int n = board.size(); // 检查【列】是否有皇后互相冲突（board 中大于 row 的那些行没有放置皇后） for (int i = 0; i &lt;= row; i++) &#123; if (board[i][col] == 'Q') return false; &#125; // 检查【右上方】是否有皇后互相冲突（board 中大于 row 的那些行没有放置皇后） for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123; if (board[i][j] == 'Q') return false; &#125; // 检查【左上方】是否有皇后互相冲突（board 中大于 row 的那些行没有放置皇后） for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) &#123; if (board[i][j] == 'Q') return false; &#125; return true;&#125; 字母大小全排列784. 字母大小写全排列 12345678910111213141516171819202122232425262728293031323334353637383940vector&lt;string&gt; ret;void backtrack(string path, string S)&#123; if (path.size() == S.size()) &#123; ret.push_back(path); return; &#125; char c = S[path.size()]; path += c; backtrack(path, S); // 字母需要回溯，数字不需要 if (isalpha(c)) &#123; // 回退再选择一次 path = path.substr(0, path.size()-1); // 大写转小写；小写转大写 if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') &#123; path += tolower(c); &#125; else &#123; path += toupper(c); &#125; backtrack(path, S); &#125;&#125;vector&lt;string&gt; letterCasePermutation(string S) &#123; ret = &#123;&#125;; if (S.size() == 0) return ret; string path; backtrack(path, S); return ret;&#125; 参考 回溯算法详解","tags":[],"categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"},{"name":"搜索","slug":"算法/搜索","permalink":"http://yoursite.com/categories/算法/搜索/"}]},{"title":"","date":"2020-08-15T09:01:58.139Z","path":"算法/排序/快速排序/","text":"123456789101112131415161718192021222324252627282930313233343536void quickSort(int s[], int l, int r)&#123; if (l &gt;= r) &#123; return; &#125; int i = l, j = r, x = s[l]; while (i &lt; j) &#123; while (s[j] &gt;= x &amp;&amp; i &lt; j) &#123; j--; &#125; if (i &lt; j) &#123; s[i++] = s[j]; &#125; while (s[i] &lt; x &amp;&amp; i &lt; j) &#123; i++; &#125; if (i &lt; j) &#123; s[j--] = s[i]; &#125; &#125; s[i] = x; quickSort(s, l, i-1); quickSort(s, i+1, r);&#125;","tags":[],"categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"},{"name":"排序","slug":"算法/排序","permalink":"http://yoursite.com/categories/算法/排序/"}]},{"title":"","date":"2020-08-15T09:01:58.133Z","path":"算法/排序/堆排序/","text":"图解堆排序堆排序是什么 堆排序的步骤 将无序数组就地交换，堆化为最大堆 将堆顶元素与末尾元素交换，将最大元素沉到数组末端； 重复步骤 1 和 2，直到整个数组有序 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445// 构造小顶堆void adjustHeap(int s[], int n, int cur)&#123; int tmp = s[cur]; // 从 cur 的左子节点开始 for (int i = 2 * cur + 1; i &lt; n; i = i * 2 + 1) &#123; // 如果存在右子节点且右子节点更小 if (i + 1 &lt; n &amp;&amp; s[i + 1] &lt; s[i]) &#123; i++; &#125; // 找到左右节点中最小的元素与当前元素交换 if (tmp &gt; s[i]) &#123; s[cur] = s[i]; // 暂时不需要处理最初被交换的那个 cur = i; // 以同样的方法处理子节点 &#125; else &#123; // 如果当前元素比子节点都小，满足条件，退出 break; &#125; &#125; s[cur] = tmp;&#125;void heapSort(int s[], int n)&#123; // 步骤 1：建堆 // 从第一个非叶子结点从下至上，从右至左调整结构 for (int i = n / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(s, n, i); &#125; // 步骤 2：交换元素，重新调整堆 for (int i = n - 1; i &gt; 0; i--) &#123; swap(s[0], s[i]); adjustHeap(s, i, 0); &#125;&#125; 复杂度 建堆的复杂度是 O(N) 交换 N 次，调整的复杂度为 O(logN) 所以堆排序复杂度为：O(NlogN) 建堆时间复杂度为什么是 O(N) 应用找出无序数组中位数，要求O(N)复杂度找出无序数组中第 K 大元素考虑 K = 1 的时候如何处理，K = 2、3 呢？最终会考虑到最大堆的建立","tags":[],"categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"},{"name":"排序","slug":"算法/排序","permalink":"http://yoursite.com/categories/算法/排序/"}]},{"title":"","date":"2020-08-15T09:01:58.129Z","path":"算法/排序/基本排序/","text":"选择排序每次挑最小的放左边 123456789101112131415void selectionSort(int s[], int n)&#123; for (int i = 0; i &lt; n-1; ++i) &#123; int minIndex = i; for (int j = i+1; j &lt; n; ++j) &#123; if (s[j] &lt; s[minIndex]) &#123; minIndex = j; &#125; &#125; swap(s[i], s[minIndex]); &#125;&#125; 插入排序从左往右遍历，取出当前元素有序地插到其左半部分 1234567891011121314151617void insertionSort(int s[], int n)&#123; for (int i = 1; i &lt; n; ++i) &#123; for (int j = i; j &gt;= 1; --j) &#123; if (s[j] &lt; s[j-1]) &#123; swap(s[j], s[j-1]); &#125; else &#123; break; &#125; &#125; &#125;&#125; 冒泡排序从左往右进行两两比较，每一趟可以使最大值在最右边 12345678910111213void bubbleSort(int s[], int n)&#123; for (int i = n-1; i &gt; 0; --i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (s[j] &gt; s[j+1]) &#123; swap(s[j], s[j+1]); &#125; &#125; &#125;&#125; 改进冒泡排序：优化外层循环如果某一趟比较没有数值交换，则说明已经排好序；处理在排序过程中数组整体已经有序的情况 123456789101112131415161718192021void bubbleSort2(int s[], int n)&#123; for (int i = n-1; i &gt; 0; --i) &#123; bool isSorted = true; for (int j = 0; j &lt; i; ++j) &#123; if (s[j] &gt; s[j+1]) &#123; swap(s[j], s[j+1]); isSorted = false; &#125; &#125; if (isSorted) &#123; return; &#125; &#125;&#125; 改进冒泡排序：优化内层循环每一趟遍历记录最后一次交换的位置，这个位置后的元素其实都是有序的，不需要再次比较 123456789101112131415161718void bubbleSort3(int s[], int n)&#123; int endPos = n-1; for (int i = n-1; i &gt; 0; --i) &#123; int lastExchangeIndex = 0; for (int j = 0; j &lt; endPos; ++j) &#123; if (s[j] &gt; s[j+1]) &#123; swap(s[j], s[j+1]); lastExchangeIndex = j; &#125; &#125; endPos = lastExchangeIndex; &#125;&#125;","tags":[],"categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"},{"name":"排序","slug":"算法/排序","permalink":"http://yoursite.com/categories/算法/排序/"}]},{"title":"","date":"2020-08-15T09:01:58.068Z","path":"不务正业/设计/设计零碎/","text":"《大标题设计原则：不要为了用大标题而做大标题》","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"设计","slug":"不务正业/设计","permalink":"http://yoursite.com/categories/不务正业/设计/"}]},{"title":"知识碎片","date":"2020-08-15T09:01:58.059Z","path":"不务正业/未分类/知识碎片/","text":"Tree命令行下展示目录结构的神器——tree，使用 brew install tree 来安装 使用 ll 作为 ls -l 的别名123456cd ~touch .bash_profileecho \"alias l='ls -alhF'\" &gt;&gt;.bash_profileecho \"alias la='ls -AFh'\" &gt;&gt;.bash_profileecho \"alias ll='ls -lhAF'\" &gt;&gt;.bash_profilesource ~/.bash_profile 如何优雅地使用 KVO 如何优雅地使用 KVO Facebook/KVOController 使用 __kindof如果以下代码不加 __kindof 就会产生 Warning 1234567NSMutableArray&lt;__kindof UIView *&gt; *subviews = @[].mutableCopy;[subviews addObject:[[UIView alloc] init]]; // Works[subviews addObject:[[UIImageView alloc] init]]; // Also works UIView *sameView = subviews[0]; // No problemUIImageView *sameImageView = subviews[1]; // No complaints now! 预览 Github 的 html在 html 的源地址前面添加 http://htmlpreview.github.io/? 即可 return 前执行12#define OnExit \\__strong void(^block)(void) __attribute__((cleanup(blockCleanUp), unused)) = ^ 尾调用优化 尾调用优化 iOS objc_msgSend尾调用优化机制详解 iOS Bug 定位 .dSYM + .app + .crash 的 UUID 必须一致 查看 app 的 UUID dwarfdump –uuid XXX.app/XXX https://www.cnblogs.com/ningxu-ios/p/4141783.html","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"未分类","slug":"不务正业/未分类","permalink":"http://yoursite.com/categories/不务正业/未分类/"}]},{"title":"查找日志技巧","date":"2020-08-15T09:01:58.056Z","path":"不务正业/未分类/查找日志技巧/","text":"将文本中带有 viewWillAppear 的所有行打印出来1cat test.log | grep -n -i 'viewWillAppear' &gt; result.log 其中，-n:显示行号；-i 忽略大小写 将文本中带有 QLASIHTTPRequest 的所有行过滤掉1sed '/QLASIHTTPRequest/d' test.log &gt; result.log /QLASIHTTPRequest/d 表示对所有匹配到 QLASIHTTPRequest 的行执行 delete 命令 关于 sed 的更多用法，见 SED 简明教程 使用正则表达式查找 C++ 所有的复制构造函数以 QVNContext::QVNContext(const QVNContext &amp;context) 为例 1(.+)::\\1\\(.*\\1\\s.*","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"未分类","slug":"不务正业/未分类","permalink":"http://yoursite.com/categories/不务正业/未分类/"}]},{"title":"","date":"2020-08-15T09:01:58.053Z","path":"不务正业/未分类/《程序员修炼之道》小抄/","text":"第一次看这本书还是在大三的时候，当时只看了一半就放弃了。如今工作三年多了，昨天晚上大概花了2个小时的时间看完这本书，发现讲的其实还是挺基础的，有些之前不懂的地方现在也豁然开朗了，相信过几年再回读，可能会有新的收获。此之谓常读常新。 不要容忍破窗户 不要留着“破窗户”（低劣的设计、错误决策、或是糟糕的代码）不修。发现一个就修一个。如果没有足够的时间进行适当的修理，就用木板把它钉起来。或许你可以把出问题的代码放入注释（comment out），或是显示“未实现”消息，或是用虚设的数据（dummy data）加以替代 不要追求完美 不要因为过度修饰和过于求精而毁损完好的程序。继续前进，让你的代码凭着自己的质量站立一会儿。它也许不完美，但不用担心：它不可能完美 想要开发一个 App 或者实现一个功能的时候，先让代码跑起来，允许不完美。后续再快速迭代增加新功能和修复 Bug，效果会比什么都规划好之后再动手更好 批判地分析你读到的和听到的 批判地思考你读到的和听到的。你需要确保你的资产中的知识是准确的 Web搜索引擎把某个页面列在最前面，并不意味着那就是最佳选择；内容供应商可以付钱让自己排在前面。书店在显著位置展示某一本书，也并不意味着那就是一本好书，甚至也不说明那是一本受欢迎的书；它们可能是付了钱才放在那里的 从谷歌或百度搜索到的知识进行思考和验证，确保每个进入脑海的知识都是准确的。一般来说，书籍更加权威 DRY – Don’t Repeat Yourself代码注释 糟糕的代码才需要许多注释。DRY法则告诉我们，要把低级的知识放在代码中，它属于那里；把注释保留给其他的高级说明。否则，我们就是在重复知识，而每一次改变都意味着既要改变代码，也要改变注释。注释将不可避免地变得过时，而不可信任的注释比完全没有注释更糟 注释应该讨论为何要做某事、它的目的和目标。代码已经说明了它是怎样完成的，所以再为此加上注释是多余的，而且违反了 DRY 原则 Use the Power of Command ShellsAlways Use Source Code Control 总是。即使你的团队只有你一个人，你的项目只需一周时间；即使那是“用过就扔”的原型；即使你的工作对象并非源码 学习一种文本操纵语言至少精通一种 编写能编写代码的代码我自己写的代码生成器：Jce 生成工具、播放器事件生成工具、多终端配置工具 DBC：按合约设计（Design with Contracts） 前条件：为了调用例程，必须为真的条件 后条件：例程保证会做的事情，例程完成时世界的状态 类不变项：从调用者的角度来说，该条件总是为真。例程内部处理过程中，不变项不一定会保持，但在例程退出的时候，不变项必须为真 12345678910/*** @类不变项：列表是升序排列*/public class dbc_list &#123; /** * @pre contains(aNode) == false * @post contains(aNode) == true */ public void insertNode(final Node aNode) &#123;// ... 谁负责检查前条件，应该是调用者。比如 sqrt(int) 这个函数，参数不能为负数这个前条件应该由调用者来保证 如果它不可能发生，用断言确保它不会发生 不要用断言代替真正的错误处理。断言检查的是决不应该发生的事情 123printf(\"Enter 'Y' or 'N': \");ch = getchar();assert((ch == 'Y') || (ch == 'N')); /* bad idea! */ 处理用户的异常输入应该属于错误处理，不可用断言检查，因为用户输入异常不是不可能发生的事情 在C++异常机制下配平资源1234567891011void doSomething(void) &#123; Node *n = new Node; try &#123; // do something &#125; catch (...) &#123; delete n; throw; &#125; delete n;&#125; 注意我们创建的节点是在两个地方释放的——一次是在例程正常的退出路径上，一次是在异常处理器中。这显然违反了DRY原则，可能会发生维护问题。 一种最简单的解决方法是不使用指针即可，栈对象会自动释放；另一种优雅的解决方法是，使用新定义的对象包装好指针对象，这个其实就是 auto_ptr 的原理 123456789101112131415161718// Wrapper class for Node resourcesclass NodeResource &#123; Node *n; public: NodeResource() &#123; n = new Node; &#125; ~NodeResource() &#123; delete n; &#125; Node *operator-&gt;() &#123; return n; &#125;&#125;;void doSomething2(void) &#123; NodeResource n; try &#123; // do something &#125; catch (...) &#123; throw; &#125;&#125; C++ 中，为什么对指针 delete 之后还要置空？ NULL 指针可以防止多次 delete 出错 防止指针成为野指针；对 NULL 指针解引用会导致运行时错误（野指针更难定位，因为对野指针解引用不一定会出现崩溃） 迪米特法则（德墨忒耳法则/最少知识原则）迪米特法则规定，某个对象的任何方法都应该只调用属于以下情形的方法： 1234567891011121314151617class Demeter&#123;public: void example(B &amp;b);private: A *a; int func()&#123;&#125;&#125;void Demeter::example(B &amp;b)&#123; C c; int f = func(); &lt;------------------1. 它自身 b.invert(); &lt;----------------------2. 传入该方法的任何参数 a = new A(); a-&gt;setActive(); &lt;------------------3. 它创建的任何对象 c.print(); &lt;-----------------------4. 任何直接持有的组件对象&#125; 举个例子，以下调用不符合迪米特法则 12345void showBalance(Account account)&#123; Money money = account.getBalance(); printToScreen(monney.printFormat());&#125; 将抽象放进代码，细节放进元数据npm 的 package.json、hexo 的主题配置、markdown、 git 的 config 等这些都是以元数据的形式进行配置 常识估算 简单循环：O(n)，比如查找数组最大值 嵌套循环：O(n²)，比如冒泡排序 二分法：O(lg(n))，比如二分查找、遍历二叉树 分而治之：O(nlg(n))，划分其输入，并独立地在两个部分上进行处理，然后再把结果组合起来的算法，比如快速排序、归并排序 组合：O(Cⁿ)，只要算法考虑事物的排列，其运行时间就可能失控，这是因为排列涉及到阶乘，比如旅行商问题 重构注意 不要试图在重构的同时增加功能 在开始重构之前，确保你拥有良好的测试 采用短小、深思熟虑的步骤，重构往往涉及到进行许多局部改动，继而产生更大规模的改动。如果你使你的步骤保持短小，并且在每个步骤之后进行测试，你将能够避免长时间的调试。","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"未分类","slug":"不务正业/未分类","permalink":"http://yoursite.com/categories/不务正业/未分类/"}]},{"title":"Hexo 特性","date":"2020-08-15T09:01:58.049Z","path":"不务正业/未分类/Hexo 特性/","text":"Travis CI 自动构建NexT 主题添加点击的爱心效果NexT 主题内接入网页在线联系功能NexT 主题中添加网页标题崩溃欺骗搞怪特效NexT 主题添加圆角效果以 Pisces 模式为例，其他模式同理 themes/next/source/css/_schemes/Pisces/_sidebar.styl 添加 border-radius 属性 12345678910111213141516.sidebar &#123; display: none; right: auto; bottom: auto; -webkit-transform: none; border-radius:10px;&#125;.sidebar-inner &#123; box-sizing: border-box; width: 240px; color: $text-color; background: white; border-radius:10px; &amp;.affix &#123; top: 0px; position: fixed; &#125;&#125; themes/next/source/css/_schemes/Pisces/_layout.styl添加 border-radius 属性 1234567.sidebar-position-right &#123; .header-inner &#123; right: 0; border-radius:10px;&#125; .content-wrap &#123; float: left; &#125; .sidebar &#123; float: right; &#125; .footer-inner:before &#123; float: right; &#125;&#125; NexT 主题添加动态背景themes/next/layout/_layout.swig 添加以下代码 1234&#123;% if theme.canvas_nest %&#125;&lt;!-- 可选配置：color=\"0,255,255\" opacity=\"0.7\" count=99 zIndex=\"0\"--&gt;&lt;script type=\"text/javascript\" color=\"51,163,220\" opacity=\"0.8\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt;&lt;/script&gt;&#123;% endif %&#125; 不蒜子统计一些坑如果使用了分割线，则生成 html 失败（已经第二次踩坑）","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"未分类","slug":"不务正业/未分类","permalink":"http://yoursite.com/categories/不务正业/未分类/"}]},{"title":"","date":"2020-08-15T09:01:58.039Z","path":"不务正业/小程序/小程序踩坑/","text":"setData 的 key 中含有变量12var originData = \"fmList[\"+index+\"].isStar\";this.setData(&#123;[originData]: isStar&#125;); wx.setStorageSync 不能直接缓存 Map/Set123456789// Getlet storagedList = wx.getStorageSync(StorageKey);if (storagedList) &#123; this.favList = new Set(storagedList);&#125;// Set// storage 不支持 set，只能转为 arraywx.setStorageSync(StorageKey, Array.from(this.favList)) 音频播放被抢占过久如果音频被抢占过久，等到页面出现时，播放器会 Loading，此时直接 replay 是没有效果的，需要通过 src 重置播放器 1234567891011onShow: function () &#123; console.log(\"onShow\"); if (!this.data.isPlaying) &#123; // 如果音频被抢占过久，等到页面出现时，播放器会 Loading， // 此时直接 replay 是没有效果的，需要通过 src 重置播放器 this.backgroundPlayer.src = this.data.playerData.src; &#125; // 每次出现就要重新启动播放，包括第一次 this.replay();&#125;, 子 view 超出父 view 的部分仍然响应了点击目前只能在超出部分盖一层 View，并给它添加点击事件来解决 内容超过容器，导致可以滚动以禁止竖直为例：overflow-y:hidden 设置透明背景 正确：background-color:rgba(0,0,0,0) 错误：background-color:clear 胡子通知顺序不一致123456&#123;&#123;a || b&#125;&#125;a = true, b = falsethis.setData(&#123;a:false&#125;);this.setData(&#123;b:true&#125;); 结果可能导致 b 的变化比 a 的变化先通知 CSS 变量123456789page &#123; --music-item-width: 5rpx; --music-item-count: 7;&#125;.music_bar &#123; width: var(--music-item-width); height: calc(var(--music-item-width)*var(--music-item-count));&#125; 布尔值的胡子语法1234567&lt;!-- 生效 --&gt;&lt;van-popup show=\"&#123;&#123;false&#125;&#125;\"&gt;&lt;/van-popup&gt;&lt;!-- 不生效 --&gt;&lt;van-popup show=\"false\"&gt;&lt;/van-popup&gt; scroll-view 的坑竖直滑动的 scroll-view, 需要给 scroll-view 一个固定的高度（比如 100%），设置属性 scroll-y 1&lt;scroll-view class='root' scroll-y&gt; 1234.root &#123; width: 100%; height: 100%;&#125; van-popup 滚动时，事件穿透到底下的 View解决方案 网络回包12345678910wx.request(&#123; url: 'https://norcy.weimiaotech.com/SmallFrequence/regions?version='+version, header: &#123; 'content-type': 'application/json' // 默认值 &#125;, success(res) &#123; console.log(\"Request Category Sucess\" + res.data.data.length); self.didCategoryRequestFinished(res.data.data); &#125;&#125;) 这样当 res.data 是空的时候，res.data.data 会变成 undefined，从而访问 length 的时候会出错 注意获取二维码的 scene 值最多只支持 32 个字母text 标签出现顶部空白123&lt;text&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt; 改为 1&lt;text&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt;","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"小程序","slug":"不务正业/小程序","permalink":"http://yoursite.com/categories/不务正业/小程序/"}]},{"title":"","date":"2020-08-15T09:01:58.026Z","path":"不务正业/前端/JavaScript/","text":"== 和 === 区别 === 严格相等，会比较两个值的类型和值 == 抽象相等，比较时，会先进行类型转换，然后再比较值 建议用 === 具体可见 js 中 == 和 === 的区别 JavaScript 中的相等性判断 Js 中如何正确创建一个类1234567function Cat(name,color)&#123; this.name = name; this.color = color;&#125;Cat.prototype.type = \"猫科动物\";Cat.prototype.eat = function()&#123;alert(\"吃老鼠\")&#125;; 使用构造函数，成员变量使用 this 在构造函数中初始化； 所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。 1234var cat1 = new Cat(\"大毛\",\"黄色\");var cat2 = new Cat(\"二毛\",\"黑色\");alert(cat1.name); // 大毛alert(cat1.color); // 黄色 类变量和方法定义在 prototype 上 构造函数有一个 prototype 对象，该对象的所有属性和方法，都会被构造函数的实例继承。因此在这里定义类变量和方法可以实现不同对象之间的数据共享 参考：Javascript 面向对象编程（一）：封装","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"前端","slug":"不务正业/前端","permalink":"http://yoursite.com/categories/不务正业/前端/"}]},{"title":"库体积优化","date":"2020-08-15T09:01:58.017Z","path":"不务正业/Xcode/库/库体积优化/","text":"概念符号表符号表是内存地址与函数名、文件名、行号的映射表。符号表元素如下所示： &lt;起始地址&gt; &lt;结束地址&gt; &lt;函数&gt; [&lt;文件名:行号&gt;] Debug Symbol 调试符号借助符号调试程序可以将原始符号表转换成可读性较强的符号表，主要是方便开发人员获取调试信息 还原前： 12345Thread 0 Crashed:0 libobjc.A.dylib 0×300c87ec 0×300bb000 + 552761 MobileLines 0×00006434 0×1000 + 215562 MobileLines 0×000064c2 0×1000 + 216983 UIKit 0×30a740ac 0×30a54000 + 131244 还原后： 12345Thread 0 Crashed:0 libobjc.A.dylib 0×300c87ec objc_msgSend + 201 MobileLines 0×00006434 -[BoardView setSelectedPiece:] (BoardView.m:321)2 MobileLines 0×000064c2 -[BoardView touchesBegan:withEvent:] (BoardView.m:349)3 UIKit 0×30a740ac -[UIWindow sendEvent:] + 264 DWARF一种支持源代码级别调试的调试文件格式 DWARF是平台独立的且适用于任何处理器任何操作系统 dSYMiOS平台中，dSYM文件是指具有调试信息的目标文件，文件名通常为：xxx.app.dSYM 为了避免进行 Strip 操作后调试符号的丢失，你可以使用dwarf-with-dsym选项。 DWARF with dSYM 选项在标准的DWARF之外执行一个额外的步骤：创建一个单独的MyApp.app.dSYM文件，这个文件包含你的程序的所有调试符号(这个文件其实是一个包，可以通过右键-&gt;显示包内容进行查看)。 事实上，DWARF with dSYM选项允许你对你进行单步调试而不管可执行程序是否被剥离了调试信息(stripped)。 这是可能的，这是因为gdb将会在你的程序的目录下查找.dSYM文件。它不需要知道对象文件(object files)的名字或者路径。如果你不除去调试符号 (strip debugging symbols)，你可以使用.o或者.dSYM文件来调试。 DWARF - Object files and linked products will use DWARF as the debug information format. [dwarf] DWARF with dSYM File - Object files and linked products will use DWARF as the debug information format, and Xcode will also produce a dSYM file containing the debug information from the individual object files (except that a dSYM file is not needed and will not be created for static library or object file products). [dwarf-with-dsym] 静态库无法产生 dsym 编译选项Generate Debug Symbols是否产生调试符号 当Generate Debug Symbols设置为YES时，编译产生的.o文件会大一些，当然最终生成的可执行文件也大一些（亲测如此） 当Generate Debug Symbols设置为NO的时候，在Xcode中设置的断点不会中断。但是在程序中打印 [NSThread callStackSymbols]，依然可以看到类名和方法名 在程序崩溃时，也可以得到带有类名和方法名的函数调用栈 19 QQLiveInternational 0x00000001069c2515 -[QVNUICustomView layoutSubviews] + 3253 结论：Debug/Release 均打开 Debug Information Level调试符号携带的信息等级 Debug Information Level 默认值为 Compiler default，另一个选项是 Line tables only Generate Debug Symbols = YES 的前提下，如果选择 Line tables only，调试信息带有函数名、文件名和行号，但是不包含其他数据（比如局部变量和函数参数）。所以断点可以工作，但是无法在 lldb 中查看局部变量的值（亲测如此） Deployment Postprocessing该选项是所有 Strip 选项的总开关 Strip，也就是把生成的 .o 文件中剥离特定的符号（symbols） Strip Linked Product 如果 Deployment Postprocessing 不打开，该选项没有作用 如果该选项生效，app 构建的过程多了两步 在app构建的开始，会生成一些.hmap辅助文件 在app构建的末尾，会执行Strip操作 如果该选项生效，断点不会中断，在程序中打印 [NSThread callStackSymbols] 也无法看到类名和方法名，程序崩溃时无法看到类名和方法名 Strip StyleStrip Linked Product 打开时该选项才生效（待验证） 剥离符号的程度依次是All Symbols &gt; Non-Global Symbols &gt; Debugging Symbols All Symbols：剥离所有符号表和重定向信息，适用于最后生成 .app 的工程 Non-Global Symbols：剥离非全局的符号（包括调试符号），保留外部符号，适用于 bundle 和 framework Debugging Symbols：剥离调试符号，保留局部符号和全局符号，都适用 Strip Linked Product = YES 时，如果把 Strip Style 从 All Symbols 改为 Debugging Symbols，则程序崩溃时就可以看到类名和方法名 注意如果构建的是一个静态库，则不可以 strip all，因为剥离了所有符号的静态库是无法被正常链接的（亲测编译失败） Link Time Optimization优点： 将一些函数內联化 去除了一些无用代码 对程序有全局的优化作用 缺点： 降低编译链接速度，只建议在打正式包时开启 降低 link map 可读性（多出了很多数字开头的“类”） 我是如何把 600M 的库减少到 30M123Deployment Postprocessing = 1Strip Linked Product = 1Strip Style = Non-Global Symbols 不过这样会导致 crash 时无法查看堆栈信息 参考文章 Xcode中和symbols有关的几个设置（好文） 干货|今日头条iOS端安装包大小优化—思路与实践 注意 是对 Framrwork 的 Target 进行设置，而不是用于打包的 Target Generate Debug Symbols = NO，Deployment Postprocessing = NO时，体积仍然很大（猜测：strip 不止剥离了 debug symbols，还剥离了其他内容，比如符号表）","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"Xcode","slug":"不务正业/Xcode","permalink":"http://yoursite.com/categories/不务正业/Xcode/"},{"name":"库","slug":"不务正业/Xcode/库","permalink":"http://yoursite.com/categories/不务正业/Xcode/库/"}]},{"title":"动态库和静态库","date":"2020-08-15T09:01:58.013Z","path":"不务正业/Xcode/库/动态库和静态库/","text":"[TOC] 库什么是库 库的本质是一段编译好的二进制代码，加上头文件就可以供别人使用。 库从广义上可分为开源库和闭源库, 而闭源库才分为静态库和动态库 开源库：对外公开源代码, 能看到具体的代码实现, 例如Github上面的第三方开源库都称之为开源库 闭源库：不公开源代码, 文件是经过编译后的二进制文件, 看不到具体实现 为什么要用库 保护代码：某些代码需要给别人使用，但是我们不希望别人看到源码，就需要以库的形式进行封装，只暴露出头文件 提高编译速度：对于某些不会进行大的改动的代码，我们想减少编译的时间，就可以把它打包成库，因为库是已经编译好的二进制了，编译的时候只需要 Link 一下，不会浪费编译时间 静态库和动态库上面提到库在使用的时候需要 Link，Link 的方式有两种，静态和动态，于是便产生了静态库和动态库 静态库静态库即静态链接库（Windows 下的 .lib，Linux 和 Mac 下的 .a） 之所以叫做静态，是因为静态库在编译的时候会被直接拷贝一份，复制到目标程序里，这段代码在目标程序里就不会再改变了 所以如果两个程序都用了某个静态库，那么每个二进制可执行文件里面其实都含有这份静态库的代码 优点是编译完成之后，目标程序不再依赖库文件，直接就可以运行 缺点是会使用目标程序的体积增大 动态库动态库即动态链接库（Windows 下的 .dll，Linux 下的 .so，Mac 下的 .dylib/.tbd） 与静态库相反，动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用。等到程序运行时，动态库才会被真正加载进来 优点是，不会影响目标程序的体积（不需要拷贝到目标程序中），而且同一份库可以被多个程序共享使用；同时，编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码 缺点是，动态载入会带来一部分性能损失，使用动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行（Linux 下喜闻乐见的 lib not found 错误） Framework什么是 FrameworkFramework 是Cocoa/Cocoa Touch程序中使用的一种资源打包方式，可以将代码文件(.a)、头文件、资源文件、说明文档等集中在一起，方便开发者使用 系统的 Framework 是动态库，开发者自己开发的 Framework 是静态库 其实是资源打包的方式，和静态库动态库的本质是没有关系的 苹果在iOS平台上规定不允许存在动态库，但是为了 App 和 Extension 能够共享代码，提出了 Embedded Framework .a与.framework的区别 .a是一个纯二进制文件不能直接使用，必须要有.h文件才能使用，.h文件对外提供接口 .framework中除了有二进制文件之外还有资源文件，可以直接使用所以开发中建议使用.framework .a、.dylib 和 .tbd.a：静态库的后缀名.dylib：动态库的后缀名.tbd：text-based stub libraries，本质上就是一个YAML描述的文本文件。iOS 7 之后取代 .dylib。具体请看这里 动态 Framework 和静态 Framework使用 file 命令可以判断 .framework 中的可执行文件是动态还是静态 123456file GPUImage.framework/GPUImageGPUImage.framework/GPUImage: Mach-O universal binary with 4 architectures: [i386:Mach-O dynamically linked shared library i386] [arm64]GPUImage.framework/GPUImage (for architecture i386): Mach-O dynamically linked shared library i386GPUImage.framework/GPUImage (for architecture x86_64): Mach-O 64-bit dynamically linked shared library x86_64GPUImage.framework/GPUImage (for architecture armv7): Mach-O dynamically linked shared library arm_v7GPUImage.framework/GPUImage (for architecture arm64): Mach-O 64-bit dynamically linked shared library arm64 12345file TVKPlayer.framework/TVKPlayerTVKPlayer.framework/TVKPlayer: Mach-O universal binary with 3 architectures: [arm_v7:current ar archive] [arm64]TVKPlayer.framework/TVKPlayer (for architecture armv7): current ar archiveTVKPlayer.framework/TVKPlayer (for architecture x86_64): current ar archiveTVKPlayer.framework/TVKPlayer (for architecture arm64): current ar archive 可以看到 GPUImage 有 dynamic，它是动态 framework，而 TVKPlayer 是静态的 如果是动态的 Framework，添加到工程的时候需要在 Embedded Binaries 下面手动添加，意思是嵌入，并不是嵌入 app 可执行文件，而是嵌入 app 的 bundle 文件。当一个 app 通过 Embedded 的方式嵌入一个 app 后，在打包之后解压 ipa 可以在包内看到一个 framework 的文件夹，下面都是与这个应用相关的动态 framework 如果是静态的 Framework，添加到工程的时候需要在 Linked Frameworks and Libraries 添加，这些 Framework 将会被拷贝到 App 的可执行文件中 架构 123// 1. 模拟器使用的CPU架构： i386: iPhone4s - iPhone5x86_64: iPhone5s - iPhoneX 123456// 2. 真机使用的CPU架构： armv6: iPhone、iPhone 2、iPhone 3G、iPod Toucharmv7: iPhone3Gs - iPhone4sarmv7s: iPhone5、iPhone5carm64: iPhone5s - iPhoneX（没有armv64） 命令查看 .a 支持的架构lipo -info xxx.a 合并成通用架构lipo -create 模拟器架构.a 真机架构.a -output 目标通用架构.a 参考iOS - 静态库、动态库、Framework组件化-动态库实战","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"Xcode","slug":"不务正业/Xcode","permalink":"http://yoursite.com/categories/不务正业/Xcode/"},{"name":"库","slug":"不务正业/Xcode/库","permalink":"http://yoursite.com/categories/不务正业/Xcode/库/"}]},{"title":"新建工程移除StroyBoard","date":"2020-08-15T09:01:58.004Z","path":"不务正业/Xcode/新建工程移除StroyBoard/","text":"移除 Main.storyboard 文件 移除 LaunchScreen.storyboard 在 TARGETS 中，将 Main InInterface 选项中的值清空 AppDelegate.m 替换以下函数，并 #import &quot;ViewController.h&quot; 123456789101112- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; ViewController *viewController = [[ViewController alloc] init]; self.window.rootViewController = viewController; self.window.backgroundColor = [UIColor whiteColor]; [self.window makeKeyAndVisible]; return YES;&#125;","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"Xcode","slug":"不务正业/Xcode","permalink":"http://yoursite.com/categories/不务正业/Xcode/"}]},{"title":"","date":"2020-08-15T09:01:58.001Z","path":"不务正业/Xcode/使用脚本添加Xcode文件/","text":"主要是 XcodeProj 这个工具的应用 Xcode 中 Group 和 FileRef 的区别GroupGroup 这个概念和我们平时经常说的 folder 文件夹有很大的差别, 文件夹在我们的日常使用时是一直所接触到的, 而对于 Group, 如果你不使用 Xcode 来编程(不是很清楚别的 IDE 是否有这个功能)的话, 这个概念距离你太远了. Group 其实是 Xcode 中用来组织文件的一种方式, 它对文件系统没有任何影响, 无论你创建或者删除一个 Group, 都不会导致 folder 的增加或者移除. 当然如果在你删除时选择 Move to Trash 就是另外一说了. 在 Group 中的文件的关系, 不会与 folder 中的有什么冲突, 它只是 Xcode 为你提供的一种分离关注的方式而已. 但是, 我一般会在开发过程中将不同的模块分到不同的 Group 和 folder 中便于整理. Group 之间的关系, 也是在 project.pbxproj 中定义的, 这个文件中包含了 Xcode 工程中所有 File 和 Group 的关系, 如果你大致浏览过这个文件的话, 你就会对我所说的有所了解. Group 在我们的工程中就是黄色的文件夹, 而 Folder 是蓝色的文件夹 一般在 Xcode 工程中, 我们比较少用 Folder Folder 会被打入到 app 的 bundle 中，比如 H5 的离线包文件夹就可以使用 FileRefFileRef 其实就是 File Reference 的缩写, 当你从 Xcode 中删除一个文件的时候, 它会弹出提示框. 而其中的 Remove Reference 选项并不会将这个文件移除到垃圾桶, 而只是会将这个文件的引用从 Xcode 的工程文件中删除. 如果你曾经看过 Build Phases 中的内容, 你会发现 如果删除的是 .h 文件, 它会从 Build Phases 中的 Headers 部分删除如果删除的是 .m 文件, 它会从 Build Phases 中的 Compile Source 部分删除但是文件还是会在原来的地方, 因为 Xcode 中所加入到工程的只是文件的一个引用 — File Ref. 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667require 'xcodeproj'project_path = './VideoNativeiPhone.xcodeproj'project = Xcodeproj::Project.open(project_path)# 测试的目录结构=begin./├── *.xcodeproj├── This └── is └── Test ├── Test.h └── Test.m=end# 递归从 Build Phases 删除引用def removeBuildPhaseFilesRecursively(aTarget, aGroup) aGroup.files.each do |file| if file.real_path.to_s.end_with?(\".m\", \".mm\", \".cpp\") then aTarget.source_build_phase.remove_file_reference(file) elsif file.real_path.to_s.end_with?(\".plist\") then aTarget.resources_build_phase.remove_file_reference(file) end end aGroup.groups.each do |group| removeBuildPhaseFilesRecursively(aTarget, group) endend# 枚举所有 targetproject.targets.each do |target| puts target.nameend# 获取第一个 Target，一般与工程名字同名target = project.targets.first# 根据路径名寻找 group。如果 should_create = true，则如果当前的 group 不存在, 它还会递归地创建group = project.main_group.find_subpath(File.join('This', 'is', 'Test'), true)# 建议设置为 SOURCE_ROOT，为了加入到 Build Phases 的时候, 从工程文件的根目录下开始寻找你所添加的文件# &lt;absolute&gt; for absolute paths# &lt;group&gt; for paths relative to the group# SOURCE_ROOT for paths relative to the project# DEVELOPER_DIR for paths relative to the developer directory.# BUILT_PRODUCTS_DIR for paths relative to the build products directory.# SDKROOT for paths relative to the SDK directory.group.set_source_tree('SOURCE_ROOT')# 如果多次添加会导致重复，因此需要将引用和 build phases 的值删除if !group.empty? then removeBuildPhaseFilesRecursively(target, group) group.clear()end# 为文件创建一个 FileRef 添加到 group 中file_ref_h = group.new_reference(\"./This/is/Test/Test.h\")file_ref_m = group.new_reference(\"./This/is/Test/Test.m\")# .h文件只需引用一下，.m 引用后还需加入 Build Phasestarget.add_file_references([file_ref_m])# 保存project.save 参考文章 使用代码为 Xcode 工程添加文件（入门篇） 懒人福利：用脚本来修改Xcode工程（实战篇） XcodeProj 源码","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"Xcode","slug":"不务正业/Xcode","permalink":"http://yoursite.com/categories/不务正业/Xcode/"}]},{"title":"Cocoapods","date":"2020-08-15T09:01:57.997Z","path":"不务正业/Xcode/Cocoapods/","text":"VideoNative 项目与 Cocoapods三个仓库 VideoNative/VideoNative 日常开发用的仓库（开发仓库） VideoNative/VideoNativeFramework 稳定版本的仓库，存放框架文件，用于发布（发布仓库） VideoNative/VideoNativeSpecs 远程的私人 Cocoapods 源，存放 VideoNative.podspec（说明书仓库） 发布流程 用开发仓库的最新代码打包一个 Framework，拷贝到 VideoNativeFramework 仓库（本质：发布仓库在本地更新框架） 编辑 VideoNativeFramework 下的 VideoNative.podsepc 文件，更新版本号（或者依赖文件，如果需要的话）（本质：发布仓库在本地更新说明书） 执行 pod lib lint 进行本地检查，如果没问题就 Push 到远程（发布仓库在远程更新框架和说明书） 再执行 pod spec lint 进行远程检查（校验发布仓库的框架和说明书） 最后执行以下命令，将 VideoNativeFramework 的 VideoNative.podspec 推送到私人 Cocoapods 源（提交说明书到说明书仓库） 1pod repo push oa-videonative-vnspec VideoNative.podspec --verbose --allow-warnings 执行 pod search VideoNative 检查是否发布新版本成功（校验说明书仓库） 其他 spec 的全称是 specification，意为“说明书；技术规范” Cocoapods/Specs 的意思是这个是 Cocoapods 公有仓库的说明书合集 podspec 就是每个 pod 组件的说明书文件 pod lib lint 和 pod spec lint 区别 pod lib lint 只对本地的 podspec 进行检查，没有联网操作 pod spec lint 对远程仓库（Spec Repo）的 podspec 进行检查 podfile.lock 是什么可以参考这里 CocoaPods的原理与技巧（二） 优秀文章 我所理解的 CocoaPods 一行命令发布 Pod 框架（生成 podspec 的工具不错）","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"Xcode","slug":"不务正业/Xcode","permalink":"http://yoursite.com/categories/不务正业/Xcode/"}]},{"title":"","date":"2020-08-15T09:01:57.987Z","path":"不务正业/VideoNative/VideoNative_加载VN页面_iOS篇/","text":"[toc] 为了适应多种多样的业务需求，VideoNative 提供了不同维度的 VN 页面加载方式，主要包括三大类：单纯的单页面模式、App 模式和 App 的单页面模式 单纯的单页面模式1. 简介这是单纯的单页面模式，是最灵活的 VN 页面加载方式，业务从 VN 框架获取到 QVNPage 对象之后，调用 getView 方法可以获取到一个 UIView。这个模式下，VN 框架扮演的是一个 View 的提供者，至于 View 的大小、添加、删除等都交给业务方灵活处理 该模式优点是非常灵活，对工程代码的侵入性小，但是无法使用以下接口 vn.navigate vn.app vn.window 涉及的关键类： QVNPage 2. 接口1234// QVNVideoNative.h- (void)loadSinglePage:(NSString *)rootUrl pageUrl:(NSString *)pageUrl callback:(IVNLoadPageCallback)callback; 我们可以通过 QVNVideoNative 单例加载单页面。不同于通过 VNApp 加载页面，本方法不需要 AppId，而是直接通过路径来加载页面 rootUrl 是存放该页面源码的根目录，图片资源、跳转链接等路径会以此路径做转换 pageUrl: 页面相对于 RootUrl 的路径，注意不是以 vn:// 开头 callback: 加载单页面成功的回调，其定义如下 12345typedef void (^IVNLoadPageCallback)(QVNPage *page, NSString *appId, NSString *rootUrl, NSString *pageUrl, QVNErrorCode errorCode); 其中回调参数最重要的是 QVNPage，调用者需要强持有 page 对象，否则会被释放 对于单页面，似乎提供一个绝对路径能够读取到对应的 .page 即可，其实不然，rootUrl 是必须的，因为 VN 源码中的图片路径和跳转链接等等都是相对路径，外部需要提供一个绝对的根目录，以计算出图片和跳转等的绝对路径；而 pageUrl 是相对 rootUrl 的路径，两者结合可以计算出 .page 的绝对路径 3. 使用范例MyApp 的 VN 代码存放在 Bundle 中，以下图为例，vnapp 是存放着 VN 代码的目录 1234567MyApp.app└── vnapp ├── image │ └── image1.png └── index ├── index.page └── test.page 下面展示如何加载 index.page 这个单页面，并添加到视图中 123456NSString *rootUrl = [[[NSBundle mainBundle] bundlePath] stringByAppendingPathComponent:@\"vnapp\"];[[QVNVideoNative sharedInstance] loadSinglePage:rootUrl pageUrl:@\"index/index\" callback:^(QVNPage *page, NSString *appId, NSString *rootUrl, NSString *pageUrl, QVNErrorCode errorCode) &#123; self.page = page; [self.containerView addSubview:[self.page getView]];&#125;]; 如果要获取 test.page，则 pageUrl 改为 @”index/test” 注意，在单纯的单页面模式中，没有 App/AppId 的概念 注意，这里的 pageUrl 是一个相对路径 App 模式1. 简介单纯的单页面模式只提供了一个 View，而 QVNApp 模式就相对更重些，它提供了 Controller 和其跳转的功能。QVNApp 模式下，VN 框架接管了整个 Controller，顶部的状态栏，以及 Controller 的跳转。 如果采用 vn.navigateTo 等框架提供的跳转方法，那么跳转到的将会是 QVNApp 下的另一个 Controller，当然开发者也可以采用 jsapi 的方式，从 VN 页面跳转到其他原生 Controller 该模式适用于有多个 VN 页面且它们比较集中的业务场景，可以类比微信的小程序，也适用于使用 VN 技术构建整个 App；但是对工程的侵入性较大，比如接管了跳转和顶部状态栏、使用的 Controller 是 VN 框架内部的，外部无法干预等 涉及的关键类： QVNApp 2. 接口 获取 QVNApp 的接口 12// QVNVideoNative.h- (QVNApp *)getVNApp:(NSString *)appId rootUrl:(NSString *)rootUrl; 我们可以通过 QVNVideoNative 单例获取到 QVNApp + appId: 每个 QVNApp 都有 AppId 作为唯一标识 + rootUrl 是存放该 App 源码的根路径，这个接口将会根据 AppId 从指定的目录获取 App 利用 QVNApp 打开指定页面的接口 12// QVNApp.h- (void)startApp:(UIViewController *)parentCtl pageUrl:(NSString *)pageUrl animation:(BOOL)animation; 获取到 QVNApp 后，调用该方法，可以 Push 一个 VN 页面 + parentCtl: App 内使用 vn.navigateTo 等进行跳转时，需要外部传入一个跳转的 Controller 作为起点，同时加载的 VN 页面也会在该 Controller 上 Push 进来 + pageUrl: 页面 URL，必须是 &quot;vn://&quot; 开头的绝对路径，注意与单纯的单页面模式的区别 + animation: 是否需要 Push 动画，默认需要 3. 使用范例App 的 VN 代码存放在 Bundle 中，以下图为例，AppId 为 54，info.json 存放有 App 相关的信息，比如AppId、各个页面的配置信息（横竖屏模式、状态栏样式等）等等 123456MyApp.app└── 54 ├── index │ ├── index.page │ └── test.page └── info.json 1234567NSString *appId = @\"54\";NSString *pageUrl = @\"vn://index/index\"NSString *rootUrl = [[[NSBundle mainBundle] bundlePath] stringByAppendingPathComponent:appId];// 获取 AppQVNApp *app = [[QVNVideoNative sharedInstance] getVNApp:appId rootUrl:rootUrl];// 启动 App 中的某个页面[app startApp:self pageUrl:pageUrl animation:YES]; 如果要获取 test.page，则 pageUrl 改为 @”vn://index/test” App 的单页面模式1. 简介该模式相比单纯的单页面模式，多了 App 的概念，因此具有 vn.app、vn.navigate、vn.window 的功能；该页面是 QVNApp 模式的一个扩展功能，比如某个业务需要使用 QVNApp，但是它的跳转入口可能是来自一个 Native 页面上的一个 UIView，这个 UIView 业务需要它也是 VN 开发，那么此时这个 UIView 就可以使用这种模式获取 总的来说，这种模式的使用场景较小 涉及的关键类： QVNApp、QVNPage 2. 接口12345// QVNApp.h- (void)acquirePage:(UIViewController *)parentCtl pageUrl:(NSString *)pageUrl pageInfoData:(IVNPageInfoData *)pageInfoData callback:(IVNAcquirePageCallback)callback; 获取到 QVNApp 之后，我们可以通过该方法加载一个单页面 pageUrl: 页面 URL，必须是 “vn://“ 开头的绝对路径，注意与单纯的单页面模式的区别 parentCtl: App 内使用 vn.navigateTo 等进行跳转时，需要外部传入一个跳转的 Controller 作为起点，同时加载的 VN 页面也会在该 Controller 上 Push 进来 pageInfoData: 外部已经解析好的页面数据，会优先使用页面数据，如果为空再从根据页面 URL 读取 callback: 加载单页面成功的回调 如果业务不需要与 QVNApp 打交道，QVNVideoNative 也提供了一个便捷方法，屏蔽获取 QVNApp 的细节 123456// QVNVideoNative.h- (void)loadAppPage:(NSString *)appId rootUrl:(NSString *)rootUrl pageUrl:(NSString *)pageUrl parentCtl:(UIViewController *)parentCtl callback:(IVNLoadPageCallback)callback; 3. 使用范例123456789101112NSString *appId = @\"54\";NSString *pageUrl = @\"vn://index/index\"NSString *rootUrl = [[[NSBundle mainBundle] bundlePath] stringByAppendingPathComponent:appId];[[QVNVideoNative sharedInstance] loadAppPage:appId rootUrl:rootUrl pageUrl:pageUrl parentCtl:self callback:^(QVNPage *page, NSString *appId, NSString *rootUrl, NSString *pageUrl, QVNErrorCode errorCode) &#123; self.page = page; [self.containerView addSubview:[self.page getView]]; &#125;]; 横向比较 模式\\类别 VN 框架的角色 特点 主要缺点 相关类 使用频率 单纯的单页面 渲染并生成 UIView 使用灵活 无法使用 vn.app、vn.navigate、vn.window QVNPage 较多 App Push VN 的 Controller 业务集中 侵入性较强 QVNApp 较多 App的单页面 以上均可 App 模式的扩展功能 混合后页面关系较复杂 QVNApp、QVNPage 相对较少","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"VideoNative","slug":"不务正业/VideoNative","permalink":"http://yoursite.com/categories/不务正业/VideoNative/"}]},{"title":"CSS 解析原理","date":"2020-08-15T09:01:57.984Z","path":"不务正业/VideoNative/CSS 解析原理/","text":"CSS 属性的分类VideoNative 的 CSS 属性可以从以下几个来源获得： VNML 的标签（Node）中写的内联样式 123&lt;text style=\"color: red\"&gt;This is a text&lt;/text&gt; CSS 文件中的样式，即经过选择器匹配后的 CSS 属性 1234567.myTitle&#123; height:auto; width:auto; font-size:26rpx; color:#848494;&#125; 继承属性 默认属性 复合属性 CSS 渲染流程VideoNative 一套完整的脚本代码（VNML+CSS+JS+JSON），渲染出来的是一个 QVNPage 整个 CSS 的渲染流程如下： Page 打开的时候，将 CSS 文件中的属性读取并解析其值，存放到 QVNContext 的 QVNRichCss 中（注意此时只是属性集，至于会应用到哪些 Node 还不确定，需要根据选择器来匹配；同时为了效率，这个步骤只做一次） 读取 Node 中的内联样式（VNML 中写的），创建一个 ProperyMap Widget 节点 根据这个 ProperyMap解析 ID 和类名，将 PropertyMap 的值转为其属性集，以此得到内联属性 处理父亲的属性集，以此得到继承属性 根据 ID/类名/类型等选择器对 QVNContext 的 QVNRichCss 的样式进行匹配，以此得到从 CSS 文件中来的属性 在将属性应用到 View 节点之前，这里会执行一步整理复合属性 每个 Widget 都对应一个 AttributeSetter，AttributeSetter 会声明其感兴趣的属性。AttributeSetter 拿到属性集之后，会取出其感兴趣的属性，读取其值设置给 View 复合属性首先陈述一个事实，在将 Widget 节点的属性集应用到 View 节点的时候，各个属性是一个接一个应用的（非同时），同时它们应用的顺序是不确定的 如果不同的属性之间有依赖，比如 View 节点拿到 A 属性的时候要根据 B 属性去设置 View，那么此时 B 属性如果还没设置过来，那么就会有问题 此时我们引入一个复合属性的概念，将有依赖的属性封装为一个复合属性，复合属性将做为一个整体设置给 View，以此解决应用顺序不确定的问题 复合属性的子属性的值是来自于原有的独立属性，原有的独立属性的值已经是经过继承、匹配选择器等操作得到的最终值 复合属性对开发者是透明的 别名属性解析过程还涉及一个别名属性的概念，别名属性对开发者也是透明的 以 margin 为例，在 CSS 中，开发者可以写 margin:1px; 或 margin:1px 2px 或 margin:1px 2px 3px 4px，也可以单独写 margin-top:1px 而 VideoNative 最终得到的属性集里面，并没有一个叫做 margin 的属性，而是 4 个单独的属性：marigin-top, marigin-left, marigin-bottom, marigin-right，margin 属性就是它们的别名属性 别名属性的解析以 margin-top 属性的解析过程为例，标准的 CSS 属性解析过程是这样的，将传入的 value 通过 parseFunc 解析之后，放到属性集中。其中 parseFunc 负责将 string 转化为 QVNCSSValue，attrPairs 是 Widget 的属性集 12345void QVNRichCssAttrType::parse(const std::string &amp;value, IQVNRichCssAttrs &amp;attrPairs) const&#123; QVNCssValue* result = mParseFunc(value); attrPairs.putAttribute(*this, result);&#125; 而对 margin 的属性进行解析的时候，先调用别名 CSS 类型 QVNRichCssAliasAttrType 的 parse 方法（QVNRichCssAliasAttrType 是 QVNRichCssAttrType 的子类，所以该方法被重写） 1234void QVNRichCssAliasAttrType::parse(const std::string &amp;value, IQVNRichCssAttrs &amp;attrPairs) const&#123; mAliasParseFunc(value, attrPairs, mParseFunc);&#125; 此时调用到了 VN_RICH_CSS_MARGIN_ALIAS_PARSER 1234567891011static QVNRichCssAliasAttrType::AliasParseFunc VN_RICH_CSS_MARGIN_ALIAS_PARSER = [](const std::string &amp;token, IQVNRichCssAttrs &amp;attrs, QVNRichCssAttrType::ParseFunc parseFunc) -&gt; void&#123; std::vector&lt;std::string&gt; container; splitAliasTypes(token, container); if (container.size() &gt;= 4) &#123; attrs.putAttribute(VN_RICH_CSS_ATTRIBUTE_TYPE_MARGIN_TOP, parseFunc(container[0])); attrs.putAttribute(VN_RICH_CSS_ATTRIBUTE_TYPE_MARGIN_RIGHT, parseFunc(container[1])); attrs.putAttribute(VN_RICH_CSS_ATTRIBUTE_TYPE_MARGIN_BOTTOM, parseFunc(container[2])); attrs.putAttribute(VN_RICH_CSS_ATTRIBUTE_TYPE_MARGIN_LEFT, parseFunc(container[3])); &#125;&#125;; 别名解析函数将值通过 parseFunc 解析之后，设置给 margin-top 等属性","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"VideoNative","slug":"不务正业/VideoNative","permalink":"http://yoursite.com/categories/不务正业/VideoNative/"}]},{"title":"","date":"2020-08-15T09:01:57.973Z","path":"不务正业/Python/文件操作/","text":"python中对文件、文件夹(文件操作函数)的操作需要涉及到os模块和shutil模块。 例子读取文件全部内容12with open('/path/to/file', 'r') as f: print(f.read()) 按行读取文件内容12for line in f.readlines(): print(line.strip()) # 把末尾的'\\n'删掉 按行写入文件123with open('/path/to/file', 'w') as f: f.write('Hello, world!\\n') f.write('Hello, world!2') 清空指定文件夹的所有文件123456import osimport shutilif os.path.exists(root_director): shutil.rmtree(root_director) os.mkdir(root_director) APIPython脚本工作的目录路径(区别于脚本所在的目录)os.getcwd() 返回指定目录下的所有文件和目录名os.listdir() 检验给出的路径是否是一个文件os.path.isfile() 检验给出的路径是否是一个目录os.path.isdir() 判断是否是绝对路径os.path.isabs() 检验给出的路径是否存在os.path.exists() 返回一个路径的目录名和文件名os.path.split() 1os.path.dirname('/a/b/c') # ('a/b', 'c') 分离扩展名os.path.splitext() 1os.path.dirname('/a/b/c.txt') # ('a/b/c', '.txt') 获取路径名os.path.dirname() 1os.path.dirname('/a/b/c') # a/b 获取文件名os.path.basename() 1os.path.dirname('/a/b/c.txt') # c.txt 运行shell命令os.system() 读取和设置环境变量os.getenv() 与os.putenv() 给出当前平台使用的行终止符os.linesep() Windows使用’\\r\\n’，Linux使用’\\n’而Mac使用’\\r’ 指示你正在使用的平台os.name()对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’ 重命名os.rename(old,new) 创建多级目录os.makedirs(“a/b/c”) 创建单个目录os.mkdir(“test”) 获取文件属性os.stat(file) 修改文件权限与时间戳os.chmod(file) 终止当前进程os.exit() 获取文件大小os.path.getsize(filename) 复制文件shutil.copyfile(“oldfile”,”newfile”) oldfile和newfile都只能是文件 shutil.copy(“oldfile”,”newfile”) oldfile只能是文件夹，newfile可以是文件，也可以是目标目录 复制文件夹shutil.copytree(“olddir”,”newdir”) olddir和newdir都只能是目录，且newdir必须不存在 重命名文件(目录)os.rename(“oldname”,”newname”) 文件或目录都是使用这条命令 移动文件(目录)shutil.move(“oldpos”,”newpos”) 删除文件os.remove(“file”) 删除目录os.rmdir(“dir”) 只能删除空目录 shutil.rmtree(“dir”) 空目录、有内容的目录都可以删 删除多个目录os.removedirs() 转换目录os.chdir(“path”) 换路径 文件操作：os.mknod(“test.txt”) 创建空文件fp = open(“test.txt”,w) 直接打开一个文件，如果文件不存在则创建文件 关于 open 模式： 1234567891011w 以写方式打开，a 以追加模式打开 (从 EOF 开始, 必要时创建新文件)r+ 以读写模式打开w+ 以读写模式打开 (参见 w )a+ 以读写模式打开 (参见 a )rb 以二进制读模式打开wb 以二进制写模式打开 (参见 w )ab 以二进制追加模式打开 (参见 a )rb+ 以二进制读写模式打开 (参见 r+ )wb+ 以二进制读写模式打开 (参见 w+ )ab+ 以二进制读写模式打开 (参见 a+ )","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"Python","slug":"不务正业/Python","permalink":"http://yoursite.com/categories/不务正业/Python/"}]},{"title":"","date":"2020-08-15T09:01:57.966Z","path":"不务正业/Python/Python小知识/","text":"我用过的python库 pprint：美观打印数据结构 requests：可以方便地发送http请求，以及方便地处理响应结果，完胜自带的 urllib Beautiful Soup：抓取网页数据 字符串拼接1234567891011121314151617181920212223242526272829tpl = \"i am &#123;&#125;, age &#123;&#125;, &#123;&#125;\".format(\"seven\", 18, 'alex') tpl = \"i am &#123;&#125;, age &#123;&#125;, &#123;&#125;\".format(*[\"seven\", 18, 'alex']) tpl = \"i am &#123;0&#125;, age &#123;1&#125;, really &#123;0&#125;\".format(\"seven\", 18) tpl = \"i am &#123;0&#125;, age &#123;1&#125;, really &#123;0&#125;\".format(*[\"seven\", 18]) tpl = \"i am &#123;name&#125;, age &#123;age&#125;, really &#123;name&#125;\".format(name=\"seven\", age=18) tpl = \"i am &#123;name&#125;, age &#123;age&#125;, really &#123;name&#125;\".format(**&#123;\"name\": \"seven\", \"age\": 18&#125;) tpl = \"i am &#123;0[0]&#125;, age &#123;0[1]&#125;, really &#123;0[2]&#125;\".format([1, 2, 3], [11, 22, 33]) tpl = \"i am &#123;:s&#125;, age &#123;:d&#125;, money &#123;:f&#125;\".format(\"seven\", 18, 88888.1) tpl = \"i am &#123;:s&#125;, age &#123;:d&#125;\".format(*[\"seven\", 18]) tpl = \"i am &#123;name:s&#125;, age &#123;age:d&#125;\".format(name=\"seven\", age=18) tpl = \"i am &#123;name:s&#125;, age &#123;age:d&#125;\".format(**&#123;\"name\": \"seven\", \"age\": 18&#125;) tpl = \"numbers: &#123;:b&#125;,&#123;:o&#125;,&#123;:d&#125;,&#123;:x&#125;,&#123;:X&#125;, &#123;:%&#125;\".format(15, 15, 15, 15, 15, 15.87623, 2) tpl = \"numbers: &#123;:b&#125;,&#123;:o&#125;,&#123;:d&#125;,&#123;:x&#125;,&#123;:X&#125;, &#123;:%&#125;\".format(15, 15, 15, 15, 15, 15.87623, 2) tpl = \"numbers: &#123;0:b&#125;,&#123;0:o&#125;,&#123;0:d&#125;,&#123;0:x&#125;,&#123;0:X&#125;, &#123;0:%&#125;\".format(15) tpl = \"numbers: &#123;num:b&#125;,&#123;num:o&#125;,&#123;num:d&#125;,&#123;num:x&#125;,&#123;num:X&#125;, &#123;num:%&#125;\".format(num=15) 全局变量1234OutputFile = ''def generateMarkdown(jsonData): OutputFile = '123' 如果在函数中需要对全局变量进行赋值，需要添加 global 关键字 12345OutputFile = ''def generateMarkdown(jsonData): global OutputFile OutputFile = '123' list 合并123l1 = [1,2,3]l2 = [3,4,5]l3 = l1+l2 将 json 写入文件123import jsonwith open('data.json', 'w') as f: json.dump(myJsonData, f, ensure_ascii=False)","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"Python","slug":"不务正业/Python","permalink":"http://yoursite.com/categories/不务正业/Python/"}]},{"title":"","date":"2020-08-15T09:01:57.964Z","path":"不务正业/Python/Python参数/","text":"方法一、arvg参数获取12345import sys print(sys.argv[0]) ## 脚本名 print(sys.argv[1]) ## 第一个参数，后面以此类推print(len(sys.argv)) ## 参数个数 方法二、getopt模块获取getopt 模块是专门用来处理命令行参数的，里面的提供了2个函数和一个类，我们主要使用getopt函数，原型为: 1def getopt(args, shortopts, longopts = []): 调用语句为: 1opts, args = getopt.getopt(sys.argv[1:], \"ho:\", [\"help\"， \"output=\"]) 参数解释有两种格式的参数，一种为短参数，如&quot;-h&quot;；另外一种是长参数，如&quot;--version&quot; 参数后面又要区分，是否带了入参值，如查看help命令，只需要”-h”，就是不需要带入参值； 如果是输入ip，如”-i 127.0.0.1”，这个就是带了入参值 短参数中，需要输入的如入参名后面加了冒号&quot;:&quot;，表明需要带参数，不加冒号则表明不要， 如上面的例子，短参数为&quot;ho:&quot;，表明有两个短参数，&quot;-h&quot;，&quot;-o&quot;，其中&quot;-o&quot;需要后面接参数 长参数中，后面如果接了等号&quot;=&quot;，表明需要带参数，不加则表明不要 如上面的例子，长参数为[&quot;help&quot;， &quot;output=&quot;]，表明有两个长参数，一个&quot;--help&quot;，不需要后面带参数；一个&quot;--output&quot;，需要后面带参数 返回值调用getopt 函数函数返回两个列表：opts 和args opts 为分析出的格式信息 args 为不属于格式信息的剩余的命令行参数(即那些不含”-/–”的参数) opts 是一个两元组的列表每个元素为：(选项串，附加参数）如果没有附加参数则为空串’’ 比如 1'-h -o file --help --output=out file1 file2' opts 应该是： 1[('-h', '')， ('-o', 'file')， ('--help', '')， ('--output', 'out')] args 则为： 1['file1', 'file2'] 例子123456789101112131415161718192021222324252627282930#!/usr/bin/python# -*- coding: UTF-8 -*-# http://www.runoob.com/python3/python3-command-line-arguments.htmlimport sys, getoptdef main(argv): inputfile = '' outputfile = '' try: opts, args = getopt.getopt(argv,\"hi:o:\",[\"ifile=\",\"ofile=\"]) except getopt.GetoptError: print('command-line-arguments.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;') sys.exit(2) for opt, arg in opts: if opt == '-h': print('Usage: command-line-arguments.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;') sys.exit() elif opt in (\"-i\", \"--ifile\"): inputfile = arg elif opt in (\"-o\", \"--ofile\"): outputfile = arg print('输入的文件为：', inputfile) print('输出的文件为：', outputfile)if __name__ == \"__main__\": main(sys.argv[1:])","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"Python","slug":"不务正业/Python","permalink":"http://yoursite.com/categories/不务正业/Python/"}]},{"title":"","date":"2020-08-15T09:01:57.955Z","path":"不务正业/iOS 未分类/弱引用集合对象/","text":"NSPointerArray特性介绍NSPointerArray 是 NSArray 的通用版本，和 NSArray/NSMutableArray 不同的是，NSPointerArray 具有下面这些特性 与 NSArray/NSMutableArray 相对应，NSArray/NSMutableArray 强引用集合对象 NSPointerArray 可以弱引用集合对象，一旦对象没人持有了，NSPointerArray 中对应的项会被变成 NULL NSPointerArray 是可变的，没有不可变的版本 NSPointerArray 可以存储 NULL，NULL 参与 count 计算 NSPointerArray 的 count 可以被设置，如果直接设置 count，多余的位置会使用 NULL 占位 NSPointerArray 存储的是指针类型 void * 而不是对象，所以需要 __bridge 进行转换 使用 addPointer 和 pointerAtIndex 来存取指针 初始化参数12- (instancetype)initWithOptions:(NSPointerFunctionsOptions)options;- (instancetype)initWithPointerFunctions:(NSPointerFunctions *)functions; 首先来看一下 NSPointerFunctionsOptions，它是个 option，主要分为三大类： 内存管理 NSPointerFunctionsStrongMemory：默认值，强引用集合对象 NSPointerFunctionsZeroingWeakMemory：废弃 NSPointerFunctionsMallocMemory 与 NSPointerFunctionsMachVirtualMemory： 用于 Mach 的虚拟内存管理 NSPointerFunctionsWeakMemory：弱引用集合对象 特性，用于标明对象判等方式 NSPointerFunctionsObjectPersonality：hash、isEqual、对象描述 NSPointerFunctionsOpaquePersonality：pointer 的 hash 、直接判等 NSPointerFunctionsObjectPointerPersonality：pointer 的 hash、直接判等、对象描述 NSPointerFunctionsCStringPersonality：string 的 hash、strcmp 函数、UTF-8 编码方式的描述 NSPointerFunctionsStructPersonality：内存 hash、memcmp 函数 NSPointerFunctionsIntegerPersonality：值的 hash 内存标识 NSPointerFunctionsCopyIn：根据第二类的选择，来具体处理。如果是 NSPointerFunctionsObjectPersonality，则根据 NSCopying 来拷贝 这里只关注弱引用，对象判别方式和 NSPointerFunctions 的初始化不展开 提供 compact 方法剔除 NULL 元素NSPointerArray 可以存储 NULL，作为补充，它也提供了 compact 方法，用于剔除数组中为 NULL 的成员。但是 compact 函数有个已经报备的 bug，每次 compact 之前需要添加一个 NULL，否则会 compact 失败 弱引用测试代码1234567891011121314151617NSPointerArray *pointerArray = [[NSPointerArray alloc] initWithOptions:NSPointerFunctionsWeakMemory];@autoreleasepool&#123; NSObject *obj = [NSObject new]; [pointerArray addPointer:(__bridge void *)obj]; NSLog(@\"NSPointerArray is: %p count: %@\", [pointerArray pointerAtIndex:0], @(pointerArray.count)); // 输出 NSPointerArray is: 0x60000000e800 count: 1&#125;NSLog(@\"After Release NSPointerArray is: %p count: %@\", [pointerArray pointerAtIndex:0], @(pointerArray.count));// 输出 After Release NSPointerArray is: 0x0 count: 1 // 每次 compact 之前需要添加 NULL，规避系统 Bug[pointerArray addPointer:NULL]; [pointerArray compact]; NSLog(@\"After Compact NSPointerArray count: %@\", @(pointerArray.count));// 输出 After Compact NSPointerArray count: 0 与 NSArray/NSMutableArray 的区别 NSArray/NSMutableArray 配合 NSValue 可以实现数组的弱引用 1234567NSMutableArray *array = @[].mutableCopy;// 添加NSObject *obj = [NSObject new];[array addObject:[NSValue valueWithNonretainedObject:obj]];// 读取NSValue *value = array[0];NSObject *obj2 = [value nonretainedObjectValue]; 注意：使用 NSValue 的方式，确实可以实现对对象的弱引用（即被添加到集合中时，对象的引用计数不会+1），但是当对象被释放的时候，数组中对应的对象会变成野指针，因此需要手动删除 NSArray 中对应对象的值，否则会在执行 [value nonretainedObjectValue] 时崩溃；而使用 NSPointerArray 不会有这个问题，对象的释放会使得集合中的对象变为 NULL NSHashTable特性介绍NSHashTable 是 NSSet 的通用版本，和 NSSet / NSMutableSet 不同的是，NSHashTable 具有下面这些特性 与 NSSet/NSMutableSet 相对应，NSSet/NSMutableSet 强引用集合对象 NSHashTable 可以弱引用集合对象，一旦对象没人持有了，NSHashTable 中的值也会被移除 NSHashTable 是可变的，没有不可变的版本 除了存储对象，NSHashTable 也可以存储任意指针，比如 void * 初始化参数可以在初始化 NSHashTable 时指定 NSHashTableOptions 来确定其内存引用 1+ (NSHashTable&lt;ObjectType&gt; *)hashTableWithOptions:(NSPointerFunctionsOptions)options; NSHashTableOptions 的取值如下： NSHashTableStrongMemory: 默认值，强引用集合对象，与 NSSet 一样 NSHashTableWeakMemory: 弱引用集合对象 NSHashTableZeroingWeakMemory: 废弃，请使用 NSHashTableWeakMemory NSHashTableCopyIn: 在将对象添加到集合之前，会拷贝对象 NSHashTableObjectPointerPersonality: 使用 shifted pointer 来做 hash 检测及确定两个对象是否相等 弱引用测试代码12345678910NSHashTable *hashTable = [NSHashTable hashTableWithOptions:NSPointerFunctionsWeakMemory];@autoreleasepool &#123; NSObject *obj = [NSObject new]; [hashTable addObject:obj]; NSLog(@\"hashTable is: %@\", hashTable); // hashTable is: NSHashTable &#123;[3] &lt;NSObject: 0x6000035e3f60&gt;&#125;&#125; NSLog(@\"hashTable is: %@\", hashTable);// hashTable is: NSHashTable &#123;&#125; NSMapTable特性介绍NSMapTable 是 NSDictionary 的通用版本，和 NSDictionary/NSMutableDictionary 不同的是，NSMapTable 具有下面这些特性 与 NSDictionary/NSMutableDictionary 相对应，NSDictionary/NSMutableDictionary 对 Key 拷贝，对 Value 强引用 key 和 value 的内存管理方式可以分开，如：key 是强引用，value 是弱引用 NSMapTable 可以弱引用 Key 和 Value，一旦 Key 或 Value 中的某一个没人持有了，NSMapTable 中对应的项也会被移除 NSMapTable 是可变的，没有不可变的版本 除了存储对象，NSMapTable 也可以存储任意指针，比如 void * 总结起来一共有 4 种可能： key 为 strong，value 为 strong key 为 strong，value 为 weak key 为 weak，value 为 strong key 为 weak，value 为 weak 当用 weak 修饰 key 或 value 时，有一方被释放，则该键值对移除。 初始化参数可以在初始化 NSMapTable 时指定 NSPointerFunctionsOptions 来分别确定对 Key 和 Value 的内存引用 1+ (NSMapTable&lt;KeyType, ObjectType&gt; *)mapTableWithKeyOptions:(NSPointerFunctionsOptions)keyOptions valueOptions:(NSPointerFunctionsOptions)valueOptions; NSMapTableStrongMemory: 默认值，强引用 Key/Value NSMapTableWeakMemory: 弱引用 Key/Value NSHashTableZeroingWeakMemory: 废弃，请使用 NSMapTableWeakMemory NSMapTableCopyIn: 在将对象添加到集合之前，会拷贝对象 NSMapTableObjectPointerPersonality: 使用 shifted pointer 来做 hash 检测及确定两个对象是否相等 弱引用测试代码123456789101112NSMapTable *mapTable = [NSMapTable weakToStrongObjectsMapTable];@autoreleasepool &#123; NSObject *key = [NSObject new]; NSObject *value = [NSObject new]; [mapTable setObject:value forKey:key]; NSLog(@\"mapTable is: %@\", mapTable); // mapTable is: NSMapTable &#123;&lt;NSObject: 0x6000008df890&gt; -&gt; &lt;NSObject: 0x6000008df870&gt;&#125;&#125; NSLog(@\"mapTable is: %@\", mapTable);// mapTable is: NSMapTable &#123;&#125;// key 是 weak 引用，所以析构之后 NSMapTable 就会移除对应的项 何时使用NSHashTable 和 NSMapTable 都比 NSSet 和 NSDictionary 都更加强大，但是大部分情况下，我们用 NSSet 和 NSDictionary 就已经足够，只有在对内存有特别要求的情况下，才使用 NSHashTable 和 NSMapTable 参考文章 NSHash​Table &amp; NSMap​Table Cocoa 集合类型：NSPointerArray，NSMapTable，NSHashTable","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"iOS 未分类","slug":"不务正业/iOS-未分类","permalink":"http://yoursite.com/categories/不务正业/iOS-未分类/"}]},{"title":"","date":"2020-08-15T09:01:57.952Z","path":"不务正业/iOS 未分类/iOS 状态栏/","text":"Info.plist 中设置 View controller-based status bar appearance 控制 App 状态栏显隐接受全局配置（NO）或者各控制器各自配置（YES） View controller-based status bar appearance = NO 时，使用 [[UIApplication sharedApplication] setStatusBarHidden:hidden] 来控制全局状态栏的显隐 View controller-based status bar appearance = YES 时，重写 ViewController 的 prefersStatusBarHidden 方法来决定当前 Controller 的状态栏显隐 设置 Status bar is initially hidden -&gt; YES 可以隐藏启动页展示过程的状态栏；默认不隐藏 ViewController 的相关方法 1234567891011121314// 样式- (UIStatusBarStyle)preferredStatusBarStyle&#123; return [self.visibleViewController preferredStatusBarStyle];&#125;// 显隐- (BOOL)prefersStatusBarHidden &#123; return [self.visibleViewController prefersStatusBarHidden];&#125;// 标记状态栏需要更新，同 setNeedsLayout[self setNeedsStatusBarAppearanceUpdate];","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"iOS 未分类","slug":"不务正业/iOS-未分类","permalink":"http://yoursite.com/categories/不务正业/iOS-未分类/"}]},{"title":"","date":"2020-08-15T09:01:57.949Z","path":"不务正业/iOS 未分类/iOS 沙盒目录结构/","text":"MyApp.app 说明 存放资源文件和可执行文件。整个目录只可读，不可更改。为了防止篡改里面的内容，应用在安装的时候会将该目录进行签名。在非越狱的情况下，该目录中的内容是无法更改的。在越狱设备上如果更改了目录内容，对应的签名就会被改变，这种情况下应用程序将无法启动。 iTunes同步 该文件不会被 iTunes 同步 路径获取 12[[NSBundle mainBundle] bundlePath]// Output is: /var/containers/Bundle/Application/556BDC9D-1881-48DC-BA34-9A5032621795/MyApp.app\" 注意这个 MyApp.app 不是在沙盒的主目录下 沙盒主目录路径 沙盒主目录的文件结构图如下 . ├── Documents ├── Library │ ├── Caches │ └── Preferences ├── SystemData └── tmp 路径获取 12NSHomeDirectory()// Output is: /var/mobile/Containers/Data/Application/E7CA106D-FFFC-47A8-9885-7F6880913E85 Documents 说明 开发者可以将应用程序的数据文件保存在这个目录下 iTunes 同步 该目录下的文件会被 iTunes 同步。 路径获取 12[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0]// Output is: /var/mobile/Containers/Data/Application/E7CA106D-FFFC-47A8-9885-7F6880913E85/Documents Library 说明 存放一些偏好设置 iTunes 同步 除这个 Library/Caches 之外，Library 下的其他文件会被 iTunes 同步 路径获取 12[NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES) lastObject]// Output is: /var/mobile/Containers/Data/Application/E7CA106D-FFFC-47A8-9885-7F6880913E85/Library Library/Caches 说明 存放缓存数据 iTunes 同步 该目录下的数据不会被 iTunes 同步 路径获取 12[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) objectAtIndex:0]// Output is: /var/mobile/Containers/Data/Application/E7CA106D-FFFC-47A8-9885-7F6880913E85/Library/Caches Library/Preferences 说明 存放偏好设置文件。比如 NSUserDefaults 就是将数据保存在该目录下的一个plist文件中 iTunes 同步 该目录下的数据会被 iTunes 同步 路径获取 12[NSUserDefaults standardUserDefaults]// Output is: /var/mobile/Containers/Data/Application/E7CA106D-FFFC-47A8-9885-7F6880913E85/Library/Preferences Temp 说明 临时文件，保存应用再次启动时就可以不需要的文件数据。并且开发者不需要这些文件的时候应该要主动将其删除掉，因为该目录下的文件随时可能被系统清理掉，比如当系统磁盘存储空间不足的时候，系统会自动清除这个目录下的文件。 iTunes 同步 该目录不会被 iTunes 同步 路径获取 12NSTemporaryDirectory()// Output is : /private/var/mobile/Containers/Data/Application/E7CA106D-FFFC-47A8-9885-7F6880913E85/tmp/","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"iOS 未分类","slug":"不务正业/iOS-未分类","permalink":"http://yoursite.com/categories/不务正业/iOS-未分类/"}]},{"title":"","date":"2020-08-15T09:01:57.944Z","path":"不务正业/iOS 未分类/iOS 图片加载的坑/","text":"iOS 中有两种常用的图片加载方式： imageNamed 有缓存：这种方法会首先在系统缓存中根据指定的名字寻找图片，如果找到了就返回。如果没有在缓存中找到图片，该方法会从指定的文件中加载图片数据，并将其缓存起来，然后再把结果返回 适合使用频率高的小图片 系统会自动添加 @2x/@3x 去寻找图片 imageWithContentsOfFile 只是简单的加载图片，并不会将图片缓存起来 适合使用频率少的大图片 关于 @2x/@3x 的坑假如现在有 `image@2x.png和image@3x.png` 2张图片 以下代码可以正确找到图片，这种方法是直接寻找 image@2x.png 12NSString *path = [[NSBundle mainBundle] pathForResource:@\"image@2x\" ofType:@\"png\"]; UIImage *image = [UIImage imageWithContentsOfFile:path]; 以下代码无法找到图片，这种方法是直接寻找 image.png 12NSString *path = [[NSBundle mainBundle] pathForResource:@\"image\" ofType:@\"png\"]; //输出 nilUIImage *image = [UIImage imageWithContentsOfFile:path]; 以下代码可以正确找到图片，这种方法系统会帮助处理 @2x/@3x 12NSString *path = [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:@\"image.png\"];UIImage *image = [UIImage imageWithContentsOfFile:path]; 假如是一个 3x 设备，3x 图片实际宽度为 300x300，2x 图片实际宽度为 200x200，1x 图片实际宽度为 100x100 12NSString *path = [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:@\"image.png\"];UIImage *image = [UIImage imageWithContentsOfFile:path]; 在这个 3x 设备上，读到的 image 为 1&lt;UIImage: 0x283a09e30&gt; size &#123;100, 100&#125; orientation 0 scale 3.000000 如果 3x 图片缺失，会自动寻找 2x 图片，读到的 image 为 1&lt;UIImage: 0x283a09e30&gt; size &#123;100, 100&#125; orientation 0 scale 2.000000 如果 3x 和 2x 图片缺失，会自动寻找 1x 图片，读到的 image 为 1&lt;UIImage: 0x283a09e30&gt; size &#123;100, 100&#125; orientation 0 scale 1.000000 image.png 和 image@1x.png 是等价的 Framework 的图片加载提供 Framework 提供给业务方时，需要提供 .bundle 和 .framework 主 App 将 .bundle 放入自己的 bundle 中 Framework 使用以下代码访问图片资源 12NSBundle *bundle = [NSBundle bundleWithPath:[[NSBundle mainBundle] pathForResource:@\"VideoNativeFramework\" ofType:@\"bundle\"]];UIImage *img = [UIImage imageWithContentsOfFile:[[bundle resourcePath] stringByAppendingPathComponent:@\"image.png\"]];","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"iOS 未分类","slug":"不务正业/iOS-未分类","permalink":"http://yoursite.com/categories/不务正业/iOS-未分类/"}]},{"title":"","date":"2020-08-15T09:01:57.935Z","path":"不务正业/BackEnd/Ubuntu/","text":"禁止 Apache 显示目录索引1sudo vim /etc/apache2/apache2.conf 123456&lt;Directory /var/www/&gt; #Options Indexes FollowSymLinks Options FollowSymLinks AllowOverride None Require all granted&lt;/Directory&gt; 将 Options Indexes FollowSymLinks 改成 Options FollowSymLinks 即可以禁止 Apache 显示该目录结构。解释：Indexes 的作用就是当该目录下没有指定 index.html 文件时，就显示目录结构，去掉 Indexes ，Apache 就不会显示该目录的列表了 在 vim 保存时获得 sudo 权限1:w ! sudo tee % 命令:w !{cmd}，让 vim 执行一个外部命令{cmd}，然后把当前缓冲区的内容从 stdin 传入。 tee 是一个把 stdin 保存到文件的小工具。 而 %，是vim当中一个只读寄存器的名字，总保存着当前编辑文件的文件路径。 所以执行这个命令，就相当于从vim外部修改了当前编辑的文件。 Ubuntu Apache2 的启动/重启/停止 启动 1/etc/init.d/apache2 start 重启 1/etc/init.d/apache2 restart 停止 1/etc/init.d/apache2 stop php 实现 RESTful api 修改 Apache 配置，/etc/apache2/apache2.conf，将以下配置从 AllowOverride None 改为 AllowOverride All 123456&lt;Directory /var/www/&gt; #Options Indexes FollowSymLinks Options FollowSymLinks AllowOverride All Require all granted&lt;/Directory&gt; 到网站的根目录下 /var/www/html，新增或修改 .htaccess 文件，如下 1234567# 开启 rewrite 功能Options +FollowSymlinksRewriteEngine on# 重写规则RewriteRule ^MiniPro/fmlist$ ./MiniPro/RestController.php?fm=all [nc,qsa]RewriteRule ^MiniPro/fmlist/([0-9]+)$ ./MiniPro/RestController.php?fm=single&amp;id=$1 [nc,qsa] 重写规则使用正则表达式来匹配 URL，进而路由到指定的页面，其中 nc 表示不区分大小写（No Case），qsa 表示可以在 URL 后面添加参数字符串（Query String Append） 更多详细可以参照 PHP RESTful 需要注意的是 SiteRestHandler.php 这个文件中的 $this -&gt;setHttpHeaders($requestContentType, $statusCode); 这句代码需要注释才能工作 如果要读取 POST 参数使用 $_POST 是读取不到的，可使用 1$postData = json_decode(file_get_contents(&apos;php://input&apos;), true); 来获取 POST 参数 我自己实现的例子：https://github.com/Norcy/SmallFrequence.git Ubuntu Apache2 配置 HTTPS 申请 SSL 证书：包括 sapache.crt apache.key server-chain.crt 拷贝证书到 /etc/apache2/cert 目录下 创建site-enabled 指向site-available的软链接 1sudo ln -s /etc/apache2/sites-available/default-ssl.conf /etc/apache2/sites-enabled/001-ssl.conf 修改/etc/apache2/sites-enabled/001-ssl.conf，关注 ServerName，SSLCertificateFile，SSLCertificateKeyFile，SSLCertificateChainFile 123456789101112131415&lt;VirtualHost *:443&gt; ServerName norcy.xyz ServerAdmin webmaster@localhost DocumentRoot /var/www/html SSLEngine On SSLOptions +StrictRequire SSLCertificateFile /etc/apache2/cert/apache.crt SSLCertificateKeyFile /etc/apache2/cert/apache.key SSLCertificateChainFile /etc/apache2/cert/server-chain.crt ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined&lt;/VirtualHost&gt; 强制 HTTPS 访问：在网站根目录下新建文件 .htaccess 文件，写入内容 1234RewriteEngine onRewriteBase / RewriteCond %&#123;SERVER_PORT&#125; !^443$RewriteRule ^.* https://%&#123;SERVER_NAME&#125;%&#123;REQUEST_URI&#125; [L,R] 重启 1234// 加载Apache的SSL模块$ sudo a2enmod ssl// 然后，重启Apache $ sudo /etc/init.d/apache2 restart // 这时浏览器应该就可访问了 基础知识 网页文件存放在 /var/www/html 以指定用户执行命令由于权限全部给了 www-data，所以使用 ubuntu 账户进行 git 操作的时候，需要添加 sudo 或者 sudo -u www-data git push 切换用户 12sudo -isu - www-data 正确的操作姿势是以 www-data 操作 .git 目录全部改为 www-data:www-data 文件上传与下载 下载 wx 文件夹 到本地 1scp -r [-P 端口号] ubuntu@111.230.246.127:/var/www/html/PublicAccount ~/Desktop/wx/ 上传 test.txt 到 www 目录 1scp [-r] [-P 端口号] /var/www/test.txt root@192.168.0.101:/var/www/ ubuntu 的终端文件名显示乱码或问号直接修改当前用户目录 下的 .bashrc 问件，在最后添加如下： 1234export LC_ALL=Cexport LANG=\"zh_CN.utf8\"export LC_ALL=\"zh_CN.utf8\"export LC_CTYPE=\"zh_CN.utf8\" 定时任务/etc/crontab 不需要重启 crontab 服务，也不用 crontab -e 来添加任务","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"BackEnd","slug":"不务正业/BackEnd","permalink":"http://yoursite.com/categories/不务正业/BackEnd/"}]},{"title":"","date":"2020-08-15T09:01:57.913Z","path":"iOS/未分类/离屏渲染/","text":"layer.cornerRadius 不会触发离屏渲染，该属性只是对边框和背景颜色起作用，适用于内部没有其他控件的 view。 CAShapeLayer+UIBezierPath 会触发离屏渲染。 最好的方式就是使用 Core Graphics 的方式绘制圆角图片。 当然，还是那句话，根据场景来使用，如果界面中圆角的地方不多，第一种方式是最简单快捷，效率最高的。如果用到的圆角很多，那还是使用 Core Graphics 的方式 场景 cornerRadius+clipsToBounds shadow group opacity mask UIBlurEffect AsyncDisplayKit(Texture) 作为主要渲染框架，对于文字和图片的异步渲染操作交由框架来处理。关于这方面可以看我之前的一些介绍 对于图片的圆角，使用 CoreGraphics 为图片裁剪圆角 对于视频的圆角，由于实时剪切非常消耗性能，我们会创建四个白色弧形的 layer 盖住四个角，从视觉上制造圆角的效果 对于 view 的圆形边框，如果没有 backgroundColor，可以放心使用 cornerRadius 来做 对于所有的阴影，使用 shadowPath 来规避离屏渲染 对于特殊形状的 view，使用 layer mask 并打开 shouldRasterize 来对渲染结果进行缓存对于模糊效果，不采用系统提供的 UIVisualEffect，而是另外实现模糊效果（CIGaussianBlur），并手动管理渲染结果 https://zhuanlan.zhihu.com/p/72653360http://lemon2well.top/2018/08/29/iOS%20%E5%BC%80%E5%8F%91/iOS%E4%B8%AD%E7%9A%84%E5%9C%86%E8%A7%92%E5%A4%84%E7%90%86%EF%BC%88%E7%BB%88%E7%BB%93%E7%AF%87%EF%BC%89/https://bestswifter.com/efficient-rounded-corner/","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"未分类","slug":"iOS/未分类","permalink":"http://yoursite.com/categories/iOS/未分类/"}]},{"title":"","date":"2020-08-15T09:01:57.910Z","path":"iOS/未分类/杂/","text":"NSNotification 接收通知时所在的线程取决于发送的线程还是注册的线程发送的线程。 如果是注册的线程，则 NSNotificationCenter 需要维护监听者和其注册时所在线程的表，实现较为复杂；其次注册时所在的线程有可能被销毁，等到接收通知时不一定存在 如果是子线程发送通知，如何在主线程接受通知1234567[[NSNotificationCenter defaultCenter] addObserverForName:@\"MyNoti\" object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123; NSLog(@\"我在主线程接收到通知\");&#125;];dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:@\"MyNoti\" object:nil];&#125;); 多线程比较 Xcode 编译基本的编译过程分为四个步骤： 预处理（Pre-process）：把宏替换，删除注释，展开头文件，产生 .i 文件。 编译（Compliling）：把之前的 .i 文件转换成汇编语言，产生 .s 文件。 汇编（Asembly）：把汇编语言文件转换为机器码文件，产生 .o 文件。 链接（Link）：对.o 文件中的对于其他的库的引用的地方进行引用，生成最后的可执行文件（同时也包括多个 .o 文件进行 link） 内存分布 栈区 0x7 开头 通常存放局部变量、函数参数等。栈在运行时可动态地扩展和收缩 栈是向低地址扩展的数据结构，是一块连续的内存的区域。栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是一个编译时就确定的常数，如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。 堆区 0x6 开头 那些由 new/alloc 创建的对象所分配的内存块，内存由开发者申请和销毁；堆在运行时可动态地扩展和收缩 堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 静态区(未初始化数据) bss 段 存放未初始化的全局变量和静态变量，程序结束后由系统释放；如 int a; 常量区(已初始化数据) data 段 专门用于存放常量，程序结束后由系统释放；如 int a = 0; 代码区 用于存放程序运行时的代码，代码会被编译成二进制存进内存的程序代码区 全局区又可分为未初始化全局区：.bss 段和初始化全局区：data 段 栈区从上往下走，堆区会从下往上走，当两个相遇的时候，则会发生堆栈溢出 123456789101112int a = 10; // 全局初始化区char *p; // 全局未初始化区int main()&#123; int b; // 栈 char s[] = \"abc\" // 栈 char *p1; // 栈 char *p2 = \"123456\"; // 123456 在常量区，p2 在栈上。 static int c =0； // 全局（静态）初始化区 int array = new int[10]; // 堆&#125; 卡顿检测 方案一：基于RunloopMatrix 卡顿监控在 Runloop 的起始最开始和结束最末尾位置添加 Observer，从而获得主线程的开始和结束状态。卡顿监控起一个子线程定时检查主线程的状态，当主线程的状态运行超过一定阈值则认为主线程卡顿，从而标记为一个卡顿。 子线程 Ping 锁 自旋锁 dispatch_semaphore 递归锁 NSLock NSConditionLock pthread_mutex 互斥锁 @synchronized dispatch_barrier_async atomic https://bestswifter.com/ios-lock/ 内存检测 hook 掉 UIViewController 和 UINavigationController 的 pop 跟 dismiss 方法 调用以下代码，有误判，需要建立白名单 1234567- (BOOL)willDealloc &#123; __weak id weakSelf = self; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [weakSelf assertNotDealloc]; &#125;); return YES;&#125;","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"未分类","slug":"iOS/未分类","permalink":"http://yoursite.com/categories/iOS/未分类/"}]},{"title":"","date":"2020-08-15T09:01:57.905Z","path":"iOS/未分类/启动/","text":"App 的启动流程分为两个阶段：pre-main 和 main 脑图 pre-main 阶段 读取 App 的可执行文件（Mach-O 文件），从里面获得 dyld 的路径 加载 dyld dyld 加载动态库 加载动态库 dyld 从主执行文件的 header 中获取到需要加载的所依赖动态库列表，然后它需要找到每个 dylib，而应用所依赖的 dylib 文件可能会再依赖其他 dylib，最终递归加载所有动态库 rebase 和 binding rebase 修正镜像内部的指针 binding 修正镜像外部的指针 objc setup 注册 objc 类（class registration） 将分类的方法插到类的方法列表里（category registration） 确保 selector 的唯一性（selector uniquing） initializer 调用 objc 类和分类的 load 方法 C++ 的构造函数属性函数 非基本类型的 C++ 静态全局变量的创建（即类 or 结构体） 以上整个过程由 dyld 主导，结束后，dyld 调用真正的 main 函数 小问题：那什么是 Mach-O 呢 Mach-O 是 OSX 和 iOS 系统中可执行文件的格式，主要包括以下几种类型： Executable：应用的主要二进制 Dylib：动态链接库 Bundle：不能被链接，只能在运行时使用 dlopen 加载 Image：镜像文件，包含 Executable、Dylib 和 Bundle Framework：包含 Dylib、资源文件和头文件的文件夹 小问题：dyld 是什么？ dyld（dynamic loader），是苹果的动态链接器，用于加载动态链接库 小问题：为什么需要 rebase 和 binding iOS 采用 ASLR 技术来保证 App 的安全。 ASLR（Address Space Layout Randomization）：地址空间布局随机化，是操作系统中使用的一种安全技术。可执行文件的地址空间有一个起始地址，而 ASLR 使得这个起始地址在 App 每次启动后是随机的。如果是固定的，那么黑客很容易就可以由起始地址+偏移量找到函数的地址 一个 Mach-O 文件内部有很多符号，有指向当前 Mach-O 的，也有指向其他 dylib 的，由于 ASLR 的存在，这些符号的地址都是不对的。 比如在运行时，代码如何准确的找到 printf 函数的地址或者 NSObject 类的地址呢？ rebase 的作用把 Mach-O 文件读入内存，然后在当前 Mach-O 的起始地址添加一个偏移量，以此修正当前可执行文件内部符号的地址，解决可执行文件内部的符号引用。注意 rebase 的意思就是变基，顾名思义，修改的是起始地址 binding 的作用是使用字符串匹配的方式去查找符号表，以修正可执行文件外部符号的地址，解决可执行文件外部的符号引用。这个过程相对于 rebase 会略慢。比如当前的 Mach-O 文件没有 NSObject 这个符号，它是属于 Foundation 框架的，那么 binding 的作用就是将 NSObject 这个符号与其真正的地址进行绑定 小问题：什么是确保 selector 的唯一性 分类有可能有和本类同名的方法，对于普通方法，会优先调用分类的方法；如果不同的分类实现了相同的方法，则编译顺序靠后的会被调用 确保 selector 唯一性就是找到同名方法的真正调用地址 小问题：什么是热启动和冷启动 冷启动是指 app 进程不存在的情况下启动 App，需要创建和初始化进程 热启动是指 app 进程就驻在内存中，进程状态可能是激活的，可能是睡着的，系统将该进程激活，并放到前台。也就是没有了创建和初始化的过程，只有状态的切换 main 阶段dyld 调用 main -&gt; 调用 UIApplicationMain -&gt; 最终调用 didFinishLaunchingWithOptions 优化方法见脑图 参考 iOS启动优化 美团外卖iOS App冷启动治理 关于 rebase 和 binding 的参考","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"未分类","slug":"iOS/未分类","permalink":"http://yoursite.com/categories/iOS/未分类/"}]},{"title":"","date":"2020-08-15T09:01:57.901Z","path":"iOS/未分类/UIView 与 CALayer 区别/","text":"联系 每一个 UIView 都有一个根 layer 两者都有树状层级结构，CALayer 有 subLayers, UIView 有 subViews 区别 触摸：最大的区别 CALayer 不能处理用户的触摸事件，而 UIView 可以 UIView 继承自 UIResponder，可以处理用户的触摸事件 CALayer 直接继承 NSObject，并没有相应的处理触摸事件的接口 坐标系统：CALayer 的属性更丰富 CALayer 的坐标系统比 UIView 多了一个 anchorPoint 属性 CALayer 具有以下属性：anchorPoint, position, bounds 和 transform 等 UIView 具有以下属性：bounds, frame 等 UIView 是由 CoreAnimation 来实现的。它真正的绘图部分，是由一个 CALayer 类来管理 UIView 本身更像是一个 CALayer 的管理器，访问它的 frame，bounds 等，实际上内部都是在访问它所包含的 CALayer 的相关属性 责任：UIView 侧重于对显示内容的管理，CALayer 侧重于对内容的绘制 UIView 和 CALayer 是相互依赖的关系，UIView 依赖 CALayer 绘制的内容，CALayer 依赖 UIView 提供的容器来显示绘制的内容 所以 CALayer 是基础，没有 CALayer，UIView 自身不会存在，然而，UIView 是 CALayer 的特殊实现，可响应触摸事件 动画：我们对 UIView 的属性修改时不会产生默认动画，而对单独 layer 属性直接修改会 更多详细 UIView 与 CALayer","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"未分类","slug":"iOS/未分类","permalink":"http://yoursite.com/categories/iOS/未分类/"}]},{"title":"","date":"2020-08-15T09:01:57.897Z","path":"iOS/未分类/Property/","text":"@property 的本质1@property = ivar(实例变量) + getter/setter（存取方法）; ARC 下，property 中有哪些属性关键字？ 原子性 (atomic, nonatomic) 读写权限 (readonly, readwrite) 内存管理 (strong, weak, unsafe_unretained, retain, assign, copy) 存取方法 (getter, setter) atomic 与 nonatomic 区别 atomic 性能不佳，可保证 setter/getter 的多线程安全；但是保证不了对集合类的访问的线程安全 atomic 保证 setter/getter 安全，也保证不了数据的准确性（线程 A 写，线程 B 写，线程 A 读，读的是线程 B 写入的值） 什么是线程安全？ weak 和 assign 的区别 都是弱引用，不能使引用计数+1 对象销毁后， weak 修饰的指针会自动变成 nil，而 assign 会成为野指针 weak 只能修饰 OC 对象；assign 可以修饰基本数据类型和 OC 对象 weak 修饰的成员变量是用 __weak 修饰的；assign 生成的成员变量是用 __unsafe_unretained 默认属性是哪些 基本数据类型默认关键字是 atomic、readwrite、assign 普通的 Objective-C 对象默认关键字是 atomic、readwrite、strong 常见的修饰 NSString/NSArray: copy（why） NSMutableString/NSMutableArray: strong（why） block: copy/strong（如果是 MRC 只能用 copy） 声明 Block 时，使用 strong 和 retain 会有截然不同的效果。strong 会等于 copy，而 retain 竟然等于 assign 关于 copy 与 mutableCopy 非集合类 1234567NSString *s = @\"123\";NSString *s1 = [s copy]; // 浅复制：s1 与 s 是同个对象NSString *s2 = [s mutableCopy]; // 深复制：s2 是新对象NSMutableString *m = [@\"123\" mutableCopy]; NSMutableString *m1 = [m copy]; // 深复制：m1 是新对象NSMutableString *m2 = [m mutableCopy]; // 深复制：m2 是新对象 结果，s1 是浅复制，没有生成新的对象；其他情况都是深复制，产生了新对象 集合类 1234567NSArray *a = @[@\"123\"];NSString *a1 = [a copy]; // 浅复制：a1 与 a 是同个对象NSString *a2 = [a mutableCopy]; // 单层深复制：a2 是新对象，但集合里的元素仍然是一样NSMutableString *b = [@[@\"123\"] mutableCopy]; NSMutableString *b1 = [b copy]; // 单层深复制：b1 是新对象，但集合里的元素仍然是一样NSMutableString *b2 = [mb mutableCopy]; // 单层深复制：b2 是新对象，但集合里的元素仍然是一样 结果，a1 是浅复制，没有生成新的对象；其他情况都是 单层深复制，产生了新对象；所谓单层深复制，指的是虽然该指针指向的对象是新产生的，但是集合内部的元素仍然是一样的 更多可以参考：iOS 集合的深复制与浅复制 MRC 与 ARC 下的 setter 实现123456789101112131415161718192021222324252627282930313233343536373839404142// ARC &amp; MRC 的 assign- (void)setName:(NSString *)name&#123; _name = name;&#125;// MRC：retain 的第一种写法- (void)setName:(NSString *)name&#123; if (_name != name) &#123; [_name release]; _name = [name retain]; &#125;&#125;// MRC：retain 的第二种写法- (void)setName:(NSString *)name&#123; [name retain]; // 先 retain，防止参数是自身 [_name release]; _name = name;&#125;// MRC：copy- (void)setName:(NSString *)name&#123; if (_name != name) &#123; [_name release]; _name = [name copy]; &#125;&#125;// ARC：copy- (void)setName:(NSString *)name&#123; if (_name != name) &#123; _name = [name copy]; &#125;&#125; @synthesize@synthesize 告诉编译器自动添加 setter/getter，以及添加成员变量 如果不指定实例变量的名字，默认为添加下划线：@syntheszie var = _var; 使用场景：协议中声明的属性，实现类需要使用 @synthesize 自动合成 见 如何为协议添加属性 @dynamic@dynamic 告诉编译器：属性的实例变量、setter 与 getter 方法由用户自己实现，不自动生成；当然对于 readonly 的属性只需提供 getter 即可 如果一个属性被声明为 @dynamic，但是没你有提供 setter/getter，编译不会有问题，运行时会奔溃 而实例变量也需要自己声明 12345678910111213141516171819@interface Person ()&#123; NSInteger _age; // 这个不写会编译报错&#125;@property (nonatomic, assign) NSInteger age;@end@implementation Person@dynamic age;- (void)setAge:(NSInteger)age&#123; _age = age;&#125;- (NSInteger)age&#123; return _age;&#125;@end 什么情况不会自动合成 使用了 @dynamic 时（不再合成 setter/getter/实例变量，这 3 个需要全部自己实现） 在 @protocol 中定义的所有属性（不再合成实例变量，使用 @synthesize） 在 category 中定义的所有属性（不再合成实例变量和 getter/setter，使用关联对象） 重载的属性，当你在子类中重载了父类中的属性（不再合成实例变量，使用 @synthesize 来手动合成ivar）","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"未分类","slug":"iOS/未分类","permalink":"http://yoursite.com/categories/iOS/未分类/"}]},{"title":"","date":"2020-08-15T09:01:57.893Z","path":"iOS/未分类/NSString 的坑/","text":"__NSCFConstantString12345678NSString *str1 = @\"ab\";NSLog(@\"%p isa: %@\", str1, [str1 class]);NSString *str2 = str1;NSLog(@\"%p isa: %@\", str2, [str2 class]);NSString *str3 = [[NSString alloc] initWithString:@\"ab\"];NSLog(@\"%p isa: %@\", str3, [str3 class]);NSString *str4 = [NSString stringWithFormat:@\"ab\"];NSLog(@\"%p isa: %@\", str4, [str4 class]); 输出结果 12340x1097013f8 isa: __NSCFConstantString0x1097013f8 isa: __NSCFConstantString0x1097013f8 isa: __NSCFConstantString0xaeadd56e72cd6d4d isa: NSTaggedPointerString 其中 str1/str2/str3 的指向的内容地址相同，类都是 __NSCFConstantString 这是字符串常量，编译时分配内存，存储在常量区，引用计数是不会变的 而 str4 是一个 __NSTaggedPointerString __NSTaggedPointerString这是苹果在 64 位环境下对 NSString,NSNumber 等对象做的一些优化。 64 位环境下指针变量长达 8 位，苹果把指针指向的内容直接放在了指针变量的内存地址中 这种指针不通过解引用 isa 来获取其所属类（通过其地址的部分保留字段），因此可以当作一种伪对象 这是一个单例常量，不会被释放。 对于 NSString 对象来讲，当非字面值常量的数字，英文字母字符串的长度小于等于 9 的时候会自动成为 NSTaggedPointerString 类型 如果有中文或其他特殊符号（可能是非 ASCII 字符）存在的话则会直接成为 __NSCFString 类型 123456NSString *str5 = [NSString stringWithFormat:@\"abcdedfgh\"]; // 长度&lt;=9NSLog(@\"%p isa: %@\", str5, [str5 class]);NSString *str6 = [NSString stringWithFormat:@\"abcdedfghi\"]; // 长度&gt;9NSLog(@\"%p isa: %@\", str6, [str6 class]);NSString *str7 = [NSString stringWithFormat:@\"你\"]; // 非 ASCIINSLog(@\"%p isa: %@\", str7, [str7 class]); 输出结果 1230x8166d7f2baa92699 isa: NSTaggedPointerString0x600002be0240 isa: __NSCFString0x600002e128c0 isa: __NSCFString NSString 与引用计数 __NSCFConstantString 的引用计数无限大 __NSTaggedPointerString 的引用计数无限大 __NSCFString 的引用计数正常，对一个 __NSCFString 进行 copy 操作会使得该对象的引用计数 +1 可以通过 po @(CFGetRetainCount((__bridge CFTypeRef)(s))) 查看其引用计数 一道面试题123456789@property (nonatomic, copy) NSString *str;int n = 100000;while (n--)&#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; self.str = [NSString stringWithFormat:@\"abcdedfghi\"]; &#125;);&#125; 可能挂在这里 1234567#0 0x00007fff51a9033a in __pthread_kill ()#1 0x00007fff51b3ae60 in pthread_kill ()#2 0x00007fff51a1fb7c in abort ()#3 0x00007fff51b1ba63 in malloc_vreport ()#4 0x00007fff51b1bde6 in malloc_zone_error ()#5 0x00007fff23d9f945 in _CFRelease ()#6 0x000000010dcd4e0f in -[ViewController setStr:] 原因是多个线程调用 string 的 setter 时，当 _str 引用计数为 1 时，release 被调用了，过度释放造成 crash 12345678- (void)setStr:(NSString *)str&#123; if (_str != str) &#123; [_str release]; // arc 自动加上 _str = [str copy]; &#125;&#125; 改为 self.str = [NSString stringWithFormat:@&quot;abcdedfgh&quot;]; 就不会挂了，因为 __NSTaggedPointerString 的引用计数无限大，多次 release 也没事 同理，改为 self.str = @&quot;abcdedfgh&quot; 也不会挂，因为 __NSCFConstantString 的引用计数无限大 改为 atomic 也可以防止 crash 另外在 autoreleasepool pop 的时候也会调用 release，也可能会挂，堆栈如下 12345678#0 0x00007fff50aed94b in objc_release ()#1 0x00007fff50aef077 in AutoreleasePoolPage::releaseUntil(objc_object**) ()#2 0x00007fff50aeef96 in objc_autoreleasePoolPop ()#3 0x0000000101ed1e77 in _dispatch_last_resort_autorelease_pool_pop ()#4 0x0000000101ee3825 in _dispatch_root_queue_drain ()#5 0x0000000101ee3ca6 in _dispatch_worker_thread2 ()#6 0x00007fff51b379f7 in _pthread_wqthread ()#7 0x00007fff51b36b77 in start_wqthread ()","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"未分类","slug":"iOS/未分类","permalink":"http://yoursite.com/categories/iOS/未分类/"}]},{"title":"","date":"2020-08-15T09:01:57.890Z","path":"iOS/未分类/Native 与 JS 交互/","text":"UIWebView/WKWebView 拦截请求 Native 调用 JS 1[webView stringByEvaluatingJavaScriptFromString:@\"Math.random();\"]; JS 调用 NativeNative 拦截 UIWebView 的所有请求，判断 Scheme，如果是约定好的 Schema 就拦截请求、解析参数并调用 Native 相应的逻辑 JS 发起请求有两种方式：1. 通过 localtion.href；2. 通过 iframe 方式 前者如果短时间内连续多次修改 localtion.href 的值，Native 只会收到最后一次请求，因此 JS 侧采用 iframe 的方式发起请求 12345678910var url = 'jsbridge://doAction?title=标题';var iframe = document.createElement('iframe');iframe.style.width = '1px';iframe.style.height = '1px';iframe.style.display = 'none';iframe.src = url;document.body.appendChild(iframe);setTimeout(function() &#123; iframe.remove();&#125;, 100); 1234567891011- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType&#123; if (request.URL 是自定义的 Schema) &#123; 解析 URL 的参数 处理函数 return NO; // 不发起请求 &#125; return YES; // 正常发起请求&#125; 优点：不需要等到整个 HTML 页面加载完成就能调用 Native？ 缺点：需要繁琐地解释字符串得到相应的方法名和传值，且调用的方法也不能传递返回值； UIWebView 获取 JSContext在 webViewDidFinishLoad 通过 KVC 的方法获取 JSContext 123456789- (void)webViewDidFinishLoad:(UIWebView *)webView&#123; self.jsContext = [webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"]; self.jsContext[@\"NativeBridge\"] = self; self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) &#123; context.exception = exceptionValue; NSLog(@\"异常信息：%@\", exceptionValue); &#125;;&#125; JSContext 属于 JSCore，见下节 优点：需要等到整个 HTML 页面加载完成才能调用 JS？ 缺点：WKWebView 无法使用 JSCore WKWebView 使用 userContentControllerWKWebView 无法使用 JSCore Native 调用 JS 1@property (nonatomic, strong) WKUserContentController *userContentController; Native 和 H5 交互基本全靠这个对象， 在 WKWebVeiw 中，我们使用我们有两种方式来调用 JS， 使用 WKUserScript 直接调用 JS 字符串 1.1 使用 WKUserScript 1234// source 就是我们要调用的 JS 函数或者我们要执行的 JS 代码// injectionTime 这个参数我们需要指定一个时间，在什么时候把我们在这段 JS 注入到 WebVeiw 中，它是一个枚举值，WKUserScriptInjectionTimeAtDocumentStart 或者 WKUserScriptInjectionTimeAtDocumentEnd// MainFrameOnly 因为在 JS 中，一个页面可能有多个 frame，这个参数指定我们的 JS 代码是否只在 mainFrame 中生效- initWithSource:injectionTime:forMainFrameOnly: 至此，我们已经构建了一个 WKUserScript，然后呢，我们要做的就是要把它添加进来 1- addUserScript: 至此使用 WKUserScript 调用 JS 完成 1.2 直接调用 JS 字符串 在 WKWebView 中，我们也可以直接执行 JS 字符串 1- (void)evaluateJavaScript:completionHandler: 我们通过调用这个方法来执行 JS 字符串，然后在 completionHandler 中拿到执行这段 JS 代码后的返回值。 至此，Native 调用 JS 完成 JS 调用 Native 2.1 向 JS 注入一个字符串 1[_webView.configuration.userContentController addScriptMessageHandler:self name:@\"nativeMethod\"]; 我们向 JS 注入了一个方法，叫做 nativeMethod 2.2 JS 调用 Native 1window.webkit.messageHandlers.nativeMethod.postMessage(value); 一句话调用，我们就可以在 Native 中接收到 value 2.3 接收 JS 调用 上边我们调用 addScriptMessageHandler:name 的时候，我们要遵守 WKScriptMessageHandler 协议，然后实现这个协议。 123456- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123; NSString * name = message.name // 就是上边注入到 JS 的哪个名字，在这里是 nativeMethod id param = message.body // 就是 JS 调用 Native 时，传过来的 value // TODO: do your stuff&#125; 完了，Native 调用 JS 就这么简单 优点：简单易用缺点：JS 调用 Native 后回调较难，见 https://juejin.im/entry/59f6e836f265da431a427a57 JSCore Native 调用 JS 12345JSContext *context = [[JSContext alloc] init];NSString *js = @\"function add(a,b) &#123;return a+b&#125;\";[context evaluateScript:js]; // 注入 JS 函数[context[@\"add\"] callWithArguments:@[@\"2\", @\"3\"]];//[mJsValue invokeMethod:@\"printHello\" withArguments:@[@\"1\"]]; JS 调用 Native 借助 JSCore，我们并不一定要写 JS，可以直接使用 JSCore 模拟 JS 调用 1234JSContext *context = [[JSContext alloc] init];[context evaluateScript:@\"var a = 1;var b = 2;\"];JSValue *ret = [context evaluateScript:@\"a + b\"];NSInteger sum = [ret toInt32]; // sum=3 Native 注入函数到 JS 12JSContext *context = [[JSContext alloc] init];context[@\"NativeBridge\"] = [QLJSInterface new]; Native 实现 JSExport 123456789101112@protocol QLJSProtocol &lt;JSExport&gt;JSExportAs(open, - (void)open:(NSString *)url);@end@interface QLJSInterface : NSObject&lt;QLJSProtocol&gt;@end@implementation QLKTH5Interface- (void)open:(NSString *)url&#123; NSLog(@\"URL is %@\": url);&#125;@end JS 调用 Native，可以使用 JSCore 模拟，也可以在 JS 侧调用（需要把 JS 文件注入到 JSContext） 123JSContext *context = [[JSContext alloc] init];context[@\"NativeBridge\"] = [QLJSInterface new];[context evaluateScript:@\"NativeBridge.open('HomePage')\"]; or 1234function f()&#123; NativeBridge.open('HomePage');&#125; 优点：不依赖 WebView","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"未分类","slug":"iOS/未分类","permalink":"http://yoursite.com/categories/iOS/未分类/"}]},{"title":"","date":"2020-08-15T09:01:57.888Z","path":"iOS/未分类/KVO/","text":"基本概念 KVO 是 Key-Value Observing 的缩写，用于监听对象的某一属性改变 KVO 是 Objective-C 对观察者模式的实现 基础用法我的博客园 实现原理KVO 是使用 isa 混写技术（isa-swizzing）实现 当一个对象使用了 KVO 监听，iOS 系统会修改这个对象的 isa 指针，使其指向通过 Runtime 动态创建的子类，该子类重写了 set 方法，内部实现会调用 willChangeValueForKey、父类的 setter、didChangeValueForKey。在 didChangeValueForKey 方法中又会调用监听器的监听方法 原理如图所示 重点如下： 动态创建了子类（修改了 isa 指针的指向） RuntimeAPI : objc_allocateClassPair 和 objc_registerClassPair，动态生成 NSKVONotifying_XXX 重写了 setter 方法 调用 willChangeValueForKey 调用 super 的 setter 调用 didChangeValueForKey didChangeValueForKey 中调用 observeValueForKeyPath:ofObject:change:context: 相关面试题1. 什么是 isa 混写 / KVO 的实现原理见上节 2. 如何手动触发 KVO手动调用 willChangeValueForKey 和 didChangeValueForKey，缺一不可 1234Person *p = [[Person alloc] init];[p addObserver:self forKeyPath:@\"age\" options:NSKeyValueObservingOptionNew context:nil];[p willChangeValueForKey:@\"age\"];[p didChangeValueForKey:@\"age\"]; 3. 直接修改成员变量会触发 KVO 吗比如 _age = 20 这样的调用不会触发 KVO，因为没有调用 setter 方法 4. KVC 会触发 KVO 吗KVC 访问属性既可以通过 setter，也可能通过直接访问成员变量（+ (BOOL)accessInstanceVariablesDirectly 返回 NO 的时候就不会触访问成员变量）；会不会触发 KVO 本质上是取决于会不会触发 setter 函数 细节探究创建的子类的伪代码实现1234567891011121314151617181920212223@implementation NSKVONotifying_Person- (Class)class&#123; return [Person class]; // 而不是 return object_getClassName(self);&#125;- (void)setAge:(NSInteger)age&#123; _NSSetLongLongValueAndNotify();&#125;void _NSSetLongLongValueAndNotify()&#123; [self willChangeValueForKey:@\"age\"]; [super setAge:age]; [self didChangeValueForKey:@\"age\"];&#125;- (void)didChangeValueForKey:(NSString *)key&#123; [oberser observeValueForKeyPath:key ofObject:self change:nil context:nil];&#125;@end 动态创建子类以及重写 class 方法的代码验证1234Person *p = [[Person alloc] init];NSLog(@\"添加监听之前 %@, %@\", object_getClass(p), [p class]);[p addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew context:nil];NSLog(@\"添加监听之后 %@, %@\", object_getClass(p), [p class]); 输出 12添加监听之前 Person, Person添加监听之后 NSKVONotifying_Person, Person 可以看到 p 的 isa 指针已经被改变了，指向了一个 NSKVONotifying_ 开头的类，该类是动态生成的。 尽管如此，p 的 class 函数还是返回了用户的类，实际上是苹果重写了该方法，目的是不想让这个内部细节暴露给开发者；不重写的话，使用 [person class] 就会返回 NSKVONotifying_Person，这是苹果所不希望看到的，注意，class 方法的默认实现如下 1234- (Class)class&#123; return object_getClass(self); // 将会返回 isa 指针的实际指向，即 NSKVONotifying_Person&#125; 重写子类 set 方法的代码验证1234Person *p = [[Person alloc] init];NSLog(@\"添加监听之前的方法地址：%p\", [p methodForSelector:@selector(setAge:)]);[p addObserver:self forKeyPath:@\"age\" options:NSKeyValueObservingOptionNew context:nil];NSLog(@\"添加监听之后的方法地址：%p\", [p methodForSelector:@selector(setAge:)]); 输出如下，可以使用 p 命令将地址强制转为函数 1234567添加监听之前的方法地址：0x10c9f0bc0添加监听之后的方法地址：0x7fff257228bc(lldb) p (IMP)0x10c9f0bc0(IMP) $0 = 0x000000010c9f0bc0 (ForTest`-[Person setAge:] at Person.h:14)(lldb) p (IMP)0x7fff257228bc(IMP) $1 = 0x00007fff257228bc (Foundation`_NSSetLongLongValueAndNotify) 因为 age 是 NSInteger，所以调用了 _NSSetLongLongValueAndNotify，如果是其他数据类型就会调用对应的方法 使用以下命令可以查看 Foundation 中包含 ValueAndNotify 的方法 1nm -a /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation | grep ValueAndNotify 输出 1234567891011121314151617181920212223242526272829303132333435363738000000000015ca93 t __NSSetBoolValueAndNotify00000000000553ab t __NSSetCharValueAndNotify00000000000c6bfb t __NSSetDoubleValueAndNotify0000000000101f6a t __NSSetFloatValueAndNotify00000000001321e9 t __NSSetIntValueAndNotify0000000000052c7b t __NSSetLongLongValueAndNotify00000000001c02c7 t __NSSetLongValueAndNotify0000000000070df9 t __NSSetObjectValueAndNotify00000000000cc7f1 t __NSSetPointValueAndNotify00000000001c07be t __NSSetRangeValueAndNotify0000000000092242 t __NSSetRectValueAndNotify00000000001c053f t __NSSetShortValueAndNotify00000000000cc624 t __NSSetSizeValueAndNotify00000000001c0183 t __NSSetUnsignedCharValueAndNotify00000000000d4d60 t __NSSetUnsignedIntValueAndNotify000000000008cd85 t __NSSetUnsignedLongLongValueAndNotify00000000001c0401 t __NSSetUnsignedLongValueAndNotify00000000001c0678 t __NSSetUnsignedShortValueAndNotify00000000001bf600 t __NSSetValueAndNotifyForKeyInIvar00000000001bf662 t __NSSetValueAndNotifyForUndefinedKey00000000001c091e t ____NSSetBoolValueAndNotify_block_invoke00000000000554eb t ____NSSetCharValueAndNotify_block_invoke00000000000c6d45 t ____NSSetDoubleValueAndNotify_block_invoke00000000001020b3 t ____NSSetFloatValueAndNotify_block_invoke0000000000136a41 t ____NSSetIntValueAndNotify_block_invoke0000000000052e23 t ____NSSetLongLongValueAndNotify_block_invoke00000000001c0989 t ____NSSetLongValueAndNotify_block_invoke0000000000091811 t ____NSSetObjectValueAndNotify_block_invoke0000000000125637 t ____NSSetPointValueAndNotify_block_invoke00000000001c0a4a t ____NSSetRangeValueAndNotify_block_invoke00000000000923db t ____NSSetRectValueAndNotify_block_invoke00000000001c09ed t ____NSSetShortValueAndNotify_block_invoke0000000000122c1a t ____NSSetSizeValueAndNotify_block_invoke00000000001c0958 t ____NSSetUnsignedCharValueAndNotify_block_invoke00000000000d4e9d t ____NSSetUnsignedIntValueAndNotify_block_invoke00000000000ab280 t ____NSSetUnsignedLongLongValueAndNotify_block_invoke00000000001c09b6 t ____NSSetUnsignedLongValueAndNotify_block_invoke00000000001c0a1a t ____NSSetUnsignedShortValueAndNotify_block_invoke 参考资料面试驱动技术 - KVO &amp;&amp; KVC","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"未分类","slug":"iOS/未分类","permalink":"http://yoursite.com/categories/iOS/未分类/"}]},{"title":"","date":"2020-08-15T09:01:57.884Z","path":"iOS/未分类/KVC/","text":"基本概念 KVC 是 Key-Value Coding 的缩写，让开发者可以通过 Key 直接访问或设置对象的属性/成员变量，而不需要调用存取方法 KVC 可以直接获取、修改类不想暴露的私有变量，所以会破坏面向对象的编程思想 UITextView 设置 _placeholderLabel 可用到 基础用法12345- (id)valueForKey:(NSString *)key; // 直接通过 Key 来取值- (void)setValue:(id)value forKey:(NSString *)key; // 通过 Key 来设值- (id)valueForKeyPath:(NSString *)keyPath; // 通过 KeyPath 来取值- (void)setValue:(id)value forKeyPath:(NSString *)keyPath; // 通过 KeyPath 来设值 通过 Key 来访问直接的属性 12// age 是 b 的属性[b setValue:@23 forKey:@\"age\"]; 通过 KeyPath 来访问属性的属性 12// b 是 a 的一个属性[a setValue:@23 forKeyPath:@\"b.age\"]; 实现原理KVC setter 的查找过程以 [b setValue:@23 forKey:@&quot;age&quot;]; 举例 查找 B 中的 setAge:、_setAge: 方法；找到则调用，结束 查看 B 的 + (BOOL)accessInstanceVariablesDirectly 返回值，若为 NO 则调用 B 的 setValue:forUndefinedKey: 并抛异常，结束（默认值为 YES） 查找 B 中的 _age、_isAge、age、isAge，找到则直接访问；否则调用 B 的 setValue:forUndefinedKey: 并抛异常 KVC getter 的查找过程以 [b valueForKey:@&quot;age&quot;]; 举例 查找 B 中的 getAge、age、isAge、_getAge、_age、_isAge 方法；找到则调用，结束 查找一些集合类的特有方法，比如 count/sum/average 等，这里不展开 查看 B 的 + (BOOL)accessInstanceVariablesDirectly 返回值，若为 NO 则调用 B 的 valueForUndefinedKey: 并抛异常，结束（默认值为 YES） 查找 B 中的 _age、_isAge、age、isAge，找到则直接访问；否则调用 B 的 valueForUndefinedKey: 并抛异常 accessInstanceVariablesDirectly 方法，顾名思义，是否允许直接访问成员变量，默认 YES","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"未分类","slug":"iOS/未分类","permalink":"http://yoursite.com/categories/iOS/未分类/"}]},{"title":"","date":"2020-08-15T09:01:57.881Z","path":"iOS/未分类/iOS 触摸机制/","text":"原理iOS 把用户触摸事件打包成一个 UIEvent 对象，作为事件传递的消息载体，放入当前活跃的 APP 的消息队列中，然后通过 Hit-Test 机制 来找到响应者，响应者通过响应链（Responder Chain）的传递做出响应，这就是 iOS 事件分发机制的实现原理 UIEvent 有哪些UIEvent 包含最常见的三种事件：Touch Events(触摸事件)、Motion Events(运动事件，比如重力感应和摇一摇等)、Remote Events(远程事件，比如用耳机控制手机)。这里我们只讨论触摸事件 Hit-Test 机制如图，我点击了 E，Hit-Test 机制是如何找到这个 View 呢？ 1234567891011121314151617181920212223- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; // 1. 判断能否接受事件 if (!self.userInteractionEnabled || self.hidden || self.alpha &lt;= 0.01) return nil; // 2. 判断是否在当前 View 内 if ([self pointInside:point withEvent:event] == NO) return nil; // 3. 逆序遍历子视图 for (UIView *subview in [self.subviews reverseObjectEnumerator]) &#123; // 坐标转换，将当前坐标系的点转化为子视图的坐标系的点 CGPoint childP = [self convertPoint:point toView:subview]; UIView *hitView = [subview hitTest:childP withEvent:event]; if (hitView) &#123; return hitView; &#125; &#125; // 4. 不在子视图，则返回自己 return self;&#125; 其中 UIView 的 pointInside:withEvent: 方法的作用是，判断当前的点是否在当前 View 的 bounds 中 1234- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event&#123; return CGRectContainsPoint(self.bounds, point);&#125; 注意，以下情况，Hit-Test 函数返回 nil view.isHidden = YES view.alpha &lt;= 0.01 view.userInterfaceEnable=NO control.enable = NO（如果是 UIControl） 其次注意，子视图的遍历是逆序的，为了保证相同层级下的子视图，离用户越近的优先得到响应 Responder Chain（响应链）在 UIKit 中，UIApplication、UIView、UIViewController 这几个类都是直接继承自 UIResponder 类；而响应链是由 UIResponder 组合而成的数组，起始于 FirstResponder，结束于 UIApplication 用户触摸屏幕后，系统通过 Hit-Test 机制找到响应的 UIView，即 FirstResponder；如果该 UIResponder 不处理该事件，则会交给它 的下一个 UIResponder，如果该 UIResponder 处理则停止，否则继续递归直到响应链结束 UIView 的 nextResponder 属性，如果有管理此 view 的 UIViewController 对象，则为此 UIViewController 对象；否则 nextResponder 即为其 superview UIViewController 的 nextResponder 属性为其管理 view 的 superview UIWindow 的 nextResponder 属性为 UIApplication 对象 UIApplication 的 nextResponder 属性为 nil。 应用寻找 UIView 所在的 Controller123456789101112131415@implementation UIView (Controller)- (UIViewController *)viewController&#123; UIResponder *responder = [self nextResponder]; while (responder) &#123; if ([responder isKindOfClass:[UIViewController class]]) &#123; return (UIViewController *)responder; &#125; responder = [responder nextResponder]; &#125; return nil;&#125;@end 扩大按钮点击区域重写以下方法即可 12345678- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; CGRect relativeFrame = self.bounds; // 上下左右扩大 15 像素 UIEdgeInsets hitTestEdgeInsets = UIEdgeInsetsMake(-15, -15, -15, -15); CGRect hitFrame = UIEdgeInsetsInsetRect(relativeFrame, hitTestEdgeInsets); return CGRectContainsPoint(hitFrame, point);&#125; 子 view 超出了父 view 的 bounds 响应事件正常情况下，子 View 超出父 View 的 bounds 的那一部分是不会响应事件的 解决方法1：重写父 View 的 pointInside 方法 这种方法会导致如果点击在父 View （而不是其子 View）上时，不会再响应任何事件，父 View 就像变透明了一样 1234567891011121314- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; // 这是默认实现 // return CGRectContainsPoint(self.bounds, point); for (UIView *view in self.subviews) &#123; if (CGRectContainsPoint(view.frame, point)) &#123; return YES; &#125; &#125; return NO;&#125; 解决方法2：重写父 View 的 hitTest 方法（推荐） 1234567891011121314151617181920- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; UIView *view = [super hitTest:point withEvent:event]; if (view == nil) &#123; // 如果默认返回 nil，说明此次点击确实不在父 View 范围内 // 此时我们再多加一层判断是否在子 View 内，如果满足则返回子 View for (UIView *subview in [self.subviews reverseObjectEnumerator]) &#123; CGPoint childP = [self convertPoint:point toView:subview]; UIView *hitView = [subview hitTest:childP withEvent:event]; if (hitView) &#123; return hitView; &#125; &#125; &#125; return view;&#125; 实现一个透明的 View，点击子 View 有效，点击自身无效1234567891011// 播放器中用到的 QNBPlayerIntellectView- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; UIView *hitTestView = [super hitTest:point withEvent:event]; // 如果点击的对象是自己，则当没事发生 if (hitTestView == self) &#123; hitTestView = nil; &#125; return hitTestView;&#125;","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"未分类","slug":"iOS/未分类","permalink":"http://yoursite.com/categories/iOS/未分类/"}]},{"title":"","date":"2020-08-15T09:01:57.878Z","path":"iOS/未分类/block 和 delegate 的区别/","text":"特性对比 block delegate 安全性 容易产生循环引用 可读性 代码集中更连贯，代码更少 性能 性能开销比 delegate 多，因为 block 会涉及到栈区向堆区拷⻉等操作，时间和空间上的消耗都⼤于 delegate 如何选择 回调方法较少时使用 block，比如网络请求；有多个回调方法使用 delegate，比如 tableview 临时性的回调使用 block，比如数组的枚举；只调用一次的回调且需要存储的，使用 delegate/block 均可，比如网络；可能调用多次的回调，需要存储，使用 delegate 更好，比如按钮的点击","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"未分类","slug":"iOS/未分类","permalink":"http://yoursite.com/categories/iOS/未分类/"}]},{"title":"","date":"2020-08-15T09:01:57.845Z","path":"iOS/内存管理/Weak-Strong Dance/","text":"Weak-Strong Dance1234__typeof(&amp;*self) __weak weakSelf = self;self.completionHandler = ^(NSInteger result) &#123; [weakSelf.property removeObserver:weakSelf forKeyPath:@\"pathName\"];&#125;; 假设 block 被放在子线程中执行，而且执行过程中 self 在主线程被释放了。由于 weakSelf 是一个弱引用，因此会自动变为 nil 而这个例子的 KVO 中，这会导致崩溃 解决以上问题的方法很简单，新增一行代码即可 12345__typeof(&amp;*self) __weak weakSelf = self;self.completionHandler = ^(NSInteger result) &#123; __typeof(&amp;*self) __strong strongSelf = weakSelf; [strongSelf.property removeObserver:strongSelf forKeyPath:@\"pathName\"];&#125;; self 所指向对象的引用计数变成 2，即使主线程中的 self 因为超出作用于而释放，对象的引用计数依然为 1，避免了对象的销毁 Q：下面这行代码，将一个弱引用的指针赋值给强引用的指针，可以起到强引用效果么？ __typeof(&amp;*self) __strong strongSelf = weakSelf; A：会的。引用计数描述的是对象而不是指针。strongSelf 会强引用 weakSelf 指向的那个对象。因此对象的引用计数会加一 Q：block 内部定义了 strongSelf，会不会因此强引用了 strongSelf？ A：不会。block 只有截获外部变量时，才会引用它。如果是内部新建一个，则没有任何问题 Q：如果在 block 内部没有强引用，而是通过 if 判断，是不是也可以，比如这样写： 1234567__typeof(&amp;*self) __weak weakSelf = self;wself.completionHandler = ^(NSInteger result) &#123; if (weakSelf) &#123; [weakSelf.property removeObserver:weakSelf forKeyPath:@\"pathName\"]; &#125;&#125;; A：不可以！考虑到多线程执行，也许在判断的时候，self 还没释放，但是执行 self 里面的代码时，就刚好释放了 Q：那按照这个说法，block 内部强引用也没用啊。也许 block 执行以前，self 就释放了 A：有用！如果在 block 执行以前，self 就释放了，那么 block 的引用计数降为 0，所以自己就会被释放。这样它根本就不会被执行 Q：如果在执行 block 的过程中，block 被释放了怎么办？ A：简单来说，block 还会继续执行，但是它捕获的指针会变成 nil 12345__weak ObjectA * weakSelf = self;self.completion = ^&#123; weakSelf.completion = nil; [weakSelf doSomethingElse];&#125;; 当我们这样调用时，执行到 weakSelf.completion = nil 时，block 会被释放但会继续执行，weakSelf 会变为 nil，因此 doSomethingElse 不会被执行 1_completion(); // 直接使用成员变量 如果这样调用就可以避免 block 的释放，这个会在栈上创建一个 block 的 copy，原始的 block 对象会被释放，但是新的对象会继续正常执行，weakSelf 也不会变 nil 1self.completion(); 使用系统 API 需不需要使用 weak正常情况下是不需要的，比如 123456789101112131415[UIView animateWithDuration:duration animations:^&#123; [self.superview layoutIfNeeded]; &#125;];[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; self.someProperty = xyz;&#125;];[[NSNotificationCenter defaultCenter] addObserverForName:@\"someNotification\" object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification *notification) &#123; self.someProperty = xyz; &#125;]; 但是如果系统的 API 对 self 有引用的时候就要考虑，比如 1234567891011121314151617// self-&gt;operationsGroup/operationsQueue-&gt;block-&gt;self__weak __typeof__(self) weakSelf = self;dispatch_group_async(_operationsGroup, _operationsQueue, ^&#123; __typeof__(self) strongSelf = weakSelf; [strongSelf doSomething]; [strongSelf doSomethingElse];&#125;);// self-&gt;observer-&gt;block-&gt;self__weak __typeof__(self) weakSelf = self;_observer = [[NSNotificationCenter defaultCenter] addObserverForName:@\"testKey\" object:nil queue:nil usingBlock:^(NSNotification *note) &#123; __typeof__(self) strongSelf = weakSelf; [strongSelf dismissModalViewControllerAnimated:YES];&#125;]; 封装常用的宏12#define DECLARE_WEAK_SELF __typeof(&amp;*self) __weak weakSelf = self#define DECLARE_STRONG_SELF __typeof(&amp;*self) __strong strongSelf = weakSelf","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"内存管理","slug":"iOS/内存管理","permalink":"http://yoursite.com/categories/iOS/内存管理/"}]},{"title":"","date":"2020-08-15T09:01:57.842Z","path":"iOS/内存管理/dealloc 探究/","text":"结论 dealloc 是在最后一次 release 执行后调用 ARC 下，对象的实例变量的释放时机是：编译器在 NSObject 插入的 .cxx_desctruct 方法释放 ARC 下 [super dealloc] 方法是由编译器自动插入，所以不需要手动调用 dealloc 主要干三件事： 释放对象的实例变量 释放对象的关联对象（即释放该类的分类里设置的关联属性） 将所有指向该对象的 weak 指针置为 nil 源码探讨通过 apple 的 runtime 源码，不难发现 NSObject 执行 dealloc 最后执行到 objc_destructInstance 12345678910111213141516171819void *objc_destructInstance(id obj)&#123; if (obj) &#123; Class isa_gen = _object_getClass(obj); class_t *isa = newcls(isa_gen); // Read all of the flags at once for performance. bool cxx = hasCxxStructors(isa); bool assoc = !UseGC &amp;&amp; _class_instancesHaveAssociatedObjects(isa_gen); // 重点 if (cxx) object_cxxDestruct(obj); if (assoc) _object_remove_assocations(obj); if (!UseGC) objc_clear_deallocating(obj); &#125; return obj;&#125; 简单明确的干了三件事： object_cxxDestruct：strong 修饰的变量执行 objc_storeStrong(&amp;ivar, nil) release 对象，ivar 赋值 nil；weak 修饰的变量执行 objc_destroyWeak(&amp;ivar) -&gt; storeWeak(&amp;ivar, nil ) -&gt; weak_unregister_no_lock，将变量指向 nil，且删除变量对象的 weak 相关信息（referrers 移除 weak 地址） 执行 _object_remove_assocations 去除和这个对象 assocate 的对象（常用于 category 中添加带变量的属性） 执行 objc_clear_deallocating，清空引用计数表并清除弱引用表，将所有 weak 引用指 nil（这也就是 weak 变量能安全置空的所在） 面试题：引用计数减为 0 会立即释放吗答案：会。dealloc 是在最后一次 release 执行后调用 参考文章 ARC 下 dealloc 过程及.cxx_destruct 的探究","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"内存管理","slug":"iOS/内存管理","permalink":"http://yoursite.com/categories/iOS/内存管理/"}]},{"title":"","date":"2020-08-15T09:01:57.839Z","path":"iOS/内存管理/autorelease/","text":"autorelease 的伪代码实现1[obj autorelease]; 等同于以下代码 12345// NSObject.m:- (id)autorelease &#123; [NSAutoreleasePool addObject:self];&#125; 123456789101112131415// NSAutoreleasePool. 类方法+ (void)addObject:(id)anObj &#123; NSAutoreleasePool *pool = 获取正在使用中的 pool； if (pool != nil) &#123; [pool addObject:anObj]; &#125;&#125;// NSAutoreleasePool.m 实例方法- (void)addObject:(id)anObj &#123; [array addObject:anObj];&#125; 其中关于获取正在使用中的 pool，以下例子的 obj 在调用 autorelease 时取到的 autoreleasepool 就是 poo2 12345678NSAutoreleasePool *pool1 = [[NSAutoreleasePool alloc] init];NSAutoreleasePool *pool2 = [[NSAutoreleasePool alloc] init];NSObject *obj = [[NSObject alloc] init];[obj autorelease][poo1 drain];[poo2 drain]; 12345678910111213141516171819// drain 的实现- (void)drain&#123; [self dealloc];&#125;- (void)dealloc&#123; [self emptyPool]; [array release];&#125;- (void)emptyPool&#123; for (id obj in array) &#123; [obj release]; &#125;&#125; autorelease 苹果的实现12345678910111213141516171819202122232425262728293031323334353637383940class AutoreleasePoolPage &#123; static inline void *push() &#123; // 相当于生成或持有 NSAutoreleasePool 类对象 &#125; static inline id autorelease(id obj) &#123; // 相当于 NSAutoreleasePool 类的 addObject 类方法 AutoreleasePoolPage *autoreleasePoolPage = 取得正在使用的 AutoreleasePoolPage 实例； autoreleasePoolPage-&gt;add(obj); &#125; id *add(id obj) &#123; // 将对象追加到内部数组中 &#125; static inline void *pop(void *token) &#123; // 相当于废弃 NSAutoreleasePool 类对象 releaseAll(); &#125; void releaseAll() &#123; // 调用内部数组中对象的 release 实例方法 &#125;&#125;;void *objc_autoreleasePoolPush(void)&#123; return AutoreleasePoolPage::push();&#125;void objc_autoreleasePoolPop(void *ctxt)&#123; AutoreleasePoolPage::pop(ctxt);&#125;id *objc_autorelease(id obj) &#123; return AutoreleasePoolPage::autorelease(obj);&#125; 123456789// 等同于 objc_autoreleasePoolPush()NSAutoreleasePool *pool=[[NSAutoreleasePool alloc] init];id obj = [[NSObject alloc] init];// 等同于 objc_autorelease(obj)[obj autorelease];// 等同于 obic_autoreleasePoolPop(pool)[pool drain]; AutoreleasePool 的底层实现 AutoreleasePool 是由一个个 AutoreleasePoolPage 组成的双向链表 AutoreleasePoolPage 内部维护一个栈；栈满的时候会新建一个 AutoreleasePoolPage 节点 AutoreleasePool Push 时会压入一个边界对象表示一个 AutoreleasePool 的开始，Pop 时会清理堆栈直到遇到一个边界对象；边界对象是界定 AutoreleasePool 的分割线 AutoreleasePool 与 RunLoopApp 启动后，苹果在主线程 RunLoop 里注册了两个 Observer，区别是优先级不同 第一个 Observer 优先级最高，保证创建释放池发生在其他所有回调之前，监视了一个事件： Entry（即将进入 Loop），其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。 第二个 Observer 优先级最低，保证其释放池子发生在其他所有回调之后，监视了两个事件： BeforeWaiting（准备进入休眠）时调用 _objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池； Exit(即将退出 Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。 在主线程执行的代码，通常是写在诸如事件回调、Timer 回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了 参考文章 AutoreleasePool 底层实现原理","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"内存管理","slug":"iOS/内存管理","permalink":"http://yoursite.com/categories/iOS/内存管理/"}]},{"title":"","date":"2020-08-15T09:01:57.833Z","path":"iOS/Runtime/方法交换/","text":"代码实现1234567891011121314151617181920212223242526void swizzleMethod(Class class, SEL originalSelector, SEL swizzledSelector)&#123; // 获取 Method Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); // 确保这两个方法一定存在（要么在本类，要么在其父类里） if (originalMethod &amp;&amp; swizzledMethod) &#123; // 如果本类没有 origin 方法，则给 originalSelector 添加 swizzled 实现（origin 方法在父类，因为 originalMethod 不为空），返回 YES // 如果本类有 origin 方法，则添加失败，返回 NO BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; // 添加成功，表示已实现 originalSelector -&gt; swizzledIMP // 接下来实现 swizzledSelector -&gt; originalIMP class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; // 添加失败，表示类里原本就有 originalIMP，只需要交换这两个方法的实现即可 method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;&#125; 代码示例： 123456789101112131415161718+ (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; swizzleMethod(self, @selector(viewDidLoad), @selector(my_viewDidLoad)); &#125;);&#125;- (void)viewDidLoad&#123; [super viewDidLoad];&#125;- (void)my_viewDidLoad&#123; NSLog(@\"View Did Load\"); [self my_viewDidLoad];&#125; 为什么不能直接调用 method_exchangeImplementations 参见：方法交换的图示 方法交换为什么写在 +load 中而不是 initialze 方法交换为什么要 dispatch_once 中执行 参见：iOS 的 initialize 和 load 区别 class_getInstanceMethod1Method class_getInstanceMethod(Class cls, SEL name); 获取指定 SEL 的 Method 如果该类没有指定 SEL 的 Method，父类里面可能有 所以如果该类和其父类都没有该 SEL 的实现，才返回 NULL class_addMethod1BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types); 给指定 SEL 添加新实现。如果添加成功则返回 YES，否则返回 NO（比如该类已经有对应 SEL 的 IMP） 注意，该方法会覆盖父类的实现，但不会替换本类原有的实现。如果要替换本类原有实现，使用 method_setImplementation class_replaceMethod1IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types); 替换指定 SEL 的实现，返回值为被替换掉的 IMP 如果本类不存在该 name 的 Method，则 class_addMethod 会被调用 如果本类存在该 name 的 Method，则 method_setImplementation 会被调用 method_exchangeImplementations1method_exchangeImplementations(Method m1, Method m2) 交换两个方法的实现 应用实例 AOP（Aspect of programming），给所有的 Controller 的 viewWillAppear 等生命函数添加数据上报、日志等 API 安全性保护，替换 NSArray 的 addObject 方法，防止插入 nil 对象，Debug 下报错，详见 Github Demo","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"Runtime","slug":"iOS/Runtime","permalink":"http://yoursite.com/categories/iOS/Runtime/"}]},{"title":"","date":"2020-08-15T09:01:57.831Z","path":"iOS/Runtime/如何为协议添加属性/","text":"如果是协议中的属性，编译器不会自动合成实例变量，相当于只是声明了 setter/getter（注意是声明，没有实现） 第一步，声明协议 123@protocol QVNImageProtocol &lt;NSObject&gt;@property (nonatomic, weak) id&lt;QVNInnerImageLoadDelegate&gt; vn_imageDelegate;@end 第二步，实现协议的人需要自动合成实例变量 123456@interface QVNImageView &lt;QVNImageLoadDelegate&gt;@end@implementation QVNImageView@synthesize vn_imageDelegate;@end 问题来了，自动合成的属性会不会拥有 weak/assign/readonly 等属性呢 答案是会的，@property 会根据这些属性合成对应的 setter/getter 当然你也可以模仿 @synthesize 的作用，手动添加成员变量和 setter/getter 1234567891011121314151617181920@interface QVNImageView &lt;QVNImageLoadDelegate&gt;&#123; __weak id&lt;QVNInnerImageLoadDelegate&gt; _vn_imageDelegate;&#125;@end@implementation QVNImageView- (id&lt;QVNInnerImageLoadDelegate&gt;)vn_imageDelegate&#123; return _vn_imageDelegate;&#125;- (void)setVn_imageDelegate:(id&lt;QVNInnerImageLoadDelegate&gt;)vn_imageDelegate&#123; if (vn_imageDelegate != _vn_imageDelegate) &#123; _vn_imageDelegate = vn_imageDelegate; &#125;&#125;@end","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"Runtime","slug":"iOS/Runtime","permalink":"http://yoursite.com/categories/iOS/Runtime/"}]},{"title":"","date":"2020-08-15T09:01:57.829Z","path":"iOS/Runtime/如何为分类添加属性/","text":"Runtime 原理123456789struct category_t &#123; const char *name; // 原类名，而不是分类名 // 要扩展的类对象，编译期间是不会定义的，而是在 Runtime 阶段通过 name 对应到对应的类对象 classref_t cls; struct method_list_t *instanceMethods; // 分类中新增的对象方法列表 struct method_list_t *classMethods; // 分类中新增的类方法列表 struct protocol_list_t *protocols; // 分类中新增的协议列表 struct property_list_t *instanceProperties; // 分类中新增的属性列表&#125;; 可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，但不可以添加成员变量 instanceProperties 的存在是我们可以通过 objc_setAssociatedObject 和 objc_getAssociatedObject 向分类中增加实例变量的原因，不过这个和一般的实例变量是不一样的 所以，Category 可以使用 @property，但不会生成带下划线的成员变量，也不会生成 getter 和 setter（@property 只是帮助声明了 setter/getter，并没有提供实现）。我们可以使用 Runtime 为已有的类添加新的属性并生成 getter 和 setter 方法 语法12345void objc_setAssociatedObject (id object, void *key, id value, objc_AssociationPolicy policy);id objc_getAssociatedObject(id object, void *key);void objc_removeAssociatedObject(id object); // 移除 object 上的所有关联对象 参数说明 id object：被关联的对象（一般为 self） const void *key：关联的key，要求唯一，因此避免使用 @””（一般为新增属性的 getter） id value：关联的对象（一般为新增的属性） objc_AssociationPolicy policy：内存管理的策略 key关联的 key 值有三种推荐值 声明 static char kAssociatedObjectKey;，使用 &amp;kAssociatedObjectKey 作为 key 值 声明 static void *kAssociatedObjectKey = &amp;kAssociatedObjectKey; ，使用 kAssociatedObjectKey 作为 key 值 用 selector ，使用 getter 方法的名称作为 key 值（推荐） 设置关联对象值时，若想令两个健匹配到相同的一个值，则二者必须是完全相同的指针才行。 所以 key 值最好定义为一个全局静态变量，而不能每次都用 @”xxx” 推荐使用 selector，因为这种方法省略了声明参数的代码，并且能很好地保证 key 的唯一性 内存管理策略其中 objc_AssociationPolicy 是关联对象的属性，如下 12345OBJC_ASSOCIATION_ASSIGN --- assignOBJC_ASSOCIATION_RETAIN_NONATOMIC --- nonatomic, retainOBJC_ASSOCIATION_COPY_NONATOMIC --- nonatomic, copyOBJC_ASSOCIATION_RETAIN --- retain(strong)OBJC_ASSOCIATION_COPY --- copy 例子123@interface UIView (VN_ShortCut)@property (nonatomic, weak) UICollectionView *vn_cellCollectionView;@end 1234567891011@implementation UIView (VN_ShortCut)- (UICollectionView *)vn_cellCollectionView &#123; return objc_getAssociatedObject(self, @selector(vn_cellCollectionView));&#125;- (void)setVn_cellCollectionView:(UICollectionView *)cellCollectionView &#123; objc_setAssociatedObject(self, @selector(vn_cellCollectionView), cellCollectionView, OBJC_ASSOCIATION_ASSIGN);&#125;@end OBJC_ASSOCIATION_ASSIGN 可能引发 crash注意 OBJC_ASSOCIATION_ASSIGN 的作用是 assign 而不是 weak，所以当关联的对象被释放的时候并不会被自动置为 nil，因此获取到的对象将会是一个野指针。 直观的方法 1如果要实现 weak 的效果，解决方法是新建一个替身，weak 引用住该对象，然后使用 OBJC_ASSOCIATION_RETAIN_NONATOMIC 存储该替身。 以上面的例子为例，代码如下 1234567891011- (UICollectionView *)vn_cellCollectionView&#123; QVNWeakProxy *proxy = objc_getAssociatedObject(self, @selector(vn_cellCollectionView)); return (UICollectionView *)proxy.target;&#125;- (void)setVn_cellCollectionView:(UICollectionView *)cellCollectionView&#123; QVNWeakProxy *proxy = [[QVNWeakProxy alloc] initWithTarget:cellCollectionView]; objc_setAssociatedObject(self, @selector(vn_cellCollectionView), proxy, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125; 其中 QVNWeakProxy 只要继承自 NSObject 并实现 target 的存取方法即可 优雅的方法 2变量用 __weak 修饰，因此被 block 捕获的时候不会增加引用计数；block 使用 copy 修饰，可以将栈 block 转为堆 block，防止被释放 123456789101112- (UICollectionView *)vn_cellCollectionView&#123; id (^block)(void) = objc_getAssociatedObject(self, @selector(vn_cellCollectionView)); return (block ? block() : nil);&#125;- (void)setVn_cellCollectionView:(UICollectionView *)cellCollectionView&#123; id __weak weakObject = cellCollectionView; id (^block)(void) = ^&#123;return weakObject;&#125;; objc_setAssociatedObject(self, @selector(vn_cellCollectionView), block, OBJC_ASSOCIATION_COPY);&#125; 引申思考：为什么内存管理没有 weak 选项","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"Runtime","slug":"iOS/Runtime","permalink":"http://yoursite.com/categories/iOS/Runtime/"}]},{"title":"","date":"2020-08-15T09:01:57.827Z","path":"iOS/Runtime/分类/","text":"[TOC] 分类的源码123456789struct category_t &#123; const char *name; // 原类名，而不是分类名 // 要扩展的类对象，编译期间是不会定义的，而是在 Runtime 阶段通过 name 对应到对应的类对象 classref_t cls; struct method_list_t *instanceMethods; // 分类中新增的对象方法列表 struct method_list_t *classMethods; // 分类中新增的类方法列表 struct protocol_list_t *protocols; // 分类中新增的协议列表 struct property_list_t *instanceProperties; // 分类中新增的属性列表&#125;; 分类为什么不能添加实例变量 从底层结构上看：没有实例变量的相关字段，所以分类是无法添加实例变量的（即分类在编译时无法保存实例变量的信息，而 instanceProperties 的存在说明属性是可以的） 从内存结构上看：在运行期，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局（即使分类保存了实例变量的信息，运行时也无法向本类添加实例变量） 如何理解在运行期，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局？ 那为什么添加方法就不会呢？还得从 objc_class 的结构说起 注：本文关于 objc_class 的源码都是基于老版本的源码，其结构更容易理解 1234567891011121314151617struct objc_class&#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; 1234567891011struct objc_ivar_list &#123; int ivar_count OBJC2_UNAVAILABLE; /* variable length structure */ struct objc_ivar ivar_list[1] OBJC2_UNAVAILABLE;&#125; struct objc_ivar &#123; char *ivar_name OBJC2_UNAVAILABLE; char *ivar_type OBJC2_UNAVAILABLE; int ivar_offset OBJC2_UNAVAILABLE;&#125; 可以看到，ivars 是一个一级指针，指向的是一个 objc_ivar_list 类，其中 ivar_list 的大小是可变的；这个可以在 class_addIvar 的实现中找到 1234567891011121314151617181920212223242526272829303132333435BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *type)&#123; ivar_list_t *oldlist, *newlist; if ((oldlist = (ivar_list_t *)cls-&gt;data()-&gt;ro-&gt;ivars)) &#123; size_t oldsize = oldlist-&gt;byteSize(); // 重新分配内存，影响的是 ivar_list 的大小 newlist = (ivar_list_t *)calloc(oldsize + oldlist-&gt;entsize(), 1); memcpy(newlist, oldlist, oldsize); free(oldlist); &#125; else &#123; newlist = (ivar_list_t *)calloc(sizeof(ivar_list_t), 1); newlist-&gt;entsizeAndFlags = (uint32_t)sizeof(ivar_t); &#125; uint32_t offset = cls-&gt;unalignedInstanceSize(); uint32_t alignMask = (1&lt;&lt;alignment)-1; offset = (offset + alignMask) &amp; ~alignMask; // 对这块内存进行复写 ivar_t&amp; ivar = newlist-&gt;get(newlist-&gt;count++); ivar.offset = (int32_t *)malloc(sizeof(int32_t)); *ivar.offset = offset; ivar.name = name ? strdupIfMutable(name) : nil; ivar.type = strdupIfMutable(type); ivar.alignment_raw = alignment; ivar.size = (uint32_t)size; // 重新指向这个新的 list ro_w-&gt;ivars = newlist; // 更新 instance_size cls-&gt;setInstanceSize((uint32_t)(offset + size)); return YES;&#125; 调用 class_addIvar 会添加一个实例变量，影响 instance_size 和 ivars 所指向的空间的大小。但是仍然无法解释为什么不能添加 ivars 此时还得知道一个 ivar 是如何被系统访问的，如果按照以下这种方式访问 ivar，整个流程要经过好多次指针转移： 12class -&gt; class.rw_data -&gt; class.rw_data.ro_data -&gt; class.rw_data.ro_data.ivars -&gt; -&gt; class.rw_data.ro_data.ivars.first[n] 如果是这样，那么动态添加 ivar 似乎变得可行，因为 ivar 是指针，往指针指向的内容扩充并不会影响类的大小，访问时只要遍历所有 ivar list 就可以找到对应的 ivar，但是这样访问，大量使用 ivar 肯定很耗时。事实上 Runtime 不是这样访问 ivar 的 那么，对于 ivar 的访问究竟是怎么样的呢？ 这篇 《谈谈 ivar 的直接访问》 提到，对 ivar 的访问，其实是在编译期将 ivar 相对于类本身的偏移量存储在一个全局变量里，全局变量的值在编译的时候就确定了，这个全局变量的地址就存在 objc_ivar 的 ivar_offset 即编译时，系统会将对这个 ivar 的读写访问的代码转为，本类地址加上对应的全局偏移量，就能访问到对应 ivar 的值。 12@property (nonatomic, assign) NSInteger myInt;self.myInt = 5; 编译后的代码为 12extern \"C\" unsigned long OBJC_IVAR_$_MyObject$_myInt;(*(NSInteger *)((char *)self + OBJC_IVAR_$_MyObject$_myInt)) = 5; 而正是由于这种关系，在运行时如果想添加一个 ivar，势必会导致所有全局偏移量不正确 有人会说，如果加在 ivar list 的前面会影响旧的 ivar 的全局偏移量，那加在 ivar list 后面不就影响不了吗？答案是，类是可以被继承的，给父类的 ivar list 尾部添加一个 ivar，尽管不影响父类自己的 ivar 偏移，却影响了子类的 ivar 偏移 这个就是所谓的在运行期，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局 对于方法的访问与 ivar 的访问不同，是通过 objc_msgSend 找到对应的方法列表，所以可以动态添加方法 那运行时如何给类添加实例变量呢？ 只能在 objc_allocateClassPair 与 objc_registerClassPair 两个函数之间为类添加变量 1234Class class = objc_allocateClassPair(NSObject.class, \"Sark\", 0);class_addIvar(class, \"_girlFriend\", sizeof(id), log2(sizeof(id)), @encode(id));class_addIvar(class, \"_company\", sizeof(id), log2(sizeof(id)), @encode(id));objc_registerClassPair(class); 分类方法的加载与覆盖我们主要探究四个问题： 分类的方法什么时候被添加到本类 分类的方法在运行时会覆盖本类，那么在内存结构中是否覆盖了本类 分类在运行时是怎么覆盖本类方法 如果有多个分类有同名的方法，其调用顺序是怎样的 分类插入本类方法的源码启动时，_objc_init 里面的调用的 map_images 最终会调用 objc-runtime-new.mm 里面的 _read_images 方法有以下的代码片段，我们删除一些无用代码得到 注：如果一个类实现了 +load 方法，那么它就会在启动时被加载，会调用 realizeClass 进行加载，加载后 isRealized 将会返回 true；如果没实现 +load 方法，那么就会懒加载这个类，直到给这个类发送消息时才会去 realizeClass。懒加载和非懒加载处理分类的时机是不一样的，但是原理大致相同。我们这里只讨论类和分类都实现了 +load 的情况，更多情况请参考 iOS 底层探索 - 分类的加载 以下是处理分类的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243// Discover categories. for (EACH_HEADER) &#123; // hi 表示 headerInfo // 从每一个 headerInfo 中获取分类列表以及分类个数 category_t **catlist = _getObjc2CategoryList(hi, &amp;count); // 注意这里的 count 指的是一个头文件定义的分类个数 for (i = 0; i &lt; count; i++) &#123; // 获取分类实例 category_t *cat = catlist[i]; // 获取分类指向的本类 Class cls = remapClass(cat-&gt;cls); // 处理本类不存在的异常 if (!cls) &#123; // 此处省略... continue; &#125; // 开始处理分类 // 第一步，注册分类到本类（addUnattachedCategoryForClass） // 第二步，重建这个类的方法列表（remethodizeClass） // 处理实例方法、协议、属性 if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) &#123; addUnattachedCategoryForClass(cat, cls, hi); if (cls-&gt;isRealized()) &#123; remethodizeClass(cls); &#125; &#125; // 按照同样的逻辑处理类方法、协议、类属性 if (cat-&gt;classMethods || cat-&gt;protocols) &#123; addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi); if (cls-&gt;ISA()-&gt;isRealized()) &#123; remethodizeClass(cls-&gt;ISA()); &#125; &#125; &#125;&#125; 这段代码主要告诉我们，在启动初始化 objc 的时候分类的方法列表会被插到本类的方法中 它主要实现了，遍历所有头文件获取所有分类列表，并对每个分类： 把 category 的实例方法、协议以及属性添加到类上 把 category 的类方法和协议添加到类的 metaclass 上 这里我们只研究实例方法的插入，其他项是同理的 addUnattachedCategoryForClass 只是负责把类和 category 做一个关联映射，并没有修改类的结构，我们暂不关心 真正生效的是 remethodizeClass，它负责重新对方法列表进行排列，但其实也是一个壳，主要调用了 attachCategories 注：由于我们对分类和类写了 +load，所以执行到这里的时候，类已经被加载过了，所以 isRealized 是 true 1234567891011// 重新对方法列表进行排列static void remethodizeClass(Class cls)&#123; category_list *cats; // unattachedCategoriesForClass，我们暂不关心 if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) &#123; attachCategories(cls, cats, true /*flush caches*/); free(cats); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static void attachCategories(Class cls, category_list *cats, bool flush_caches)&#123; if (!cats) return; bool isMeta = cls-&gt;isMetaClass(); // 本类的所有分类的所有方法列表 method_list_t **mlists = (method_list_t **) malloc(cats-&gt;count * sizeof(*mlists)); // 本类的所有分类的所有属性列表 property_list_t **proplists = (property_list_t **) malloc(cats-&gt;count * sizeof(*proplists)); // 本类的所有分类的所有协议列表 protocol_list_t **protolists = (protocol_list_t **) malloc(cats-&gt;count * sizeof(*protolists)); // 方法个数 int mcount = 0; // 属性个数 int propcount = 0; // 协议个数 int protocount = 0; // 分类的个数，这里一般是 1 个，因为参数是每个头文件中的每个分类 int i = cats-&gt;count; bool fromBundle = NO; while (i--) &#123; // 从后往前数，获取每一个分类 auto&amp; entry = cats-&gt;list[i]; // 处理方法 // 获取该分类的所有方法 method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta); if (mlist) &#123; // 并插到临时变量 mlists 的尾部 // 注意分类的遍历顺序，最终会导致分类列表中靠后的分类的方法排在 mlists 前面 mlists[mcount++] = mlist; fromBundle |= entry.hi-&gt;isBundle(); &#125; // 处理属性列表，同理 property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta, entry.hi); if (proplist) &#123; proplists[propcount++] = proplist; &#125; // 处理协议，同理 protocol_list_t *protolist = entry.cat-&gt;protocols; if (protolist) &#123; protolists[protocount++] = protolist; &#125; &#125; // rw 代表原类的信息 auto rw = cls-&gt;data(); // 这里会对同个分类的方法进行排序，比如 test2 排在 test 前面 prepareMethodLists(cls, mlists, mcount, NO, fromBundle); // 将获取到的分类的所有方法，添加到原类的方法前面 rw-&gt;methods.attachLists(mlists, mcount); free(mlists); if (flush_caches &amp;&amp; mcount &gt; 0) flushCaches(cls); rw-&gt;properties.attachLists(proplists, propcount); free(proplists); rw-&gt;protocols.attachLists(protolists, protocount); free(protolists);&#125; 这个方法主要做了两件事，以实例方法为例，属性和协议同理 注意这里虽然是数组，但是一般只有一个类，即 cats-&gt;count = 1 把所有分类的方法读取出来放到一个数组里，越靠后的分类的方法在数组中的位置越靠前 把这个方法数组添加到原类方法的首部，见 attachLists 12345678910111213141516171819202122232425262728293031void attachLists(List* const * addedLists, uint32_t addedCount) &#123; if (addedCount == 0) return; if (hasArray()) &#123; // many lists -&gt; many lists uint32_t oldCount = array()-&gt;count; uint32_t newCount = oldCount + addedCount; setArray((array_t *)realloc(array(), array_t::byteSize(newCount))); array()-&gt;count = newCount; // void *memmove(void *str1, const void *str2, size_t n) 从 str2 复制 n 个字符到 str1 memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0])); memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125; else if (!list &amp;&amp; addedCount == 1) &#123; // 0 lists -&gt; 1 list list = addedLists[0]; &#125; else &#123; // 1 list -&gt; many lists List* oldList = list; uint32_t oldCount = oldList ? 1 : 0; uint32_t newCount = oldCount + addedCount; setArray((array_t *)malloc(array_t::byteSize(newCount))); array()-&gt;count = newCount; if (oldList) array()-&gt;lists[addedCount] = oldList; memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125;&#125; 关于 attachLists 方法，就是分类方法覆盖本类方法的关键所在 首先，我们要明确，每次进入这个方法的参数 addedLists，是指一个分类的所有方法；这个方法实现的是将一个分类的所有方法添加到类结构的方法列表前面（虽然这里的参数可能是一个 method_list_t，不过实测下来这个数组只会有一个元素，因此暂时理解为一个元素） 然后我们看看这里是怎么实现的，这里主要处理如何将一个元素添加进数组，根据数组的情况分为 3 种情况 类的方法列表中没有 method_list_t 时，把单个新增元素这个赋值给指针（0 lists -&gt; 1 list） 类的方法列表中只有一个 method_list_t 时，重新申请内存，把老的第 0 个元素挪到最后，再把新增元素拷贝到最前 类的方法列表中有多个 method_list_t 时，重新申请内存，把老的元素通过 memmove 挪到最后，再把新增元素拷贝到最前 如果一个类自身没有声明方法时，当第一个分类进来的时候就会进到情况 1；再继续处理第二个分类或者本类已经有方法的时候回进入到情况 2，其他会进入情况 3。这一点还是很好理解的，主要看现在的类结构里面有没有方法列表 void *memmove(void *str1, const void *str2, size_t n) 从 str2 复制 n 个字符到 str1 void *memcpy(void *str1, const void *str2, size_t n) 从 str2 复制 n 个字符到 str1 在重叠内存块这方面，memmove() 是比 memcpy() 更安全的方法。如果目标区域和源区域有重叠的话，memmove() 能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，复制后源区域的内容会被更改。如果目标区域与源区域没有重叠，则和 memcpy() 函数功能相同。 加载分类同名方法的源码我们先看看 objc_class 结构中 methodLists 这个二级指针。首先，**methodLists 是个二级指针，它指向的是一个数组，这个数组就是由 objc_method_list 构成，它是一个一维数组，即 *methodLists，如下图 注：在最新的 Runtime 源码中，objc_method_list 被替换为 method_list_t，所以 methodLists 也可以看是 method_list_t 的二级指针 假如本类有 a、b 方法，分类 1 有 a、c、d 方法，分类 2 有 a、e 方法，分类 1 先声明，则 methodLists 的方法列表应该如下 1*methodLists = [[a, e], [a, c, d], [a, b]]; 其中 [a, e]、[a, c, d] 和 [a, b] 都是一个 method_list_t。 从 category_t 的结构中我们可以看出，一个分类拥有一个 method_list_t，即分类本身的方法列表；而本类的方法列表存放的是一个指针，指向的是一个数组，这个数组的元素是 method_list_t 关于这个数据结构的证明我们除了从这篇文章可以得到 二级指针指向的数据结构是什么样的？，也可以从方法的调用中一探究竟 首先，我们看下方法调用的栈 1objc_msgSend -&gt; _class_lookupMethodAndLoadCache3 -&gt; lookUpImpOrForward lookUpImpOrForward 关键代码如下 12345678910111213141516171819IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)// 省略其他代码// 1. 找缓存imp = cache_getImp(cls, sel);if (imp) goto done;// 2. 找本类&#123; Method meth = getMethodNoSuper_nolock(cls, sel); if (meth) &#123; log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls); imp = meth-&gt;imp; goto done; &#125;&#125;// 3. 找父类// 省略其他代码 可以看到先找缓存，再找本类，最后找父类，最关键的是 getMethodNoSuper_nolock，源码如下 12345678910111213141516static method_t *getMethodNoSuper_nolock(Class cls, SEL sel)&#123; runtimeLock.assertLocked(); assert(cls-&gt;isRealized()); for (auto mlists = cls-&gt;data()-&gt;methods.beginLists(), end = cls-&gt;data()-&gt;methods.endLists(); mlists != end; ++mlists) &#123; method_t *m = search_method_list(*mlists, sel); if (m) return m; &#125; return nil;&#125; 注意这里的 methods 是 objc_class 中的结构，是新版本源码，我们这里关于 objc_class 是老的源码，但这并不妨碍我们理解 objc_class 的 methods 是一个二级指针，其指向一个数组，数组的每个元素都是一个 method_list_t * cls-&gt;data()-&gt;methods.beginLists() 返回的是该数组的第一个元素的迭代器（类比 C++ STL 中的 list 的 begin()），对其解引用后可以得到一个 method_list_t *。这个也是 search_method_list 的入参 search_method_list 的源码可以直接简化如下，对这个一维数组进行顺序查找，找到立刻返回 1234567static method_t *search_method_list(const method_list_t *mlist, SEL sel)&#123; for (auto&amp; meth : *mlist) &#123; if (meth.name == sel) return &amp;meth; &#125; return nil;&#125; 总结成一句话就是，方法查找时，从类的 method 列表中开始顺序查找，列表的每个元素是一个 method_list_t，这个结构里面存储着一个分类或本类的方法列表，遍历这个 method_list_t 与调用的方法的名字是否一致，一致则返回 结论 分类的方法什么时候被添加到本类 答：在启动的时候，objc_setup 阶段会进行 objc 类的注册，将分类的方法插到本类的方法列表 分类的方法在运行时会覆盖本类，那么在内存结构中是否覆盖了本类 答：对于 load 方法来说比较特殊，见下节；对于普通方法来说，内存结构中分类的方法并没有覆盖本类，而是插到了本类的方法列表前面 分类在运行时是怎么覆盖本类方法 答：objc_msgSend 时，会从类的方法列表中查找对应的 method，是从头往后查找的，由于分类的方法被插在了本类的方法前面，因此会优先找到，从而达到了覆盖的效果 如果有多个分类有同名的方法，其调用顺序是怎样的 答：分类的顺序是按照在编译选项中的顺序决定的，越靠后的分类的方法会被放到本类方法列表的越前面，会被优先调用到。 如何调试 Runtime可以下载源码 Xcode 11.4 无法编译成功，改为 11.3.1 才可。另外 10.15 系统版本的 Mac 需要选择 Deployment Target 为 10.14 才能编译成功 使用以下源码来判断正在处理哪一个类 1if (strcmp(cls-&gt;data()-&gt;ro-&gt;name, \"Person\") == 0) 相关知识如何为分类添加属性关联对象 分类的 load 方法顺序父类 &gt; 本类 &gt; 分类 分类的 initialize 方法顺序父类 &gt; 本类 &gt; 分类 源码链接 objc_msgSend 汇编源码 objc_object 源码 objc_class 源码（老） 其他相关源码 category_t 定义源码","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"Runtime","slug":"iOS/Runtime","permalink":"http://yoursite.com/categories/iOS/Runtime/"}]},{"title":"","date":"2020-08-15T09:01:57.825Z","path":"iOS/Runtime/关联对象的实现原理/","text":"提问 关联对象被存储在什么地方，是不是存放在被关联对象本身的内存中？ 为什么 AssociationsHashMap 是使用 unordered_map，而 ObjectAssociationMap 使用 map 使用关联对象有什么需要注意的地方 为什么内存管理策略中没有 weak 选项，即 OBJC_ASSOCIATION_WEAK 阅读本文的前提1objc_setAssociatedObject(self, @selector(vn_cellCollectionView), proxy, OBJC_ASSOCIATION_RETAIN_NONATOMIC); 其中 self 我们称之为被关联对象，proxy 我们称之为 关联对象 关键数据结构理解好以下几个结构之后，几乎不需要看源码就能推测 set/get 的原理 AssociationsManager单例，全局唯一 AssociationsHashMapAssociationsManager 的属性，全局唯一 std::unordered_map，存放对象与 ObjectAssociationMap（这里的对象指的是添加属性的分类） ObjectAssociationMapstd::map，存放 key 与 ObjcAssociation ObjcAssociation存放 value 和 policy 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy)&#123; // 初始化一个旧值 ObjcAssociation old_association(0, nil); // acquireValue 会对新的值进行 retain or copy，可以看下下面的源码 id new_value = value ? acquireValue(value, policy) : nil; &#123; // 全局单例 AssociationsManager manager; // 全局的 unordered_map AssociationsHashMap &amp;associations(manager.associations()); // 将被关联对象转化一下，DISGUISE 仅仅对 object 做了位运算 disguised_ptr_t disguised_object = DISGUISE(object); if (new_value) &#123; // 新值不为空，则开始插入 AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; // 如果被关联对象已经在全局的 unordered_map 注册过，则找到对应的 map ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; // map 找到了则记录旧值以备释放，并更新新值 old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); &#125; else &#123; // map 找不到则直接插入 (*refs)[key] = ObjcAssociation(policy, new_value); &#125; &#125; else &#123; // 如果被关联对象没有在全局的 unordered_map 注册过，则创建 map 并注册 ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; // 将值插入到新的 map 中 (*refs)[key] = ObjcAssociation(policy, new_value); _class_setInstancesHaveAssociatedObjects(_object_getClass(object)); &#125; &#125; else &#123; // 新的值为空，准备删除旧值（如果有的话） AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; // 记录旧值等待释放并从 map 中移除 old_association = j-&gt;second; refs-&gt;erase(j); &#125; &#125; &#125; &#125; // 释放旧值（如果需要的话） if (old_association.hasValue()) ReleaseValue()(old_association);&#125; 1234567891011static id acquireValue(id value, uintptr_t policy) &#123; switch (policy &amp; 0xFF) &#123; case OBJC_ASSOCIATION_SETTER_RETAIN: return ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain); case OBJC_ASSOCIATION_SETTER_COPY: return ((id(*)(id, SEL))objc_msgSend)(value, SEL_copy); &#125; return value;&#125; 12// DISGUISE 仅仅对 object 做了位运算inline disguised_ptr_t DISGUISE(id value) &#123; return ~uintptr_t(value); &#125; 解答 关联对象被存储在什么地方，是不是存放在被关联对象本身的内存中？ 关联对象并不是存放在被关联对象本身的内存中，而是存放在一个全局的 unordered_map 中 其中 unordered_map 存储着被关联的对象与 map，其中 map 存放着关联对象的 key 和关联对象 获取关联对象时，首先通过被关联对象的地址找到 map，然后通过关联对象的 key 找到关联对象并返回 为什么 AssociationsHashMap 是使用 unordered_map，而 ObjectAssociationMap 使用 map unordered_map 查找更加高效，大多数情况下应该选择 unordered_map，而 ObjectAssociationMap 使用 map 应该是出于内存考虑 详细可参考 unordered_map 与 map 的区别 使用关联对象有什么需要注意的地方 使用 OBJC_ASSOCIATION_ASSIGN 可能会有野指针，引发 crash，具体可参考 如何为分类添加属性 为什么内存管理策略中没有 weak 选项，即 OBJC_ASSOCIATION_WEAK 如果真的有 weak 选项，我们期望的结果是当被关联对象被释放之后，从关联对象身上取出的“属性”是 nil 首先我们要搞懂 weak 属性的实现原理，简单来说，Runtime 在底层维护一个全局的 weak 表，每次当一个 weak 指针被赋值对象的时候，会将对象地址和 weak 指针地址注册到 weak 表中，其中对象地址作为 key；当对象被废弃时，可根据对象地址快速寻找到指向它的所有 weak 指针，并将 weak 指针置为 nil，同时移出 weak 表 所以，实现 weak 的前提是存在一个 weak 指针指向到被引用对象的地址，而通过对以上源码的研究，我们可以知道关联对象和被关联对象之间并没有这样一个 weak 指针，因此无法实现 OBJC_ASSOCIATION_WEAK p.s. 注意这篇文章的解释是错的 更多阅读 如何为分类添加属性 Objective-C Associated Objects 的实现原理 源码","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"Runtime","slug":"iOS/Runtime","permalink":"http://yoursite.com/categories/iOS/Runtime/"}]},{"title":"","date":"2020-08-15T09:01:57.822Z","path":"iOS/Runtime/weak 的实现原理/","text":"本文解决的问题 weak 的代码实现原理 当对象释放的时候，如何实现将 weak 指针置为 nil weak 指针的线程安全 阅读本文的前提1id __weak weakObj = obj; obj 在本文中称之为【被引用对象】，即 referent weakObj 在本文中称之为【弱引用对象】，即 referrer weak 的代码实现原理以上例子中的代码的 Clang 实现如下 12id weakObj;objc_initWeak(&amp;weakObj, obj); objc_initWeak 源码 12345id objc_initWeak(id *addr, id val) &#123; *addr = 0; // 初始化 weakObj = nil if (!val) return nil; // 判空 return objc_storeWeak(addr, val);&#125; 简化版 objc_storeWeak 源码 1234567891011121314151617181920id objc_storeWeak(id *location, id newObj) &#123; // 获取 oldObj(这个例子中应为 nil) id oldObj = *location; // 获取 oldObj 对应的 SideTable SideTable *oldTable = SideTable::tableForPointer(oldObj); // 获取 newObj 对应的 SideTable SideTable *newTable = SideTable::tableForPointer(newObj); // 从 SideTable 的 weak_table 中移除 oldObj 和它的 weak pointer weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location); // 从 SideTable 的 weak_table 中添加 newObj 和它的 weak pointer newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj, location); // 给 weak 指针赋值 *location = newObj; // 这个例子中返回值外部没用到 return newObj;&#125; 相关类的简化版源码 12345678910111213141516// 全局有若干个 SideTable，并不是和 referent 一一对应，多个 referent 可能共享一个 SideTableclass SideTable &#123;private: static uint8_t table_buf[SIDE_TABLE_STRIPE * SIDE_TABLE_SIZE];public: weak_table_t weak_table; RefcountMap refcnts; // 这个是负责引用计数的 static SideTable *tableForPointer(const void *p) &#123; uintptr_t a = (uintptr_t)p; int index = ((a &gt;&gt; 4) ^ (a &gt;&gt; 9)) &amp; (SIDE_TABLE_STRIPE - 1); return (SideTable *)&amp;table_buf[index * SIDE_TABLE_SIZE]; &#125;&#125;; SideTable *oldTable = SideTable::tableForPointer(oldObj); 可能看完这句代码，我们会错以为 SideTable 和 obj 是一一对应的，其实并不是 SideTable 有一个成员 table_buf，它是 static 的，全局唯一 由 tableForPointer 的源码我们可以知道，只是根据对象的地址来获取 table_buf 中的其中一张 SideTable 由此可见，SideTable 并不是和 obj 对象一一对应，而是全局有多份，多个对象可能共享同一个 SideTable 另外，可以看到 SideTable 还负责相关对象的引用计数 123456789101112131415161718192021// 全局的弱引用表，与 SideTable 一一对应，Key 是 referent，值是该对象相关的所有弱引用信息（即 weak_entry_t）struct weak_table_t &#123; weak_entry_t *weak_entries; // 所有 referent 对应的 weak_entry_t，这是一个数组 size_t num_entries; // 一共有多少个 referent，即 weak_entries 数组的长度 ...&#125;;// 负责维护和存储指向一个对象的所有弱引用 hash 表// 与 referent 一一对应struct weak_entry_t &#123; DisguisedPtr&lt;objc_object&gt; referent; // 即被引用的对象 obj struct &#123; weak_referrer_t *referrers; // 所有弱引用该对象的指针的哈希表 ... &#125;&#125;;// The address of a __weak object reference// typedef struct objc_object *id;// 可以看到 weak_referrer_t 其实就是一个 id 的指针typedef objc_object ** weak_referrer_t; 为了更好的理解 weak_table_t 与 obj 之间的对应关系，我们看下 weak_register_no_lock 的实现 123456789101112131415161718192021222324252627282930313233343536// Adds an (object, weak pointer) pair to the weak table.id weak_register_no_lock(weak_table_t *weak_table, id referent, id *referrer) &#123; ... weak_entry_t *entry; // weak_entry_for_referent 的实现应该是，遍历 weak_entries 数组，寻找并返回与 referent 对应的 weak_entry_t if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; // 如果该 referent 已经存在 weak_entry_t（即在此之前已经有弱引用信息），则添加 referrer 到 weak_entry_t append_referrer(entry, referrer); &#125; else &#123; // 如果该 referent 没有 weak_entry_t（即在此之前没有弱引用信息），则新增 weak_entry_t 到 weak_table weak_entry_t new_entry(referent, referrer); weak_entry_insert(weak_table, &amp;new_entry); &#125; return referent_id;&#125;// Removes an (object, weak pointer) pair from the weak table.void weak_unregister_no_lock(weak_table_t *weak_table, id referent, id *referrer) &#123; if (!referent) return; weak_entry_t *entry; // weak_entry_for_referent 的实现应该是，遍历 weak_entries 数组，寻找并返回与 referent 对应的 weak_entry_t if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; // 如果该 referent 已经存在 weak_entry_t（即在此之前已经有弱引用信息），则从 weak_entry_t 中删除 referrer // remove_referrer 这个方法会把这个 referrer 置为 nil（这个就是 weak 指针自动变 nil 的原因哦） remove_referrer(entry, referrer); // 视情况从 weak_table 中删除 referent 对应的 weak_entry_t ... if (empty) &#123; weak_entry_remove(weak_table, entry); &#125; &#125; // 如果调用正确，理论上 weak_entries 数组应该会有 referent 的 weak_entry_t 信息&#125; 当对象释放的时候，如何实现将 weak 指针置为 nil1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// NSObject.m- (void)dealloc &#123; _objc_rootDealloc(self);&#125;void _objc_rootDealloc(id obj) &#123; obj-&gt;rootDealloc();&#125;void objc_object::rootDealloc() &#123; ... object_dispose((id)this);&#125;id object_dispose(id obj) &#123; if (!obj) return nil; objc_destructInstance(obj); free(obj); return nil;&#125;void *objc_destructInstance(id obj) &#123; if (obj) &#123; bool cxx = obj-&gt;hasCxxDtor(); bool assoc = obj-&gt;hasAssociatedObjects(); if (cxx) object_cxxDestruct(obj); if (assoc) _object_remove_assocations(obj); obj-&gt;clearDeallocating(); &#125; return obj;&#125;// 没找到 clearDeallocating 源码，但是大致实现如下void objc_object::clearDeallocating() &#123; SideTable *table = SideTable::tableForPointer(this); weak_clear_no_lock(&amp;table-&gt;weak_table, (id)this);&#125;void weak_clear_no_lock(weak_table_t *weak_table, id referent_id) &#123; objc_object *referent = (objc_object *)referent_id; // 从 weak_table 中寻找该 referent 对应的 weak_entry_t weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); weak_referrer_t *referrers; size_t count; referrers = entry-&gt;referrers; count = TABLE_SIZE(entry); // 清除所有 referrer 的值 for (size_t i = 0; i &lt; count; ++i) &#123; objc_object **referrer = referrers[i]; if (referrer) &#123; // referrer 指向的值，不出意外应该与 referent 相等 if (*referrer == referent) &#123; // 置空，这个就是为什么 weak 会自动置 nil 的原因 *referrer = nil; &#125; &#125; &#125; // 从 weak_table 中删除对应的 weak_entry_t weak_entry_remove(weak_table, entry);&#125; 可以看到对象释放时会调用 dealloc， 一步步调用到了 clearDeallocating，然后调用 tableForPointer 寻找对应的 SideTable，拿到 weak_table_t 最终调用 weak_clear_no_lock，将所有的 referrer 指向的值（即 weak 指针），置为 nil，并从 weak_table_t 表中删除该对象的 weak_entry_t 通俗解释： 系统会把 weakObj 会放入一个 hash 表中。 用 obj 的内存地址作为 key，当 obj 的引用计数为 0 的时候会执行其 dealloc，此时会在这个 weak 表中搜索，找到所有以 &amp;obj 为 key 的对象，设置为 nil weak 指针的线程安全问题：当一个对象正在 delloc 时，如果在另一个线程获取了 weak 指针，这时获取到的 weak 指针有没有可能是野指针？ 以下的代码例子模拟了这样一个过程，多个线程正在访问 weakObj，其中一个线程对 self.obj 释放了 123456789101112131415161718// @property (nonatomic, strong) NSObject *obj;self.obj = [NSObject new];int n = 500;while (n--)&#123; __weak NSObject *weakObj = self.obj; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; if (n == 480) &#123; self.obj = nil; &#125; int m = 1000; while (m--) &#123; NSLog(@\"%@----%@\", weakObj, @(n)); &#125; &#125;);&#125; 结论：不会挂，不可能是野指针。weak 的访问是线程安全的 123Person *obj = [[Person alloc] init];id __weak weakObj = obj;NSLog(@\"%@\", weakObj); 通过 clang -rewrite-objc MyBlock.c 重写后得到的伪代码 1234567id weakObj;objc_initWeak(&amp;weakObj, obj);// 注意 NSLog(@\"%@\", weakObj) 转为以下代码id tmp = objc_loadWeakRetained(&amp;obj);NSLog(@\"%@\", tmp);objc_release(tmp); 当我们访问 weakObj 的时候，编译器会转为 objc_loadWeakRetained 123456789101112131415161718192021222324252627282930313233343536id objc_loadWeakRetained(id *location)&#123; id obj; id result; Class cls; SideTable *table; retry: obj = *location; if (!obj) return nil; if (obj-&gt;isTaggedPointer()) return obj; table = &amp;SideTables()[obj]; table-&gt;lock(); if (*location != obj) &#123; table-&gt;unlock(); goto retry; &#125; result = obj; cls = obj-&gt;ISA(); if (! cls-&gt;hasCustomRR()) &#123; // 一般情况下会走到这里 if (! obj-&gt;rootTryRetain()) &#123; result = nil; &#125; &#125; else &#123; // 此处省略不重要的代码... &#125; table-&gt;unlock(); return result;&#125; 获取 weak 指针时，会调用 objc_loadWeakRetained 不讨论 isTaggedPointer 这种特殊情况 hasCustomRR 在重写 retain/release/autorelease/retainCount/_tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference 等方法时会返回true，一般情况会返回 false。这里只讨论返回 false 的情况 rootTryRetain 会尝试对该对象进行 retain，里面会判断该对象是否正在 deallocating，如果是则返回 nil 通俗概括以上代码：获取 weak 时调用 objc_loadWeakRetained，获取过程会加锁。如果该对象已经释放或正在释放则返回 nil，否则对该对象进行 retain 并返回。因此我们得出结论：对 weak 指针的访问是线程安全的 那么问题来了，既然有 retian，那什么时候 release 呢？答案是 ARC 下会在 weak 指针访问完成后，自动插 release 代码，如下 1234// 注意 NSLog(@\"%@\", weakObj) 转为以下代码id tmp = objc_loadWeakRetained(&amp;obj);NSLog(@\"%@\", tmp);objc_release(tmp); 参考 Runtime如何实现weak属性？ objc-weak.h 源码 SiteTable 源码 详解获取weak对象的过程","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"Runtime","slug":"iOS/Runtime","permalink":"http://yoursite.com/categories/iOS/Runtime/"}]},{"title":"","date":"2020-08-15T09:01:57.820Z","path":"iOS/Runtime/Runtime_实践/","text":"super 的本质《Objective-C Runtime初探：self super》 123456789101112@interface A : NSObject- (void)f;@end@interface B : A- (void)f;- (void)g;@end@interface C : B- (void)f;@end 1234567891011121314151617181920212223242526272829@implementation A- (void)f&#123; NSLog(@\"A\");&#125;@end@implementation B- (void)f&#123; NSLog(@\"B\");&#125;- (void)g&#123; [self f]; [super f]; NSLog(@\"%@\", [self class]); NSLog(@\"%@\", [super class]);&#125;@end@implementation C- (void)f&#123; NSLog(@\"C\");&#125;@end 请问，下面代码输出什么？ 12C *c = [[C alloc] init];[c g]; 答案：CACC NSObject 分类的 -test 与 Person 的无实现 +test问：假如 Person 类声明了 + (void)test 方法，但是没实现，而 NSObject 的分类实现了 - (void)test 方法；此时调用 Person 的 test 类方法，会发生什么事？ 1234567891011121314// Person.h@interface Person : NSObject+ (void)test; // 没有实现@end// NSObject+Runtime.m@implementation NSObject (Runtime)- (void)test&#123; NSLog(@\"NSObject's test\");&#125;@end[[Person class] test]; // 会发生什么？ 答：虽然 Person 没有实现这个类方法，但是最终会调用 NSObject 的 test 实例方法。 对于类方法，消息发送从 Person 类的 isa 指针指向的元类开始查找方法，沿着继承链向上查找，最终找到 NSObject 元类，找不到，继续查找 NSObject 的类对象，最终发现了 test 方法，进而进行调用 本题的考点是： NSObject 元类的父类就是 NSObject 类对象 查找方法的 Key 是 @selector，并不包括其是实例方法还是类方法；或者说实例方法和类方法的区别就在于查找的继承链，而不在于方法本身 Runtime 怎么添加属性、方法12345class_addIvar // 添加成员变量class_addMethod // 添加方法class_addProperty // 添加属性class_addProtocol // 添加协议class_replaceProperty // 替换属性 需要注意的是，成员变量和属性的区别，详见 方法交换 为什么 Category 中不能动态添加成员变量因为 category_t 的结构中没有含有成员变量的字段，但是含有属性相关的字段，因此虽然无法动态添加成员变量，但是可以动态添加属性 详见：如何为分类添加属性 能否在分类中增加属性不能添加成员变量；不能直接添加属性，但是可以通过 Runtime 的方法添加 因为方法和属性并不“属于”类实例，而成员变量“属于”类实例 因为 Category 在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局。 详见：如何为分类添加属性 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？不能向编译后得到的类中增加实例变量；能向运行时创建的类中添加实例变量； 添加实例变量会影响类结构体中的 objc_ivar_list 和 instance_size 因为编译后的类已经注册在 Runtime 中，类结构体中的 objc_ivar_list 实例变量的链表和 instance_size 实例变量的内存大小已经确定，同时 Runtime 会调用 class_setIvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 引用，所以不能向存在的类中添加实例变量 运行时创建的类是可以添加实例变量，调用 class_addIvar 函数，但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前，原因同上。 类和分类的同名方法 如果分类中有和原有类同名的方法, 会优先调用分类中的方法，即 分类 &gt; 原类 如果多个分类中都有和原类同名的方法, 那么各个分类的方法调用顺序由编译器决定，即 分类1 or 分类2 &gt; 原类 分类和扩展的区别 扩展我们天天使用，既可以添加 @property（一般用来声明私有变量），也可以添加方法（但是没必要） 分类只能添加方法，正确添加 @property 需要用 Runtime 的方法 类扩展是在编译阶段被添加到类中，而类别是在运行时添加到类中 项目中用过 Runtime 吗项目中用过的： Swizzle Method（API 安全性保护，防止崩溃；AOP，VideoReport 的埋点上报、日志） 给分类添加属性（给系统的类添加属性，如 VN 中为 UIView 添加 Cell 信息） 打印类的所有属性值 自己没用过但是知道的： Runtime 如何实现自定义 KVO Runtime 如何实现 weak 属性 实现 NSCoding 的自动归档和自动解档 简单描述下 Runtime 的消息机制分为两个阶段：消息发送和消息转发 消息发送： 当调用实例方法时：通过 isa 指针找到实例对应的类对象，并且在其中的缓存方法列表以及方法列表中进行查询，如果找不到则根据 super_class 指针在父类中查询，直至根类(NSObject 或 NSProxy) 当调用类方法时：通过 isa 指针找到类对象对应的元类并且在其中的缓存方法列表以及方法列表中进行查询，如果找不到则根据 super_class 指针在父类中查询，直至根类(NSObject 或 NSProxy) 如果没有找到对应的 IMP，则进入消息转发流程： 动态方法解析（+resolveInstanceMethod: 或者 +resolveClassMethod:），动态添加方法实现的机会 快速转发（替换消息接收者）（-forwardingTargetForSelector:），替换消息的接收者为其他对象的机会 完整消息转发（-methodSignatureForSelector: &amp;&amp; -forwardInvocation:），可以实现多次转发，转发给多个对象，是第二阶段的扩充 _objc_msgForward 是什么，直接调用它将会发生什么？ _objc_msgForward 是 IMP 类型，当向一个对象发送一条消息，会调用 methodForSelector 方法，但它并没有实现的时候，该方法会返回该 IMP，即 _objc_msgForward，这个 IMP 用于执行消息转发 直接调用会进入消息转发的三个流程 工作遇到的例子1234567SEL commonReceiveSEL = @selector(didReceiveBaseEvent:);if ([myDelegate respondsToSelector:commonReceiveSEL])&#123; void (*commonEventIMP)(id, SEL, id) = (void (*)(id, SEL, id))[self methodForSelector:]; commonReceiveIMP(myDelegate, commonReceiveSEL, nil);&#125; 这个例子中，self 没有实现这个 didReceiveBaseEvent:，应该把 self 改为 myDelegate 但是执行 commonReceiveIMP 时，居然 myDelegate 的方法被正确调用了，正常情况应该是抛错误：doesNotRecognizeSelector: methodForSelector 返回的是方法的 IMP，如果找不到该 IMP，则会返回 _objc_msgforward 这个 IMP _objc_msgforward 调用之后会进入 Runtime 的消息转发流程 项目中有一个 SDK hook 了消息转发流程的第三个阶段，即 methodSignatureForSelector 和 forwardInvocation:，使得 commonReceiveSEL 转发给了 myDelegate 当把这个 SDK 移除之后，果然就抛了 doesNotRecognizeSelector: 的错误 Runtime 如何实现 weak 属性weak 的实现原理 isKindOfClass、isMemberOfClassRuntime 源码 12345678910111213141516// isKindOf 和 isMemberOf 的基本用法和区别Person *person = [[Person alloc] init];BOOL res1 = [person isKindOfClass:[Person class]]; // YESBOOL res2 = [person isMemberOfClass:[Person class]]; // YESBOOL res3 = [person isKindOfClass:[NSObject class]]; // YESBOOL res4 = [person isMemberOfClass:[NSObject class]]; // NO// 由于类也是对象，所以 res5 和 res6BOOL res5 = [[Person class] isKindOfClass:[NSObject class]]; // YESBOOL res6 = [[Person class] isMemberOfClass:[NSObject class]]; // NOBOOL res7 = [[NSObject class] isKindOfClass:[NSObject class]]; // YESBOOL res8 = [[NSObject class] isMemberOfClass:[NSObject class]];// NOBOOL res9 = [[Person class] isKindOfClass:[Person class]]; // NOBOOL res10 = [[Person class] isMemberOfClass:[Person class]]; // NO 其中 res1-res4 展示了 isKindOf 和 isMemberOf 的基本用法和区别；res5、res6 展示了调用者是类对象时也是同理 按照我们的理解，isKindOf/isMemberOf 的调用者是实例对象时，参数应该是类对象；调用者是类对象时，参数应该是元类才比较合理 所以 res7 的输出有点奇怪，而 res8 和 res10 的输出也正常，然而 res9 却和 res7 不一致 我们看下源码 123456789101112131415161718192021222324252627282930313233// 实例方法中的 self 是对象，[self class] 取得的是类对象，所以 cls 只有可能是类对象才有可能相等- (BOOL)isMemberOfClass:(Class)cls&#123; return [self class] == cls;&#125;// 类方法中的 self 是类对象，object_getClass 取得的是类对象的isa指针指向的对象，也就是元类对象，所以 cls 只有是元类对象才有可能相等+ (BOOL)isMemberOfClass:(Class)cls&#123; return object_getClass((id)self) == cls;&#125;// 实例方法中的 self 是对象，[self class] 取得的是类对象// 从当前的类对象开始，向其父类方向查找，直到找到相等或尽头- (BOOL)isKindOfClass:(Class)cls&#123; for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;// 类方法中的 self 是类对象，object_getClass 取得的是类对象的isa指针指向的对象，也就是元类对象// 从当前的元类对象开始，向其父类方向查找，直到找到相等或尽头+ (BOOL)isKindOfClass:(Class)cls&#123; for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125; 关于 res7，当调用者是 [NSObject class] 时，调用的是 + (BOOL)isKindOfClass:(Class)cls；self 是 NSObject 的类对象，object_getClass 返回的是 NSObject 元类，而传入的 cls 是 NSObject 类对象。 第一次判断的时候，比较的对象是 NSObject 元类和 NSObject 类对象，不相等； 第二次判断的时候，取 NSObject 元类的父类，即 NSObject 类对象，与 cls 比较，相等，返回 YES 关于 res9，第一次比较的对象 Person 元类与 Person 类对象；第二次比较的是 NSObject 元类与 Person 类对象；第三次比较的是 NSObject 类对象与 Person 类对象；结束，返回 NO 关于 res8，当调用者是 [NSObject class] 时，调用的是 + (BOOL)isMemberOfClass:(Class)cls；self 是 NSObject 的类对象，object_getClass 返回的是 NSObject 元类，而传入的 cls 是 NSObject 类对象。不相等，返回 NO res10 与 res8 同理","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"Runtime","slug":"iOS/Runtime","permalink":"http://yoursite.com/categories/iOS/Runtime/"}]},{"title":"","date":"2020-08-15T09:01:57.818Z","path":"iOS/Runtime/Runtime/","text":"[TOC] Runtime 脑图 概念Class、id、objc_object 定义源码 objc_class、objc_method 定义源码 category_t 定义源码 实例对象（objc_object）1typedef struct objc_object *id; id 是一个指向 objc_object 的指针 123456789struct objc_object &#123; isa_t isa;&#125;union isa_t &#123; Class cls; // ... 省略其他&#125; 简单点说，objc_object 中包含了 Class 信息 类对象（objc_class）1typedef struct objc_class *Class; Class 是一个指向 objc_class 的指针 在 Objc2.0 之前，objc_class 源码如下 1234567891011121314151617struct objc_class&#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; 然后在 2006 年苹果发布 Objc2.0 之后，objc_class 的定义就变成下面这个样子了 12345struct objc_class : objc_object &#123; Class superclass; cache_t cache; class_data_bits_t bits;&#125; 在 Objc2.0 中，所有的对象都会包含一个isa_t 类型的 isa 指针 objc_class 继承于 objc_object，所以 objc_class 也包含了 isa 指针，故类本身其实也是一个对象，称之为类对象 这意味着，可以像向实例对象发送消息一样，我们可以向类对象发送消息，比如 [Person alloc] class_data_bits_t 存储着类对象的相关数据（比如对象方法、对象成员等等），Objc2.0 之前存储在 objc_class 的信息都放到这里了 当一个对象的实例方法被调用的时候，会通过 isa 找到相应的类，然后在该类的class_data_bits_t 中去查找方法实现 但是在我们调用类方法的时候，类对象的 isa 里面是什么呢？这里为了和对象查找方法的机制一致，遂引入了元类的概念 元类 上图可以看出： Superclass 实例对象之间没有父子关系，有父子关系的是类对象和元类 NSObject 类的父类是 nil 特殊：NSObject 元类的父类是 NSObject 类对象 isa 可以理解“是一个” 实例对象“是一个”类对象，类对象“是一个”元类 特殊：任何元类都“是一个” NSObject 元类 【消息发送】：当一个消息发送给任何一个对象时，将会由对象的 isa 指针开始查找方法，接着沿着 superclass 链向上去查找 【内存布局】：不同实例对象对应的类，父类，元类打印出来的地址相同，因为 main 方法执行之前，类对象和元类对象就被创建 理解好对象、类和元类的关系（为什么需要元类）1Person *p = [[Person alloc] init]; 其中，p 是对象，Person 是类。注意，类本身也是对象，所以我们可以把类叫做类对象 对象的实例方法存放在类对象中，对象是以类对象为模版进行创建 而类对象与元类的关系好比对象和类对象的关系，元类中保存了创建类对象以及类方法所需的所有信息 当你给对象发送消息时，消息是从这个对象的类的方法列表中查找 当你给类发消息时，消息是从这个类的元类的方法列表中查找 到此，我们可以理解，为什么类对象“是一个”元类；也可以理解为什么需要元类这个概念（为了和对象查找方法的机制一致） 类对象和元类对象是唯一的，对象是可以在运行时创建无数个的。而在 main 方法执行之前，类对象和元类对象被创建 引申思考：究竟什么样的数据结构才算对象？每个对象都有一个类，这个是 Objective-C 中关于面向对象的内容 实际上，任何数据结构，只要其内存区域的第一块位置是以指向 Class 的指针都可以被称之为对象 比如 objc_object，Objc2.0 前的 objc_class， Objc2.0 后的 objc_class 123456789101112131415161718// isa_t 展开之后struct objc_object &#123; Class isa;&#125;// Objc2.0 前struct objc_class&#123; Class isa; ...&#125;// Objc2.0 后，继承关系展开之后struct objc_class : objc_object &#123; Class isa; Class superclass; ...&#125; 引申思考：类对象是一个对象，那么元类是对象吗？类对象是 objc_class，它的 isa 指针指向的是一个 objc_class，这就意味着元类是一个 objc_class 描述的结构。由于 objc_class 的第一个位置存放着 Class 指针，所以元类本身也是一个对象！所有的元类的 Class 指针指向的都是根元类 即所有元类的类都是根元类，这个是规则。由于这条规则，根元类（即 NSObject 类的元类）的 isa 指针指向了自己，也就是说根元类是它自己的一个实例 引申思考：objc_object 对应对象，objc_class 对应类对象，那是不是会有 objc_meta_class 对应元类id 是一个指向 objc_object 的指针，Class 是一个指向 objc_class 的指针，由此看，id 对应对象，Class 对应类对象确实没错，id 和 Class 都是开发者层面能接触到的，但是元类开发者并不会接触到，所以没有一个对应的“开发层面的概念”对应元类。 元类本身也是一个对象，是用 objc_class 来描述。 即对象用 objc_object 描述；类对象和元类都是用 objc_class 描述 引申思考：为什么所有元类的 isa 指针直接指向了根元类？这是规定（我猜：指向 nil 或其他地方都没有指向根元类合理），同时元类的 isa 指针不是很重要，因为在现实世界中没人向元类发送消息 引申思考：为什么 NSObject 元类的父类是 NSObject 类对象？因为 NSObject 定义了一系列“抽象方法”，这里面既有实例方法，又有类方法 class class isMemberOfClass isKindOfClass respondsToSelector conformsToProtocol conformsToProtocol methodForSelector instanceMethodForSelector 注意：这些方法中的类方法列表是存放在 NSObject 根元类的数据结构中，但是这些方法是“写”在 NSObject.m 中 定义 NSObject 元类的父类为 NSObject 类对象，导致了所有的实例对象、类对象和元类对象都是 NSObject 类对象的实例（除了 NSObject 类对象自己） NSObject 类对象是万物之根 意义在于，元类对象也能调用 NSObject 的实例方法? 如果一个类的类方法没有被实现，最终会去 NSObject 的实例方法中寻找 对于所有的实例对象，都能够调用到 NSObject 的实例方法 对于所有的类对象和元类对象，都能够调用到 NSObject 的类方法 For all instances, classes and meta-classes in the NSObject hierarchy, this means that all NSObject instance methods are valid. For the classes and meta-classes, all NSObject class methods are also valid. ——引自《What is a meta-class in Objective-C?》 Method（objc_method）12345struct objc_method &#123; SEL method_name; // 方法名（区分方法的标识） char *method_types; // 返回值类型 IMP method_imp; // 方法实现&#125; SEL 与 IMP 的关系类似于 key 与 value 的关系 SEL（objc_selector）123456typedef struct objc_selector *SEL;struct objc_selector &#123; char *name; // 方法名称 char *types; // 返回值类型&#125;; SEL 是一个指向 objc_selector 的指针，可以理解为方法（Method）的 ID IMP 可以理解为函数指针，指向了最终的实现 引申思考：关于重载Objective-C 中不支持函数重载就是因为 SEL 只记录了方法名而没有参数，同时一个类的方法列表中不能存在两个相同的 SEL 引申思考：关于重写不同的类可以有同一个 SEL，这些 SEL 对应着不同的实现 不同类的实例对象执行相同的 SEL 时，会在各自的方法列表中去根据 SEL 去寻找自己对应的 IMP 这使得 OC 可以支持函数重写 比如父类和子类都有 viewDidLoad，父类和子类是两个不同的类对象，同时有相同的 SEL，即 viewDidLoad，而其 IMP 又不一样 1@property SEL selector; Objective-C 中的 selector 是 SEL 的一个实例对象 我们可以用 @selector() 返回的是一个 SEL 类型的方法选择器 方法实现（IMP）1typedef id (*IMP)(id, SEL, ...); 关于函数指针 先了解函数指针的概念 typedef 返回类型(*函数指针名)(参数表) 12345678typedef void (*funPointer)(int); funPointer pFun;void myFun(int a)&#123;print(\"Hello\");&#125; void main() &#123; pFun = myFun; (*pFun)(2); &#125; 所以 IMP 是一个函数指针，指向类似 id FunName(id, SEL, ...){...} 的函数实现 在 Runtime 中，IMP 指向着方法最终实现的内存地址 类缓存（objc_cache）Runtime 中，每当找到一个类的方法时，会放入它的缓存，即 objc_class 中的 objc_cache，以加快下次方法调用时的查找效率 分类（objc_category）123456789struct category_t &#123; const char *name; // 原类名，而不是分类名 // 要扩展的类对象，编译期间是不会定义的，而是在 Runtime 阶段通过 name 对应到对应的类对象 classref_t cls; struct method_list_t *instanceMethods; // 分类中新增的对象方法列表 struct method_list_t *classMethods; // 分类中新增的类方法列表 struct protocol_list_t *protocols; // 分类中新增的协议列表 struct property_list_t *instanceProperties; // 分类中新增的属性列表&#125;; 引申思考：如何在分类中添加属性可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，但不可以添加成员变量 instanceProperties 的存在是我们可以通过 objc_setAssociatedObject 和 objc_getAssociatedObject 向分类中增加实例变量的原因，不过这个和一般的实例变量是不一样的 消息发送（objc_msgSend）一个对象的方法像这样[obj foo]，编译器转成 objc_msgSend(obj, foo) 1id objc_msgSend(id self, SEL op, ...) Runtime 时执行的流程是这样的： 通过 obj 的 isa 指针找到它的类对象（obj 是一个 id，即 objc_object 指针，有 isa 指针） 在类对象的方法列表中寻找 foo（objc_class 的 methodLists） 如果类对象中没到 foo，继续往它的 superclass 中找 一旦找到 foo 这个函数（objc_method），就去执行它的实现 IMP，并转发 IMP 的返回值 如果每次消息传递都沿着继承链，在每个类的 methodLists 查找方法其实效率很低，所以需要缓存，即 objc_class 中的 objc_cache，key 是 objc_method 中的SEL，value 是 objc_method 中的IMP 消息转发（_objc_msgforward）如果消息传递的过程中，沿着继承树查找到最终的根类（NSObject）还是没有对应的方法实现，则会进行消息转发，如果消息转发失败了就回执行 doesNotRecognizeSelector: 方法报unrecognized selector 错 什么是消息转发呢，主要分为以下三个阶段 动态方法解析第一个阶段 Runtime 会调用 +resolveInstanceMethod: 或者 +resolveClassMethod:（取决于是实例方法还是类方法），让你有机会提供一个函数实现。如果你添加了函数并返回YES， 那运行时系统就会重新启动一次消息发送的过程 123456789101112131415161718192021- (void)viewDidLoad &#123; [super viewDidLoad]; [self performSelector:@selector(foo:)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(foo:)) &#123; // 注意参数 fooMethod 这里是作为一个函数指针传递 class_addMethod([self class], sel, (IMP)fooMethod, \"v@:\"); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;void fooMethod(id obj, SEL _cmd) &#123; NSLog(@\"Hello\");&#125; 快速转发（替换消息接收者）如果你错过了第一阶段，则进入第二阶段。Runtime 会调用 forwardingTargetForSelector 给你把这个消息转发给其他对象的机会 123456789- (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (aSelector == @selector(foo)) &#123; return [Person new]; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 完整消息转发最后一步会发送 -methodSignatureForSelector: 消息获得函数的参数和返回值类型。 如果返回nil ，Runtime 则会发出 -doesNotRecognizeSelector: 消息，程序这时也就挂掉了 如果返回了一个函数签名，Runtime 就会创建一个 NSInvocation 对象并发送 -forwardInvocation: 消息给目标对象 123456789101112131415161718192021222324- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; if ([NSStringFromSelector(aSelector) isEqualToString:@\"foo\"]) &#123; // 返回签名，进入 forwardInvocation return [NSMethodSignature signatureWithObjCTypes:\"v@:\"]; &#125; return [super methodSignatureForSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; SEL sel = anInvocation.selector; Person *p = [Person new]; if ([p respondsToSelector:sel]) &#123; [anInvocation invokeWithTarget:p]; &#125; else &#123; [self doesNotRecognizeSelector:sel]; &#125;&#125; 什么是 &quot;v@:&quot;，详细可参见Type Encodings 所以不同与第二阶段，在这个阶段你可以： 把消息存储，在你觉得合适的时机转发出去，或者不处理这个消息。 修改消息的 target，selector，参数等 多次转发这个消息，转发给多个对象 显然在这个阶段，你可以对消息做更多的事情，是第二个阶段的扩充 引申思考：消息转发为什么要三个阶段呢？第一阶段意义在于动态添加方法实现，第二阶段直接把消息转发给其他对象，第三阶段是对第二阶段的扩充，可以实现多次转发，转发给多个对象等 如果只是考虑消息转发的功能，那么只提供最后一个阶段就可以实现，所以这个问题的本质是，为什么要多提供前面两个阶段？ Objective-C 的消息机制与 C++ 等静态编译语言不同，提供动态性的同时必然也牺牲了调用的效率。消息转发的效率必然不如 C++ 的函数调用。 从效率上讲，完整的消息转发效率太低，提供前面两个阶段就是为了让消息能够尽快得到处理；因为三个阶段步骤越往后，处理消息累计开销就越大。 《Objective-C 与 Runtime：为什么是这样？》（R.I.P） Runtime 应用Swizzle Method自定义 KVO 实现给分类添加属性打印类的所有属性值123456789101112131415161718192021222324- (NSString *)description&#123; return [NSString stringWithFormat:@\"%@\", [self properties_values]];&#125;- (NSDictionary *)properties_values&#123; NSMutableDictionary *props = [NSMutableDictionary dictionary]; unsigned int outCount, i; objc_property_t *properties = class_copyPropertyList([self class], &amp;outCount); for (i = 0; i &lt; outCount; i++) &#123; objc_property_t property = properties[i]; const char *char_f = property_getName(property); NSString *propertyName = [NSString stringWithUTF8String:char_f]; id propertyValue = [self valueForKey:propertyName]; if (propertyValue) &#123; [props setObject:propertyValue forKey:propertyName]; &#125; &#125; free(properties); return props;&#125; 可以将 properties_values 方法，写到 NSObject 的分类里，就不需要每个人都写一份 实现 NSCoding 的自动归档和自动解档OC 中归档解档又称为序列化和反序列化 归档/解档需要实现 NSCoding 协议方法，在 NSCoding 协议方法中实现了对每个属性分别进行归档/解档，归档对属性值归档为相应的字段，解档依据相应的字段为对象属性赋值 可以使用 Runtime 的 Ivar *class_copyIvarList 方法获取某个类的属性个数和属性列表。遍历属性列表，可获取每个属性的名字，然后使用 KVC 获取或设置每个属性的值 1234567891011121314151617181920212223242526272829303132333435363738- (void)encodeWithCoder:(NSCoder *)coder&#123; [self code:YES coder:coder];&#125;- (instancetype)initWithCoder:(NSCoder *)coder&#123; if (self = [super init]) &#123; [self code:NO coder:coder]; &#125; return self;&#125;- (void)code:(BOOL)isEncode coder:(NSCoder *)coder&#123; unsigned int outCount = 0; Ivar *ivars = class_copyIvarList([UserModel class], &amp;outCount); for (int i = 0; i &lt; outCount; i++) &#123; Ivar ivar = ivars[i]; const char * name = ivar_getName(ivar); NSString *key = [NSString stringWithUTF8String:name]; id value; if (isEncode) &#123; value = [self valueForKey:key]; [coder encodeObject:value forKey:key]; &#125; else &#123; value = [coder decodeObjectForKey:key]; [self setValue:value forKey:key]; &#125; &#125; free(ivars);&#125; 实现字典和模型的自动转换（MJExtension）用 Runtime 提供的函数遍历 Model 自身所有属性，如果属性在 json 中有对应的值，则将其赋值 核心方法：在 NSObject 的分类中添加方法 12345678910111213141516171819202122232425262728- (instancetype)initWithDict:(NSDictionary *)dict &#123; if (self = [self init]) &#123; NSMutableArray *keys = [NSMutableArray array]; NSMutableArray *attributes = [NSMutableArray array]; unsigned int outCount; objc_property_t *properties = class_copyPropertyList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; objc_property_t property = properties[i]; NSString * propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding]; [keys addObject:propertyName]; NSString * propertyAttribute = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding]; [attributes addObject:propertyAttribute]; &#125; free(properties); for (NSString * key in keys) &#123; if ([dict valueForKey:key] == nil) continue; [self setValue:[dict valueForKey:key] forKey:key]; &#125; &#125; return self;&#125; 热更新（JSPatch）JS 传递字符串给 OC，OC 通过 Runtime 接口调用和替换 OC 方法 参考文章 iOS Runtime详解 神经病院 Objective-C Runtime 入院第一天—— isa 和 Class 《What is a meta-class in Objective-C?》","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"Runtime","slug":"iOS/Runtime","permalink":"http://yoursite.com/categories/iOS/Runtime/"}]},{"title":"","date":"2020-08-15T09:01:57.815Z","path":"iOS/Runtime/iOS 的 initialize 和 load 区别/","text":"[TOC] load initialize 执行次数 1次 每个类会被系统只调用一次，但是由于继承的关系，子类未实现的情况下父类的方法会被多次调用 执行时机 所有运行时需要用到的类在main函数开始执行之前，与这个类是否被用到无关 懒加载，需要使用到具体类的时候才调用 （类或它的子类收到第一条消息之前被调用的，包括实例方法和类方法，如果没收到消息则永远不会调用） 作用 Runtime 交换方法 初始化全局 oc 对象 （普通对象可以在声明的时候初始化） 执行时环境 系统不稳定，许多东西尚未初始化，调用的时候其它类不一定准备好 系统处于正常状态，其他类的方法都能正常调用 （特殊情况：如果在 load 方法调用该类的方法会导致 initalize 提前调用，这种情况系统并不稳定） 调用顺序 1. 顺序：父类-&gt;本类-&gt;分类 2. 分类不会影响本类，分类之间的 load 顺序无法确定 3. 本类没写，系统在加载本类的时候不会调用其父类 4. 不同的类或者分类之间的顺序是按 Compile Sources 来确定 1. 顺序：父类-&gt;本类-&gt;分类 2. 分类的实现会覆盖本类 3. 本类没写，会自动调用父类，所以需要先判断类名 相同点 1. 代码要精简，避免处理复杂逻辑 2 线程安全，不必加锁 3. 开发者不能显式调用，也不能调用 super 4. 最好不要调用其他类的方法 同左 load 中最好不要调用其他类的方法，是因为调用的时候其他类不一定加载好 initialize 中最好不要调用其他类的方法，是因为如果这样做，可能产生循环依赖，比如 A 的 initialize 调用了 B 的方法，导致 B 的 initialize 被调用，而 B 的 initialize 也调用了 A 的方法，此时会有问题（而现实情况的互相依赖可能涉及多个类，一旦出现问题就难以定位） load父类的 load 优先于子类12345678910111213static void schedule_class_load(Class cls)&#123; if (!cls) return; assert(cls-&gt;isRealized()); // _read_images should realize if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return; // Ensure superclass-first ordering schedule_class_load(cls-&gt;superclass); add_class_to_loadable_list(cls); cls-&gt;setInfo(RW_LOADED);&#125; 可以看到，对 cls 的处理过程中，优先递归处理了父类，因此父类的 load 一定比子类的优先调用 本类的 load 优先于分类1234567891011121314151617181920212223242526272829void call_load_methods(void)&#123; static BOOL loading = NO; BOOL more_categories; recursive_mutex_assert_locked(&amp;loadMethodLock); // Re-entrant calls do nothing; the outermost call will finish the job. if (loading) return; loading = YES; void *pool = objc_autoreleasePoolPush(); do &#123; // 1. Repeatedly call class +loads until there aren't any more while (loadable_classes_used &gt; 0) &#123; call_class_loads(); &#125; // 2. Call category +loads ONCE more_categories = call_category_loads(); // 3. Run more +loads if there are classes OR more untried categories &#125; while (loadable_classes_used &gt; 0 || more_categories); objc_autoreleasePoolPop(pool); loading = NO;&#125; 其中 call_class_loads 是调用本类的 load，而 call_category_loads 是调用分类的 load 系统加载本类的时候为什么不会调用父类这里有一点值得探讨：本类没写，系统在加载本类的时候不会调用其父类 探讨这个问题的前提是，父类的 load 方法是存在的，假如没有实现，讨论调用时机是没有意义的 这里可能会误解为，本类没写，其父类的 load 也不会被调用。加载子类的时候，如果子类没有实现 load 方法，那么系统是不会在此时自动调用父类的 load，因为 load 调用是直接获取函数指针来执行，不会像 objc_msgSend 一样会有方法查找的过程，也就不会沿着继承链往上寻找了。但是这个不意味着父类的 load 方法不会被调用，因为父类也是需要被加载的，所以 load 方法也会被调用，所以这里强调的是时机，本类没有写 load 的情况下，系统加载本类的时候不会调用其父类的 load 123456789101112131415161718192021222324static void call_class_loads(void)&#123; int i; // Detach current loadable list. struct loadable_class *classes = loadable_classes; int used = loadable_classes_used; loadable_classes = nil; loadable_classes_allocated = 0; loadable_classes_used = 0; // Call all +loads for the detached list. for (i = 0; i &lt; used; i++) &#123; Class cls = classes[i].cls; // 这里取到的就是 load 方法 load_method_t load_method = (load_method_t)classes[i].method; if (!cls) continue; (*load_method)(cls, SEL_load); &#125; // Destroy the detached list. if (classes) _free_internal(classes);&#125; (*load_method)(cls, SEL_load); 说明，load 方法不是通过 objc_msgSend 调用，而是直接通过函数指针调用，因此不会在此次调用中调用父类实现 initializeinitialize 的正确写法（重要！！！不然有子类的情况下可能会调用多次）假设我想要在 A 的 initialize 方法中打印出自己，如果这样写： 12345678910111213@interface A : NSObject@end@implementation A+ (void)initialize&#123; NSLog(@\"%@\", self);&#125;@end@interface B : A@end@implementation B@end 此时创建一个B对象，输出是 AB 初始化 B 的时候，要先初始化 A，所以输出 A，然后初始化 B，由于 B 没有实现 initialize，所以系统调用了 A 的方法，此时 self 是 B 所以 A 的 initialize 方法应该这样写 1234567+ (void)initialize&#123; if (self == [A class]) &#123; NSLog(@\"%@\", self); &#125;&#125; 此时创建一个B对象，输出是 B initialize 的调用顺序以下关键代码来自 objc-runtime-new.mm，当我们给某个类发送消息时，Runtime 会调用该函数。当类没有初始化会调用 void _class_initialize(Class cls) 对该类进行初始化 123456789101112IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; // 省略部分代码 if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123; // 省略部分代码 _class_initialize(_class_getNonMetaClass(cls, inst)); // 省略部分代码 &#125; // 省略部分代码&#125; _class_initialize 关键代码如下 可以看到优先递归处理了父类，因此父类的 initialize 一定优先于子类 除此之外，从 ((void (*)(Class, SEL))objc_msgSend)(cls, SEL_initialize); 看到，本类的 initialize 是通过 objc_msgSend 进行调用，与普通方法的调用是一样的，如果子类没有实现，那么父类的实现会被调用；如果一个类的分类实现了 initialize 方法，那么就会对这个类中的实现造成覆盖 12345678910111213141516171819202122232425void _class_initialize(Class cls)&#123; // 省略部分代码 Class supercls; BOOL reallyInitialize = NO; supercls = cls-&gt;superclass; if (supercls &amp;&amp; !supercls-&gt;isInitialized()) &#123; _class_initialize(supercls); &#125; if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123; cls-&gt;setInitializing(); reallyInitialize = YES; &#125; if (reallyInitialize) &#123; // 省略部分代码 ((void (*)(Class, SEL))objc_msgSend)(cls, SEL_initialize); // 省略部分代码 &#125; // 省略部分代码&#125; 题目实战Compile Sources 中有以下类，顺序如下 12345678910Daughter.mOther.mFather+Category_2.mSon+Category.mSon.mmain.mOther+Category.mFather+Category_1.mFather.mAppdelegate.m 顾名思义，Father 有是 Son 和 Daughter 的父类，Other 与他们没有继承关系 其中除了 Daughter，其他类都写了 load 方法和 initialize 方法，如下 1234567891011121314151617181920+ (void)load&#123; NSLog(@\"%s %@\", __FUNCTION__, [self class]);&#125;+ (void)initialize&#123; NSLog(@\"%s %@\", __FUNCTION__, [self class]);&#125;// main.mint main(int argc, char * argv[]) &#123; @autoreleasepool &#123; NSLog(@\"Main 函数开始执行\"); Daughter *daugter = [[Daughter alloc] init]; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 输出结果如下： 123456789101112+[Other(Category) initialize] Other+[Other load] Other+[Father(Category_1) initialize] Father+[Father load] Father+[Son(Category) initialize] Son+[Son load] Son+[Father(Category_2) load] Father+[Son(Category) load] Son+[Other(Category) load] Other+[Father(Category_1) load] FatherMain 函数开始执行+[Father(Category_1) initialize] Daughter 类的加载顺序由 Compile Sources 确定，即 Daughter &gt; Other &gt; Son &gt; Father，分类的加载是另外一个时机 第一个加载的类是 Daughter，由于没有实现 load，所以没有任何关于 Daughter 的输出，同时也可以看出，一个类没有实现 load，加载它时不会调用父类的 load 第二个加载的类是 Other，由于在其 load 的中向本类发送了消息，所以导致 initialzie 先于 load 被调用，可以看出，initialize 调用的时机不是在 main 函数之后，而是在向该类发送第一个消息之前；第一行输出是 Other 分类的 initialize 方法， Other 自己的 intialize 永远没机会被调用，是因为分类的 innitialize 会覆盖本类 第三个加载的类是 Son，加载 Son 的时候会优先加载 Father，说明子类的 load 一定是晚于父类；同 Other，Father 优先输出了分类的 initialize，再输出 load，那为什么是 Category_1 而不是 Category_2 的 initialze 呢，因为 Category_2 在 Compile Sources 中是晚于 Category_1，因此覆盖了本类和 Category_1 的方法。即分类的 initialzie 覆盖本类时，以 Compile Sources 中最后一个分类为准 接下来终于轮到 Son 自己加载了，可以看到 Son+Category 的 load 的方法并没有在此时执行，说明分类的 load 确实晚于主类 最后一个要加载的主类是 Father，而由于 Father 刚刚已经加载过了，因此不会再次调用 load 方法，说明一个类的 load 方法系统最多只会调用一次 主类加载完之后，终于轮到分类了，分类的加载顺序取决于其在 Compile Sources 的顺序，而与它们的主类在 Complie Sources 的顺序无关，本例中 Father(Category_2) &gt; Son(Category) &gt; Other(Category) &gt; Father(Category_1) 主类分类加载完毕，开始执行 main 函数。说明类的 load 都是在 main 函数之前 最后在 main 函数中向 Daughter 发送了一个消息，从而触发了 Daughter 的 initialize，可以看出 initialize 是懒加载的；其次，本类没实现 initialize 的时候，系统会自动调用父类的实现 延伸思考为什么分类的 load 方法不会被覆盖本类，而 innitialize 会呢因为 load 的时候 Runtime 还没有初始化完毕；load 的调用是直接函数调用，而 initialize 是属于消息发送，需要依赖 Runtime 分类实现的普通方法，是如何覆盖本类的为什么方法交换要写在 load我们可以从 load 的特点得到： 方法交换调用一次就够了，而 load 只会被系统调用一次 方法交换越早越好，而 load 方法在 main 函数之前就被调用了 但是有这两个原因仍然不足以说明为什么要写在 load，因为 initialize 方法也可以做到一次和越早越好 那么 load 为什么比 initialize 更适合呢，答案是不会有被覆盖的风险，写了就一定会被调用到 写在主类的 initialize 的方法可能被其分类的 initialize 覆盖，而 load 不会 为什么方法交换需要加 dispatch_once，不是说 load 只会执行一次吗load 是线程安全的，最多也被系统调用一次，添加 dispatch_once 完全是为了防止不合格的程序员手动调用 多次交换会有什么问题1234567891011121314151617181920212223242526272829// UIViewController+Category1.m+ (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; swizzleMethod(self, @selector(viewWillAppear), @selector(viewWillAppear_1)); &#125;);&#125;- (void)viewWillAppear_1:(BOOL)animated&#123; NSLog(@\"%s\", __FUNCTION__); [self viewWillAppear_1:animated];&#125;// UIViewController+Category2.m+ (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; swizzleMethod(self, @selector(viewWillAppear), @selector(viewWillAppear_2)); &#125;);&#125;- (void)viewWillAppear_2:(BOOL)animated&#123; NSLog(@\"%s\", __FUNCTION__); [self viewWillAppear_2:animated];&#125; 假如 UIViewController+Category1 的 load 比 UIViewController+Category2 先执行，那么执行此时所有的 UIViewController 即将出现的时候将会调用哪些方法 答案：调用顺序如下 123viewWillAppear_2viewWillAppear_1viewWillAppear 交换之前 123@selector(viewWillAppear) -&gt; viewWillAppear's IMP@selector(viewWillAppear_1) -&gt; viewWillAppear_1's IMP@selector(viewWillAppear_2) -&gt; viewWillAppear_2's IMP 第一次交换：UIViewController+Category1 的 load 123@selector(viewWillAppear) -&gt; viewWillAppear_1's IMP@selector(viewWillAppear_1) -&gt; viewWillAppear's IMP@selector(viewWillAppear_2) -&gt; viewWillAppear_2's IMP 第二次交换：UIViewController+Category2 的 load 123@selector(viewWillAppear) -&gt; viewWillAppear_2's IMP@selector(viewWillAppear_1) -&gt; viewWillAppear's IMP@selector(viewWillAppear_2) -&gt; viewWillAppear_1's IMP 调用 viewWillAppear，执行的是其对应的 IMP， 即 viewWillAppear_2 然后 viewWillAppear_2 的 IMP 里又调用了 @selector(viewWillAppear_2) ，执行的是 viewWillAppear_1 的 IMP 最后 viewWillAppear_1 的 IMP 里又调用了 @selector(viewWillAppear_1) ，执行的是 viewWillAppear 的 IMP load 方法中实现方法交换的时候采用 c 函数swizzleMethod 采用 C 函数，而不是 NSObject 的方法，是为了防止子类在 load 方法中向其自己发送消息，那样会导致其 +initialize 方法在 load 的时候被提前调用，而此时系统环境是不稳定的 参考文章 《Objective-C +load vs +initialize》 《一道题搞清楚Objective-C中load和initialize》 《Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的52个有效方法》第 51 条","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"Runtime","slug":"iOS/Runtime","permalink":"http://yoursite.com/categories/iOS/Runtime/"}]},{"title":"","date":"2020-08-15T09:01:57.810Z","path":"iOS/RunLoop/RunLoop/","text":"[toc] RunLoop 脑图 RunLoop 流程 RunLoop 相关概念Event Loop事件循环模型，实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒 12345678910function loop() &#123; init(); do &#123; var message = get_next_message(); process_message(message); &#125; while (message != quit);&#125; 线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束 RunLoop 就是 OSX/iOS 平台对事件循环模型的实现，在循环中用来处理程序运行过程中出现的各种事件（比如说触摸事件、UI 刷新事件、定时器事件）和消息，从而保持程序的持续运行；而且在没有事件处理的时候，会进入睡眠模式，从而节省 CPU 资源，提高程序性能 NSRunLoop 和 CFRunLoopOSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoop CFRunLoop 是 Core Foundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的 NSRunLoop 是 Foundation 框架内的，提供了面向对象的 API，但是这些 API 不是线程安全的 其中 NSRunLoop 是对 CFRunLoop 的简单封装，需要着重研究的只有 CFRunLoop 更准确的说，代码里面是 CFRunLoopRef，本文统一简称为 CFRunLoop RunLoop 与线程的关系苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数： Core Foundation 框架中的获取方法：CFRunLoopGetMain() 和 CFRunLoopGetCurrent() Foundation 框架中的获取方法：[NSRunLoop mainRunLoop] 和 [NSRunLoop currentRunLoop] 代码逻辑如下： 1234567891011121314151617181920212223242526272829303132333435363738/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic;/// 访问 loopsDic 时的锁static CFSpinLock_t loopsLock; /// 获取一个 pthread 对应的 RunLoop。CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123; OSSpinLockLock(&amp;loopsLock); if (!loopsDic) &#123; // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。 loopsDic = CFDictionaryCreateMutable(); CFRunLoopRef mainLoop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop); &#125; /// 直接从 Dictionary 里获取。 CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread)); if (!loop) &#123; /// 取不到时，创建一个 loop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, thread, loop); /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。 _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop); &#125; OSSpinLockUnLock(&amp;loopsLock); return loop;&#125; CFRunLoopRef CFRunLoopGetMain() &#123; return _CFRunLoopGet(pthread_main_thread_np());&#125; CFRunLoopRef CFRunLoopGetCurrent() &#123; return _CFRunLoopGet(pthread_self());&#125; 从上面的代码可以看出 线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里，但是不代表有线程就有 RunLoop 除了主线程，如果想要获取线程的 RunLoop，只能在当前线程内获取； 除了主线程，如果没有主动获取线程的 RunLoop，则 RunLoop 不会创建 RunLoop 会在线程销毁时销毁 CFRunLoop 是基于 pthread 来管理的 pthread_t 和 NSThread 是一一对应的 可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程； 也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。 RunLoop 的结构结构图 在 CoreFoundation 里面关于 RunLoop 有5个类： CFRunLoopRef CFRunLoopModeRef CFRunLoopSourceRef CFRunLoopTimerRef CFRunLoopObserverRef 一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer（这三个都被称为 Mode Item）。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个 Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响 每次 RunLoop 只会以一种 Mode 运行，以该 Mode 运行的时候，就只执行和该 Mode 相关的任务，只通知该 Mode 注册过的 Observer Mode ItemSource/Timer/Observer 都被称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的 CFRunLoopSourceCFRunLoopSource 是事件产生的地方。 Source有两个版本：Source0 和 Source1 Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件 Source1 是基于 port 的，包含了一个 mach_port 和一个回调（函数指针），可以接收内核消息并触发回调。这种 Source 能主动唤醒 RunLoop 的线程，比如触摸/锁屏/摇晃/点击 CFRunLoopTimerCFRunLoopTimer 是基于时间的触发器，它和 NSTimer 是 toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop 会注册对应的时间点，当时间点到时，RunLoop 会被唤醒以执行那个回调 CFRunLoopObserverCFRunLoopObserver 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个： 12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 事件源 种类图中展现了 RunLoop 在线程中的作用：从 input source 和 timer source 接受事件，然后在线程中处理事件 Run Loop 的处理两大类事件源： Timer Source Input Source performSelector 的方法簇 Port 自定义的 Input Source 事件源缺失的后果如果一个 mode 没有 Source0/Source1/Timer（不管有没有 Observer），则 RunLoop 会直接退出，不进入循环。详搜 __CFRunLoopModeIsEmpty RunLoop Mode种类苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode NSDefaultRunLoopMode(kCFRunLoopDefaultMode) NSConnectionReplyMode NSModalPanelRunLoopMode NSEventTrackingRunLoopMode(UITrackingRunLoopMode) NSRunLoopCommonModes(kCFRunLoopCommonModes) 其中比较重要的模式如下，其他 Mode 不需要管 NSDefaultRunLoopMode：App的默认 Mode，通常主线程是在这个 Mode 下运行的 UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响 NSRunLoopCommonModes：实际上是一个 Mode 的集合，默认包括 NSDefaultRunLoopMode 和 UITrackingRunLoopMode。可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common” Common Modes12345678910111213141516struct __CFRunLoop &#123; CFMutableSetRef _commonModes; // Set CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt; CFRunLoopModeRef _currentMode; // Current Runloop Mode CFMutableSetRef _modes; // Set ...&#125;;struct __CFRunLoopMode &#123; CFStringRef _name; // Mode Name, 例如 @\"kCFRunLoopDefaultMode\" CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ...&#125;; 其中 _commonModes 其实并不是一个真正的模式，可以看到它是 Modes 而不是 Mode，是一个模式的集合 一个 Mode 可以将自己标记为 “Common” 属性，对应的方法是 CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName); 添加 Source/Observer/Timer 时，如果指定的模式为 kCFRunLoopCommonModes，则会被添加 _commonModeItems 中；每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有 Mode 里 kCFRunLoopDefaultMode 默认是 “Common” 的 RunLoop 内部逻辑 流程图源文件 对应源码 其中 poll = 处理了 source0 || 没有超时 此处最好看源码！！！ RunLoop 的底层实现RunLoop 进入休眠时调用的函数是 mach_msg()，实际上是调用了一个 Mach 陷阱 mach_msg_trap()，当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会休眠并监听端口等待唤醒 休眠的具体流程如下： 指定一个将来唤醒自己的mach_port端口 调用 mach_msg 来监听这个端口，保持mach_msg_trap状态 由另一个线程（比如有可能有一个专门处理键盘输入事件的 loop 在后台一直运行）向内核发送这个端口的msg后，mach_msg_trap 状态被唤醒，RunLoop 继续运行 RunLoop 的应用系统应用事件响应（重要）如果发生触摸/锁屏/摇晃/点击等事件，首先是由 Source1 接收 IOHIDEvent，唤醒 RunLoop；之后在 Source1 的回调 __IOHIDEventSystemClientQueueCallback() 内触发 Source0 回调，Source0 的回调内部调用 UIApplication 将事件封装为 UIEvent 并分发出去。所以 UIButton 的点击事件在堆栈中看到是在 Source0 内的 界面更新（重要）setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调执行一个函数：遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面 定时器（重要）一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop 为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 由于 NSTimer 的这种机制，因此 NSTimer 的执行必须依赖于 RunLoop，如果没有 RunLoop，NSTimer 是不会执行的 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行 CADisplayLink 是一个和屏幕刷新率一致的定时器，比 NSTimer 精度更高。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。通常情况下 CADisaplayLink 用于构建帧动画，看起来相对更加流畅，而 NSTimer 则有更广泛的用处 AutoreleasePool（重要） 进入之前，创建 AutoreleasePool（监听 kCFRunLoopEntry） 休眠之前，销毁当前再创建一个新的 AutoreleasePool（监听 kCFRunLoopBeforeWaiting） 退出之前，销毁 AutoreleasePool（监听 kCFRunLoopExit） RunLoop 的实践应用卡顿检测（重要）RunLoop 处理事件的时间主要出在两个阶段： kCFRunLoopBeforeSources 和 kCFRunLoopBeforeWaiting 之间 kCFRunLoopAfterWaiting 之后 我们可以向主线程注册 Observer 观察其 RunLoop 的回调，如果回调时间过长，则认为发生卡顿 这个例子中，RunLoop 的回调用来发送信号量（就像喂食）；子线程则不断等待 RunLoop 发送的信号量并消耗它，最多等待 5 秒（等吃，如果有则吃掉，如果等了太久则不等了，开始哭）；超时发生时，一般 lastActivity 是 kCFRunLoopBeforeSources or kCFRunLoopAfterWaiting（哭一般是因为等待着两个事件） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172@interface RunLoopMonitor()&#123; CFRunLoopObserverRef _observer; // 观察者 dispatch_semaphore_t _semaphore; // 信号量 CFRunLoopActivity _lastActivity; // 状态&#125;@end@implementation RunLoopMonitor+ (instancetype)sharedInstance&#123; static id sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; sharedInstance = [[self alloc] init]; // 开始监听 [self registerObserver]; &#125;); return sharedInstance;&#125;static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123; RunLoopMonitor *instance = [RunLoopMonitor sharedInstance]; // 记录状态值 instance-&gt; _lastActivity = activity; // 发送信号 dispatch_semaphore_signal(instance-&gt;_semaphore);&#125;// 注册一个Observer来监测Loop的状态,回调函数是runLoopObserverCallBack- (void)registerObserver&#123; // 这是在主线程 // 设置Runloop observer的运行环境 CFRunLoopObserverContext context = &#123;0, (__bridge void *)self, NULL, NULL&#125;; // 创建Runloop observer对象，监听所有的状态 _observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;runLoopObserverCallBack, &amp;context); // 将新建的observer加入到当前thread的runloop CFRunLoopAddObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes); // 创建信号，初识信号量为 0 _semaphore = dispatch_semaphore_create(0); // 子线程监控时长 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; // 这里的 while 可以改进为创建一个常驻子线程 while (YES) &#123; // dispatch_semaphore_wait： // 如果信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1； // 如果为0，那么这个函数就阻塞当前线程等待 timeout // 如果等待期间信号量被 dispatch_semaphore_signal 加1了那么就继续向下执行并将信号量减1。 // 如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句 // 返回值为 0 则表示在规定时间内等到了 // 返回值不为 0 则代表在规定时间内也没收到信号，超时了 long ret = dispatch_semaphore_wait(self-&gt;_semaphore, dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_MSEC)); if (ret != 0) &#123; if (self-&gt; _lastActivity == kCFRunLoopBeforeSources || self-&gt; _lastActivity == kCFRunLoopAfterWaiting) &#123; NSLog(@\"超过 5 秒没有收到信号了\"); &#125; &#125; &#125; &#125;);&#125;@end RunLoop实战：实时卡顿监控 关于dispatch_semaphore的使用 滚动时延迟加载图片？（重要）当设置图片的时候，让其在 CFRunLoopDefaultMode 下进行 1[self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@\"imgName\"] afterDelay:3.0 inModes:@[NSDefaultRunLoopMode]]; 上面的代码可以达到如下效果：用户点击屏幕，在主线程中，三秒之后显示图片。但是当用户点击屏幕之后，如果此时用户开始滚动，那么就算过了三秒，图片也不会显示出来，当停止滚动才会显示图片。 这是因为 setImage 只能在 NSDefaultRunLoopMode 模式下使用，当滚动 tableView 的时候，RunLoop 是在 UITrackingRunLoopMode 这个 Mode 下，就不会设置图片，当停止的时候才切回 NSDefaultRunLoopMode 另一个例子，怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作？ 当我们在子请求数据的同时滑动浏览当前页面，如果数据请求成功要切回主线程更新UI，那么就会影响当前正在滑动的体验。我们就可以将更新UI事件放在主线程的 NSDefaultRunLoopMode 上执行即可，这样就会等用户不再滑动页面，主线程 RunLoop 由 UITrackingRunLoopMode 切换到 NSDefaultRunLoopMode 时再去更新UI 1[self performSelectorOnMainThread:@selector(reloadData) withObject:nil waitUntilDone:NO modes:@[NSDefaultRunLoopMode]]; 但是这里的问题是 modes 不指定的时候，就是 DefaultMode 呀，引用官方文档 This method sets up a timer to perform the aSelector message on the current thread’s run loop. The timer is configured to run in the default mode (NSDefaultRunLoopMode) Timer 滚动没回调（重要）NSTimer 在 ScrollView 滚动的时候没有回调，如何解决呢 主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 默认都是 Common Mode DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态 当你创建一个 Timer，默认是被加到 DefaultMode，Timer 正常情况下会得到重复回调，但此时滑动一个 ScrollView 时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调。因为 RunLoop 运行时只能指定一个 Mode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。TrackingRunLoopMode 下，处在 DefaultMode 的 Timer 是不会被通知到的 解决方法是将 Timer 加到 CommonModes 中去 123456789101112// 这种创建方法默认不会加到任何 RunLoopNSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(run) userInfo:nil repeats:YES];// 如果这样写，滚动时 NSTimer 不会回调// [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];// 滚动时 NSTimer 会回调// 解决方法 1：添加到 CommonModes[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];// 解决方法 2：手动添加到 TrackingMode[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];[[NSRunLoop mainRunLoop] addTimer:timer forMode:UITrackingRunLoopMode]; 也可以使用 GCD 定时器，它不会受 RunLoop 的影响 PerformSelector &amp;&amp; 子线程启动 Timer 失效（重要）当调用 NSObject 的 performSelector:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效 123456dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; // 如果只写以下一行代码不会生效，本质是生成一个 Timer 添加到 RunLoop [self performSelector:@selector(run) withObject:nil afterDelay:0]; // 必须手动开启 RunLoop Timer 才能生效 [[NSRunLoop currentRunLoop] run];&#125;); 子线程的 RunLoop 默认不开启，必须手动开启 123456789101112131415161718192021dispatch_queue_t queue = dispatch_queue_create(\"test\", DISPATCH_QUEUE_SERIAL);// 在子线程中使用定时器dispatch_async(queue, ^&#123; // 第一种方式 // 创建的 timer 已经添加至当前的 runloop 中 [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(doSomething) userInfo:nil repeats:YES]; // 在线程中使用定时器，如果不启动run loop，timer的事件是不会响应的，而子线程中runloop默认没有启动 // 让线程执行一个周期性的任务，如果不启动run loop， 线程跑完就可能被系统释放了 [[NSRunLoop currentRunLoop] run];// 如果没有这句，doSomething将不会执行！！！ /*************************************************************/ // 第二种方式 // 创建的 timer 没有默认添加到 runloop 中 NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(doSomething) userInfo:nil repeats:NO]; // 将定时器添加到runloop中 [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; // 在线程中使用定时器，如果不启动run loop，timer的事件是不会响应的，而子线程中runloop默认没有启动 // 让线程执行一个周期性的任务，如果不启动run loop， 线程跑完就可能被系统释放了 [[NSRunLoop currentRunLoop] run];// 如果没有这句，doSomething将不会执行！！！&#125;); 子线程常驻（重要）当我们使用 GCD 的方法创建了子线程，那么当子线程中的任务执行完毕后，子线程就会被销毁掉 如果我们需要经常在子线程中执行此任务，只使用 GCD 会导致线程的频繁创建和销毁，此时我们就需要保证一个子线程的常驻 12345678dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; // 通过访问 RunLoop 来创建子线程的一个 RunLoop NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; // 向该RunLoop中添加一个Port/Source等维持RunLoop的事件循环 [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; // 启动 RunLoop [runLoop run];&#125;; 此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息 以下是 AFNetWorking 的 RunLoop 示例代码 123456789101112131415161718+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@\"AFNetworking\"]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; &#125;&#125; + (NSThread *)networkRequestThread &#123; static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^&#123; _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; &#125;); return _networkRequestThread;&#125; 深度好文我的脑图 深入理解RunLoop iOS RunLoop详解 RunLoop 源码剖析 关于runloop，好多人都理解错了！ RunLoop 源码","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"RunLoop","slug":"iOS/RunLoop","permalink":"http://yoursite.com/categories/iOS/RunLoop/"}]},{"title":"","date":"2020-08-15T09:01:57.808Z","path":"iOS/RunLoop/RunLoop 源码分析/","text":"[TOC] 本文对应的源码地址——CFRunLoop.h本文对应的源码地址——CFRunLoop.c 数据结构CFRunLoop12345678struct __CFRunLoop &#123; pthread_t _pthread; // RunLoop 对应的线程 CFMutableSetRef _commonModes; // CommonMode 的集合 CFMutableSetRef _commonModeItems; // CommondModeItem 的集合 CFRunLoopModeRef _currentMode; // 当前的 Mode CFMutableSetRef _modes; // 该 RunLoop 包含的 Mode ...&#125;; RunLoop 与线程一一对应 CommonModes 是一个集合，CommondModeItem 也是一个集合 虽然 RunLoop 可以包含多个 Modes，但是 currentMode 只能有一个，即在同一个时间只能指定一种 Mode 运行 CFRunLoopMode12345678910typedef struct __CFRunLoopMode *CFRunLoopModeRef;struct __CFRunLoopMode &#123; CFStringRef _name; // Mode 的名称 CFMutableSetRef _sources0; // Source0 集合 CFMutableSetRef _sources1; // Source1 集合 CFMutableArrayRef _observers; // Observer 数组 CFMutableArrayRef _timers; // Timer 数组 ...&#125;; CFRunLoopModeRef 是指向 __CFRunLoopMode 的指针，我们只需要研究 __CFRunLoopMode 即可 CFRunLoop 管理了 CFRunLoopModeRef 的集合 CFRunLoopModeRef 包含了 Source0/Source1 的集合；以及 Observer/Timer 的数组（为什么 Source 是集合，Observer/Timer 是数组？） Source0/Source1 的类型是 CFRunLoopSource（虽然上面代码看不出来） CFRunLoopSource12345678910111213141516171819202122struct __CFRunLoopSource &#123; CFMutableBagRef _runLoops; // 一个 Source 可以被加入到多个 RunLoop union &#123; CFRunLoopSourceContext version0; // Source0 CFRunLoopSourceContext1 version1; // Source1 &#125; _context;&#125;;typedef struct &#123; CFIndex version; // 区分是 Source0 还是 Source1 void (*schedule)(void *info, CFRunLoopRef rl, CFStringRef mode); void (*cancel)(void *info, CFRunLoopRef rl, CFStringRef mode); void (*perform)(void *info); ...&#125; CFRunLoopSourceContext;typedef struct &#123; CFIndex version; // 区分是 Source0 还是 Source1 mach_port_t (*getPort)(void *info); // Source1 是基于 Port void * (*perform)(void *msg, CFIndex size, CFAllocatorRef allocator, void *info); ...&#125; CFRunLoopSourceContext1; 一个 Source 可以被加入到多个 RunLoop CFRunLoopSource 包含了 Source0/Source1，union 中所有成员变量的起始地址都是一样的，Source0 和 Source 共占同一段内存的结构，_context 变量的大小取决于 Source0 和 Source1 的最大大小 Source0 比 Source1 多了 schedule 和 cancle 方法？；而 Source1 比 Source0 多了接受 Port 消息的方法。所以说 Source1 是基于 Port 的 CFRunLoopObserver123456struct __CFRunLoopObserver &#123; CFRunLoopRef _runLoop; // Observer 所在的 RunLoop CFIndex _rlCount; // Observer 当前监测的 RunLoop 数 CFOptionFlags _activities; // Observer 可以回调给监听者的时间点 ...&#125;; 一个 Observer 只能监听一个 RunLoop 其中 rlCount 是用来更新 runloop 的值（如果 Observer 添加到 A，B，再从 A 中移除，此时是有问题的，Observer 的 runloop 仍然指向 A？） 12345678910111213141516171819static void __CFRunLoopObserverSchedule(CFRunLoopObserverRef rlo, CFRunLoopRef rl, CFRunLoopModeRef rlm) &#123; __CFRunLoopObserverLock(rlo); // 如果一个 Observer 被添加到多个 RunLoop，则只有第一个会生效 if (0 == rlo-&gt;_rlCount) &#123; rlo-&gt;_runLoop = rl; &#125; rlo-&gt;_rlCount++; __CFRunLoopObserverUnlock(rlo);&#125;static void __CFRunLoopObserverCancel(CFRunLoopObserverRef rlo, CFRunLoopRef rl, CFRunLoopModeRef rlm) &#123; __CFRunLoopObserverLock(rlo); rlo-&gt;_rlCount--; // 如果一个 Observer 没有监听任何 RunLoop，则重置 _runLoop if (0 == rlo-&gt;_rlCount) &#123; rlo-&gt;_runLoop = NULL; &#125; __CFRunLoopObserverUnlock(rlo);&#125; CFOptionFlags 是枚举值，包含以下时间点 123456789typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 开始进入 kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 休眠唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 结束退出 kCFRunLoopAllActivities = 0x0FFFFFFFU&#125;; CFRunLoopTimer12345678910struct __CFRunLoopTimer &#123; uint16_t _bits; // Timer 的状态(firing、fired-during-callout、waking) CFRunLoopRef _runLoop; // 所在的 RunLoop CFMutableSetRef _rlModes; // 所在的 Mode 集合 CFAbsoluteTime _nextFireDate; // 下一次触发时机=当前时间+interval CFTimeInterval _interval; // 理想的触发间隔 CFTimeInterval _tolerance; // 时间偏差 CFRunLoopTimerCallBack _callout; // Timer 的回调 ...&#125;; 一个 Timer 可以被添加到多个 Mode bits 字段表示 Timer 的状态，主要有 0:firing、1:fired-during-callout、2:waking？ nextFireDate 和 interval：一个 Timer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点，这里 interval 就是 10 秒。nextFireDate 依次是 10:00, 10:10, 10:20 tolerance：RunLoop 为了节省资源，并不会在非常准确的时间点回调这个 Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行 CFRunLoopDoTimers123456789101112131415161718192021222324252627282930313233/*limitTSR：终止时间，如果 timer 下一次触发时间超过这个值，则 timer 不会生效*/static Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR)&#123; Boolean timerHandled = false; CFMutableArrayRef timers = NULL; // 1. 遍历 rlm 的所有 Timer，取出下一次触发时间小于当前系统时间的 Timer 组成数组 for (CFIndex idx = 0, cnt = rlm-&gt;_timers ? CFArrayGetCount(rlm-&gt;_timers) : 0; idx &lt; cnt; idx++) &#123; CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm-&gt;_timers, idx); if (__CFIsValid(rlt) &amp;&amp; !__CFRunLoopTimerIsFiring(rlt)) &#123; if (rlt-&gt;_fireTSR &lt;= limitTSR) &#123; if (!timers) timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeArrayCallBacks); CFArrayAppendValue(timers, rlt); &#125; &#125; &#125; // 2. 对该数组的 Timer 进行遍历，调用 __CFRunLoopDoTimer(rl, rlm, rlt); for (CFIndex idx = 0, cnt = timers ? CFArrayGetCount(timers) : 0; idx &lt; cnt; idx++) &#123; CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(timers, idx); Boolean did = __CFRunLoopDoTimer(rl, rlm, rlt); timerHandled = timerHandled || did; &#125; if (timers) CFRelease(timers); return timerHandled;&#125; limitTSR 这里传的是 mach_absolute_time()，该函数返回一个基于系统启动后的时钟嘀嗒数，表示当前系统时间 精简伪代码 12345static Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR)&#123; 1. 遍历 rlm 的所有 Timer，取出下一次触发时间小于当前系统时间的 Timer 组成数组 2. 对该数组的 Timer 进行遍历，调用 __CFRunLoopDoTimer(rl, rlm, rlt);&#125; CFRunLoopDoTimer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127static Boolean __CFRunLoopDoTimer(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt)&#123; Boolean timerHandled = false; uint64_t oldFireTSR = 0; if (__CFIsValid(rlt) &amp;&amp; rlt-&gt;_fireTSR &lt;= mach_absolute_time() &amp;&amp; !__CFRunLoopTimerIsFiring(rlt) &amp;&amp; rlt-&gt;_runLoop == rl) &#123; // interval = 0 的 Timer 都是一次性的 Boolean doInvalidate = (0.0 == rlt-&gt;_interval); // 设置正在 fire 的标志位 __CFRunLoopTimerSetFiring(rlt); // 记录本次的调用时间，待会用到 oldFireTSR = rlt-&gt;_fireTSR; // 计算下一次 Timer 应该触发的时机并注册对应的 timer（mk_timer or GCD Timer） __CFArmNextTimerInMode(rlm, rl); // 调用 timer 的回调 __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt-&gt;_callout, rlt, context_info); // 如果 timer 如果 interval 为 0，则移除 timer（无论是不是 repeat，只要 interval 为 0 就只调用一次） if (doInvalidate) &#123; CFRunLoopTimerInvalidate(rlt); &#125; timerHandled = true; // 取消 fire 的标志位 __CFRunLoopTimerUnsetFiring(rlt); &#125; // 非一次性 Timer 在执行回调之后需要更新 fireTSR 和 nextFireDate if (__CFIsValid(rlt) &amp;&amp; timerHandled) &#123; if (oldFireTSR &lt; rlt-&gt;_fireTSR) &#123; // 如果刚刚在 Timer 的回调期间，调整了该 Timer（调整的结果就是这个 timer 的 fireTSR 一定会变大） // 这种情况下如果此时该 Timer 依然是最小的，那么刚刚的 __CFArmNextTimerInMode 的计算就是错的 // 因为该 Timer 被设置了 fire 而被忽略，没有纳入计算 // 所以这里补充一次重新计算 __CFArmNextTimerInMode(rlm, rl); &#125; else &#123; uint64_t nextFireTSR = 0LL; uint64_t intervalTSR = 0LL; // 确保 intervalTSR 不会超过最大值 if (rlt-&gt;_interval &lt;= 0.0) &#123; // 如果在 Timer 回调期间修改了 interval，可能会走到这里，do nothing &#125; else if (TIMER_INTERVAL_LIMIT &lt; rlt-&gt;_interval) &#123; intervalTSR = __CFTimeIntervalToTSR(TIMER_INTERVAL_LIMIT); &#125; else &#123; intervalTSR = __CFTimeIntervalToTSR(rlt-&gt;_interval); &#125; // 计算下一次触发时间 if (LLONG_MAX - intervalTSR &lt;= oldFireTSR) &#123; // 如果 interval 很大很大，超过上限 nextFireTSR = LLONG_MAX; &#125; else &#123; if (intervalTSR == 0) &#123; // 一般不可能走到，只是为了防止死循环 CRSetCrashLogMessage(\"A CFRunLoopTimer with an interval of 0 is set to repeat\"); HALT; &#125; uint64_t currentTSR = mach_absolute_time(); nextFireTSR = oldFireTSR; // 确保下次触发的时间一定大于当前时间（每次增加 interval 的倍数） while (nextFireTSR &lt;= currentTSR) &#123; nextFireTSR += intervalTSR; &#125; &#125; // 更新 fireTSR 和 nextFireDate CFRunLoopRef rlt_rl = rlt-&gt;_runLoop; if (rlt_rl) &#123; // 如果 Timer 是在 RunLoop 里，则更新了 fireTSR 和 nextFireDate 之后 // 需要对 RunLoop 的每个包含该 Timer 的 Mode 的 Timers 重新排序 CFIndex cnt = CFSetGetCount(rlt-&gt;_rlModes); STACK_BUFFER_DECL(CFTypeRef, modes, cnt); CFSetGetValues(rlt-&gt;_rlModes, (const void **)modes); // 寻找包含了该 Timer 的 Mode for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123; CFStringRef name = (CFStringRef)modes[idx]; modes[idx] = (CFTypeRef)__CFRunLoopFindMode(rlt_rl, name, false); &#125; // 更新自己 rlt-&gt;_fireTSR = nextFireTSR; rlt-&gt;_nextFireDate = CFAbsoluteTimeGetCurrent() + __CFTimeIntervalUntilTSR(nextFireTSR); // 排序 for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123; CFRunLoopModeRef rlm = (CFRunLoopModeRef)modes[idx]; if (rlm) &#123; // 对 mode 中的 timer 重新排序 __CFRepositionTimerInMode(rlm, rlt, true); &#125; &#125; &#125; else &#123; // 没有 RunLoop，更新自己即可 rlt-&gt;_fireTSR = nextFireTSR; rlt-&gt;_nextFireDate = CFAbsoluteTimeGetCurrent() + __CFTimeIntervalUntilTSR(nextFireTSR); &#125; &#125; &#125; return timerHandled;&#125; 触发 Timer 的回调；更新此 Timer 的下一次触发时间；同时对包含该 Timer 的 Mode 的 Timers 重新排序 对于重复的 Timer，其多次触发的时刻不是一开始算好的，而是 Timer 触发后计算的。但是计算时参考的是上次应当触发的时间 _fireTSR（而不是当前时间），因此计算出的下次触发的时刻不会有误差。这保证了 Timer 不会出现误差叠加。比如本来 5 秒触发一次，第一次却延迟到第 7 秒才触发，但是第二次依然在 10 秒触发，而不是 12 秒。具体可以看 _fireTSR 的赋值是由 nextFireTSR 决定，而 nextFireTSR 是由上一次的 _fireTSR 决定 对于重复的 Timer，如果 RunLoop 很忙，那么 Timer 的一些回调可能被忽略。当 RunLoop 不忙了，开始处理 Timer 的时候，即上述函数，此时因为 nextFireTSR 的是一定要比当前时间晚，所以小于当前时间的触发时机都会被忽略，比如本来 5 秒触发一次，第一次在第 5 秒时正常触发，第二次却延迟到了第 16 秒才触发，那么第 15 秒的触发就会被取消，第三次应该触发的时机是 20 秒，如下图和代码 1234while (nextFireTSR &lt;= currentTSR)&#123; nextFireTSR += intervalTSR;&#125; CFArmNextTimerInMode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103static void __CFArmNextTimerInMode(CFRunLoopModeRef rlm, CFRunLoopRef rl)&#123; uint64_t nextHardDeadline = UINT64_MAX; uint64_t nextSoftDeadline = UINT64_MAX; if (rlm-&gt;_timers) &#123; // Timers 是按照 softDeadline 排序 // 遍历 Timers，计算 Mode 的 softDeadLine 和 hardDeadLine // softDeadline 是理应触发的时间；hardDeadline 是理应触发的时间加上 tolerance // 即计算下一次应该触发 Timer 的精准时机和模糊时机（这两个时机不一定来自同一个 Timer） for (CFIndex idx = 0, cnt = CFArrayGetCount(rlm-&gt;_timers); idx &lt; cnt; idx++) &#123; CFRunLoopTimerRef t = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm-&gt;_timers, idx); // 如果正在调用则过滤，详见 __CFRunLoopDoTimer if (__CFRunLoopTimerIsFiring(t)) continue; int32_t err = CHECKINT_NO_ERROR; // softDeadline 是理应触发的时间；hardDeadline 是理应触发的时间加上 tolerance uint64_t oneTimerSoftDeadline = t-&gt;_fireTSR; uint64_t oneTimerHardDeadline = check_uint64_add(t-&gt;_fireTSR, __CFTimeIntervalToTSR(t-&gt;_tolerance), &amp;err); if (err != CHECKINT_NO_ERROR) oneTimerHardDeadline = UINT64_MAX; // Timers 是按照 softDeadline 排序，如果此时 softDeadline 已经很大 // 说明下一次的触发时机一定跟这个 Timer 无关，因此可以跳过 // oneTimerSoftDeadline &gt; nextHardDeadline &gt;= nextSoftDeadline if (oneTimerSoftDeadline &gt; nextHardDeadline) &#123; break; &#125; // 找最小的那个 if (oneTimerSoftDeadline &lt; nextSoftDeadline) &#123; nextSoftDeadline = oneTimerSoftDeadline; &#125; if (oneTimerHardDeadline &lt; nextHardDeadline) &#123; nextHardDeadline = oneTimerHardDeadline; &#125; &#125; if (nextSoftDeadline &lt; UINT64_MAX &amp;&amp; (nextHardDeadline != rlm-&gt;_timerHardDeadline || nextSoftDeadline != rlm-&gt;_timerSoftDeadline)) &#123; // leeway = tolerance（这个 tolerance 可能是两个 Timer 的 deadline 相减得到） uint64_t leeway = __CFTSRToNanoseconds(nextHardDeadline - nextSoftDeadline); dispatch_time_t deadline = __CFTSRToDispatchTime(nextSoftDeadline); if (leeway &gt; 0) &#123; // 如果有 tolerance，则取消 mk_timer if (rlm-&gt;_mkTimerArmed &amp;&amp; rlm-&gt;_timerPort) &#123; AbsoluteTime dummy; mk_timer_cancel(rlm-&gt;_timerPort, &amp;dummy); rlm-&gt;_mkTimerArmed = false; &#125; // 底层通过 dispatch_source_set_timer 注册 timer _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, deadline, DISPATCH_TIME_FOREVER, leeway); rlm-&gt;_dispatchTimerArmed = true; &#125; else &#123; // 如果没有 tolerance，则取消 dispatch timer if (rlm-&gt;_dispatchTimerArmed) &#123; // Cancel the dispatch timer _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 888); rlm-&gt;_dispatchTimerArmed = false; &#125; // 注册 mk_timer if (rlm-&gt;_timerPort) &#123; mk_timer_arm(rlm-&gt;_timerPort, __CFUInt64ToAbsoluteTime(nextSoftDeadline)); rlm-&gt;_mkTimerArmed = true; &#125; &#125; &#125; else if (nextSoftDeadline == UINT64_MAX) &#123; // nextSoftDeadline &lt;= nextHardDeadline，因此 nextHardDeadline 也是 UINT64_MAX // 走到这里说明没有合法的 Timer 可以被下次 RunLoop 调用 // 取消所有类型的 Timer if (rlm-&gt;_mkTimerArmed &amp;&amp; rlm-&gt;_timerPort) &#123; AbsoluteTime dummy; mk_timer_cancel(rlm-&gt;_timerPort, &amp;dummy); rlm-&gt;_mkTimerArmed = false; &#125; if (rlm-&gt;_dispatchTimerArmed) &#123; _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 333); rlm-&gt;_dispatchTimerArmed = false; &#125; &#125; &#125; rlm-&gt;_timerHardDeadline = nextHardDeadline; rlm-&gt;_timerSoftDeadline = nextSoftDeadline;&#125; 首先要知道 Mode 的 Timers 是按照 softDeadline 排序； 该函数通过遍历 Mode 下的所有 Timer，计算出下一次应该触发 Timer 的 softDeadline 和 hardDeadline（这两个时机不一定来自同一个 Timer）； 如果有 tolerance ，则注册一个 GCD Timer；否则注册一个 mk_timer RunLoop 的入口在 Core Foundation 中我们可以通过以下2个 API 来让 RunLoop 运行 在默认的 mode 下运行当前线程的 RunLoop 123456void CFRunLoopRun(void) &#123; int32_t result; do &#123; result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false); &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);&#125; 在指定 mode 下运行当前线程的 RunLoop 123SInt32 CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123; return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);&#125; 虽然 RunLoop 有很多个 mode，但是 RunLoop 在 run 的时候必须只能指定其中一个 mode，运行起来之后，被指定的 mode 即为 currentMode CFRunLoopRunSpecific123456789101112131415161718192021222324252627282930313233SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)&#123; // 是否已经析构 if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished; CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false); // 判断指定的 Mode 存不存在，或者 ModeItem 是不是空的 if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123; return kCFRunLoopRunFinished; &#125; // 备份上一个 Mode 的数据 volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl); CFRunLoopModeRef previousMode = rl-&gt;_currentMode; rl-&gt;_currentMode = currentMode; int32_t result = kCFRunLoopRunFinished; // 如果注册了对应的 Observer，则通知即将进入 RunLoop if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry); // 真正处理 RunLoop result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode); // 如果注册了对应的 Observer，则通知即将结束 RunLoop if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit); // 恢复上一个 Mode 的数据 __CFRunLoopPopPerRunData(rl, previousPerRun); rl-&gt;_currentMode = previousMode; return result;&#125; 如果一个 RunLoop Mode 是空的，则 __CFRunLoopModeIsEmpty 这一步就会返回 true 而导致 RunLoop 退出 通知 Observer 即将进入和即将退出的代码可以在这里找到 CFRunLoopModeIsEmpty12345678910111213141516171819202122232425262728293031323334353637static Boolean __CFRunLoopModeIsEmpty(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopModeRef previousMode)&#123; if (NULL == rlm) return true; // 如果是主线程，直接 return false Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ))); if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) return false; // 如果 source0/source1/timer 有一个，则 return false if (NULL != rlm-&gt;_sources0 &amp;&amp; 0 &lt; CFSetGetCount(rlm-&gt;_sources0)) return false; if (NULL != rlm-&gt;_sources1 &amp;&amp; 0 &lt; CFSetGetCount(rlm-&gt;_sources1)) return false; if (NULL != rlm-&gt;_timers &amp;&amp; 0 &lt; CFArrayGetCount(rlm-&gt;_timers)) return false; // 传入的 mode 是否存在于当前的 RunLoop 的 Block Mode 中，或者存在于当前 RunLoop 的 CommonModes 中 struct _block_item *item = rl-&gt;_blocks_head; while (item) &#123; struct _block_item *curr = item; item = item-&gt;_next; Boolean doit = false; // 判断 Mode 是不是一个 string 类型 // 比较传入的 mode 是否存在于当前的 RunLoop，或者存在于当前 RunLoop 的 CommonModes 中 if (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) &#123; doit = CFEqual(curr-&gt;_mode, rlm-&gt;_name) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)); &#125; else &#123; doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, rlm-&gt;_name) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)); &#125; if (doit) return false; &#125; return true;&#125; 几乎网上所有的文章都说，如果没有 Source0/Source1/Timer，则 RunLoop Mode 是空的，但是其实不尽然，这里还有一个 Block 类型的判断在别的文章里没有被提到，从 macOS 10.6/iOS 4 开始，可以使用 CFRunLoopPerformBlock 函数往 run loop 中添加 blocks。正确的说法应该是，如果没有 Source0/Source1/Timer 以及该 RunLoop 的 _blocks_head 链表中也找不到该 Mode，才能判断该 Mode 是空的 注意我们说的不是 RunLoop 是空的，准确的说应该是 RunLoop Mode 是空的，由于一个 RunLoop 一次只能运行一个 Mode，所以这两种说法在某种意义上是等价的 CFRunLoopRun123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260/** RunLoop 的主流程，无限运行的秘密就在此 @param rl RunLoop @param rlm RunLoop Mode @param seconds RunLoop 超时时间 @param stopAfterHandle 处理后是否结束 @param previousMode 上一个 RunLoop Mode @return */static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode)&#123; // 记录当前时间 uint64_t startTSR = mach_absolute_time(); // 处理一些异常情况 if (__CFRunLoopIsStopped(rl)) &#123; __CFRunLoopUnsetStopped(rl); return kCFRunLoopRunStopped; &#125; else if (rlm-&gt;_stopped) &#123; rlm-&gt;_stopped = false; return kCFRunLoopRunStopped; &#125; // 声明用于和 mach_port 通信的端口 mach_port_name_t dispatchPort = MACH_PORT_NULL; // 如果是主线程，给端口赋值 Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ))); // dispatch_get_main_queue_handle_4CF 返回的是主线程 RunLoop 所关联的的端口 if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF(); // 处理 Timer 相关 dispatch_source_t timeout_timer = NULL; struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context)); if (seconds &lt;= 0.0) &#123; // 不超时 seconds = 0.0; timeout_context-&gt;termTSR = 0ULL; &#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123; // 正常限制内的超时 // 根据是否是主线程来取主队列 or 后台队列 dispatch_queue_t queue = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground(); // 创建 GCD Timer timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); // Retain，防止释放 dispatch_retain(timeout_timer); // 记录在超时上下文 timeout_context-&gt;ds = timeout_timer; timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl); timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds); // 超时上下文记录在 Timer dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context // 设置超时回调 dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout); // 设置超时取消回调 dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel); uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL); dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL); // 启动定时器 dispatch_resume(timeout_timer); &#125; else &#123; // 无限超时 seconds = 9999999999.0; timeout_context-&gt;termTSR = UINT64_MAX; &#125; Boolean didDispatchPortLastTime = true; int32_t retVal = 0; // 让我们开启无限循环的秘密 do &#123; voucher_mach_msg_state_t voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED; voucher_t voucherCopy = NULL; uint8_t msg_buffer[3 * 1024]; mach_msg_header_t *msg = NULL; mach_port_t livePort = MACH_PORT_NULL; __CFPortSet waitSet = rlm-&gt;_portSet; // 取消 RunLoop 的忽略唤醒信号，从此在线接收唤醒（可以接收 port 消息） __CFRunLoopUnsetIgnoreWakeUps(rl); // 通知即将处理 Timer if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers); // 通知即将处理 Source if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources); // 处理 Blocks __CFRunLoopDoBlocks(rl, rlm); // 处理 Source0（非 port） Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle); if (sourceHandledThisLoop) &#123; // 如果处理了 Source0 之后还有 Block 要处理，则再次处理 Block __CFRunLoopDoBlocks(rl, rlm); &#125; // poll = 是否处理 Source0 或没有超时 Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR); // 如果是主线程的队列里有未处理的消息且上一次循环的睡眠不是 dispatch 唤醒的 if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123; msg = (mach_msg_header_t *)msg_buffer; // timeout 为 0，不会休眠，直接处理消息 if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123; goto handle_msg; &#125; &#125; didDispatchPortLastTime = false; // 通知即将休眠 if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting); // 设置睡眠标志 __CFRunLoopSetSleeping(rl); // 每次循环都将 dispatchPort 加入监听端口集合中 __CFPortSetInsert(dispatchPort, waitSet); // 开始睡眠时间 CFAbsoluteTime sleepStart = poll ? 0.0 : CFAbsoluteTimeGetCurrent(); if (kCFUseCollectableAllocator) &#123; memset(msg_buffer, 0, sizeof(msg_buffer)); &#125; msg = (mach_msg_header_t *)msg_buffer; // 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。 // • 一个基于 port 的 Source 的事件。 // • 一个 Timer 到时间了 // • RunLoop 自身的超时时间到了 // • 被其他什么调用者手动唤醒 __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy); // 睡了多久 rl-&gt;_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart)); // 每次循环都移除刚刚的 dispatchPort __CFPortSetRemove(dispatchPort, waitSet); // 设置 RunLoop 的忽略唤醒信号，从此下线不接收唤醒（不再接收 port 消息） __CFRunLoopSetIgnoreWakeUps(rl); // 取消睡眠标志 __CFRunLoopUnsetSleeping(rl); // 通知结束休眠 if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting); // 处理消息 handle_msg:; // 设置 RunLoop 的忽略唤醒信号，从此下线不接收唤醒（不再接收 port 消息） __CFRunLoopSetIgnoreWakeUps(rl); if (MACH_PORT_NULL == livePort) &#123; CFRUNLOOP_WAKEUP_FOR_NOTHING(); // handle nothing &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123; CFRUNLOOP_WAKEUP_FOR_WAKEUP(); // do nothing on Mac OS &#125; else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123; CFRUNLOOP_WAKEUP_FOR_TIMER(); if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123; // Re-arm the next timer __CFArmNextTimerInMode(rlm, rl); &#125; &#125; else if (livePort == dispatchPort) &#123; CFRUNLOOP_WAKEUP_FOR_DISPATCH(); _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL); __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL); sourceHandledThisLoop = true; didDispatchPortLastTime = true; &#125; else &#123; CFRUNLOOP_WAKEUP_FOR_SOURCE(); voucher_t previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (void *)voucherCopy, os_release); CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort); if (rls) &#123; mach_msg_header_t *reply = NULL; sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop; if (NULL != reply) &#123; (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL); CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply); &#125; &#125; // Restore the previous voucher _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release); &#125; // 处理 Blocks __CFRunLoopDoBlocks(rl, rlm); if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123; // 进入该函数时参数说处理完事件就返回 retVal = kCFRunLoopRunHandledSource; &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123; // 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut; &#125; else if (__CFRunLoopIsStopped(rl)) &#123; // 被外部调用者强制停止了 __CFRunLoopUnsetStopped(rl); retVal = kCFRunLoopRunStopped; &#125; else if (rlm-&gt;_stopped) &#123; // Mode 已经被标记为 Stop rlm-&gt;_stopped = false; retVal = kCFRunLoopRunStopped; &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123; // source/timer/observer一个都没有了 retVal = kCFRunLoopRunFinished; &#125; voucher_mach_msg_revert(voucherState); os_release(voucherCopy); &#125; while (0 == retVal); // 释放 timer if (timeout_timer) &#123; // 如果有 timer，timeout_context 是被 timer 内部管理，不需要手动释放 dispatch_source_cancel(timeout_timer); dispatch_release(timeout_timer); &#125; else &#123; // 手动管理 timeout_context free(timeout_context); &#125; return retVal;&#125; mach_msg 1234567mach_msg_return_t mach_msg(mach_msg_header_t msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t receive_limit, mach_port_t receive_name, mach_msg_timeout_t timeout, mach_port_t notify); 详细可参考 [源码](http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_msg.html) `mach_msg` 是系统内核在某个 port 收发消息所使用的函数，收消息与发消息都是调用这个函数，只是 `mach_msg_option_t` 参数不同，发送为 `MACH_SEND_MSG`，接收为 `MACH_RCV_MSG` 可以简单的将 `mach_msg` 理解为多进程之间的一种通信机制，不同的进程可以使用同一个消息队列来交流数据，当使用 `mach_msg` 从消息队列里读取 msg 时，可以在参数中 timeout 值，在 timeout 之前如果没有读到 msg，当前线程会一直处于休眠状态。这也是 runloop 在没有任务可执行的时候，能够进入 sleep 状态的原因。如果 timeout = 0，则不会进入休眠；如果 timeout = TIMEOUT_INFINITY，则在没消息之前一直休眠 无限循环的真相 代码中一共出现了两处 __CFRunLoopServiceMachPort，注意 timeout 的值 12345// TimeOut 为 0__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL) // TimeOut 为 0 or 无限大__CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy); `__CFRunLoopServiceMachPort` 的实质是调用了 `mach_msg` 1234567ret = mach_msg(msg, MACH_RCV_MSG|(voucherState ? MACH_RCV_VOUCHER : 0)|MACH_RCV_LARGE|((TIMEOUT_INFINITY != timeout) ? MACH_RCV_TIMEOUT : 0)|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_AV), 0, msg-&gt;msgh_size, port, timeout, MACH_PORT_NULL); 第一处 `mach_msg` ，即如果主队列有任务执行，则不会进入睡眠，应该是为了保障 dispatch 到 main queue 的代码总是有较高的机会得以运行 可以看到 source0 是没有唤醒 RunLoop 的能力的，而 source1 有 可以看到并不是每次 RunLoop 如果处理了 source0 任务，那么 poll 值会为 true，会直接进入睡眠，而且不会告知 BeforeWaiting 和 AfterWaiting。所以有些情况下经过了几次循环，但注册的 observer 却不会收到回调","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"RunLoop","slug":"iOS/RunLoop","permalink":"http://yoursite.com/categories/iOS/RunLoop/"}]},{"title":"","date":"2020-08-15T09:01:57.800Z","path":"iOS/GCD/GCD_实践/","text":"异步处理耗时任务后主线程更新 UI12345678// 获取全局并发队列dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_async(queue, ^&#123; // 耗时操作 dispatch_async(dispatch_get_main_queue(), ^&#123; // 回主线程刷 UI &#125;);&#125;); 输出顺序123456789101112131415- (void)viewDidLoad&#123; [super viewDidLoad]; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_async(queue, ^&#123; NSLog(@\"1\"); [self performSelector:@selector(printLog) withObject:nil afterDelay:0]; NSLog(@\"3\"); &#125;);&#125; - (void)printLog&#123; NSLog(@\"2\");&#125; 输出 1、3，因为子线程没有开启 RunLoop；注意即使是 afterDelay 为 0，也是会放到下个 RunLoop 去做 如何实现多读单写？123456789101112131415161718- (id)objectForKey:(NSString *)key&#123; __block id ret; // 注意 __block dispatch_sync(self.concurrentQueue, ^&#123; // 读操作 ret = [self.dic objectForKey:key]; &#125;); return ret;&#125;- (void)setObject:(id)object forKey:(NSString *)key&#123; key = [key copy]; dispatch_barrier_async(self.concurrentQueue, ^&#123; // 写操作 [self.dic setObject:object forKey:key]; &#125;);&#125; 注意 __block 的使用 注意读的时候是同步；写的时候是异步。我们不需要使每次程序执行的时候都等待写操作完成，所以写操作异步执行，但是我们需要同步的执行读操作来保证程序能够立刻得到它想要的值 使用的队列是自己创建的而不是全局并发队列，因为我们不想写操作的时候阻塞全局队列的其他任务，我们只希望在写的同时，不会有其他的写操作或者读操作 dispatch_barrier_async 的 block 运行时机是，在它之前所有的任务执行完毕，并且在它后面的任务开始之前，期间不会有其他的任务执行 写操作的时候需要对 key 进行 copy，防止传入的 key 是 NSMutableString，异步之后它被外部修改 MRC 下的多读单写如果把 ARC 的代码转成以下 MRC 会有什么问题 1234567891011121314151617- (id)objectForKey:(NSString *)key&#123; __block id ret; dispatch_sync(self.concurrentQueue, ^&#123; ret = [self.dic objectForKey:key]; &#125;); return ret;&#125; - (void)setObject:(id)object forKey:(NSString *)key&#123; key = [key copy]; dispatch_barrier_async(self.concurrentQueue, ^&#123; [self.dic setObject:object forKey:key]; &#125;); [key release]; // MRC 添加&#125; 这样如果 A 线程正读取完一个值；而 B 线程随后对该值进行置 nil，那么 A 拿到的数据就会野指针 解决方案如下： 12345678- (id)objectForKey:(NSString *)key&#123; __block id ret; dispatch_sync(self.concurrentQueue, ^&#123; ret = [[self.dic objectForKey:key] retain]; &#125;); return [ret autorelease];&#125; 如何异步下载多张图片后并拼接见 dispatch_group_notify 如果需要按序下载图片呢？则使用串行队列即可","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"GCD","slug":"iOS/GCD","permalink":"http://yoursite.com/categories/iOS/GCD/"}]},{"title":"","date":"2020-08-15T09:01:57.798Z","path":"iOS/GCD/GCD/","text":"[toc] GCD 脑图 GCD 队列和任务队列（Dispatch Queue） 串行队列：只开启一个线程，一个任务执行完毕后，再执行下一个任务 并发队列：可以开启多个线程，并且同时执行任务 任务执行任务的两种方式： 同步执行 会卡当前线程 不具备开启新线程的能力 异步执行 异步添加任务到指定的队列中，不卡当前线程 具备开启新线程的能力（有能力不代表一定会开启新线程） 队列的创建/获取dispatch_queue_create1234// 串行队列的创建方法dispatch_queue_t queue = dispatch_queue_create(\"com.norcy.serial\", DISPATCH_QUEUE_SERIAL);// 并发队列的创建方法dispatch_queue_t queue = dispatch_queue_create(\"com.norcy.concurrent\", DISPATCH_QUEUE_CONCURRENT); 第一个参数是线程名称，推荐使用逆序全程域名，用于调试 第二个参数用于区别串行或并发，串行时填 DISPATCH_QUEUE_SERIAL 或者 NULL 都可以，并发填 DISPATCH_QUEUE_CONCURRENT 串行队列 可以使用 dispatch_queue_create 创建多个串行队列，它们之间将互不影响，可以并行执行。每创建一个串行队列，系统就会生成一个线程，如果线程数过多，就会引发大量的上下文切换降低性能 串行队列的使用场景：多个线程更新相同资源导致数据竞争时使用 并发队列 不管生成多少并发队列，系统内核只会使用有效管理的线程，不会出现串行队列的线程过多的问题 内存管理 即使在 ARC 下，每次使用 dispatch_queue_create 都得配套使用 dispatch_release 来释放 12345dispatch_queue_t myConcurrentDispatchQueue = dispatch_queue_create(\"com.example.gcd.MyConcurrentDispatchQueue\", DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, ^&#123;NSLog(@\"block on myConcurrentDispatchQueue\");&#125;); dispatch_release(myConcurrentDispatchQueue); 以上代码不会出现问题，因为 Block 拷贝的时候会对 Dispatch Queue 执行 `dispatch_retain` 操作，在 Block 结束时会执行 `dispatch_release` 操作 优先级 无论是创建串行还是并发队列，其优先级都是 DISPATCH_QUEUE_PRIORITY_DEFAULT 主队列对于串行队列，GCD 提供了的一种特殊的串行队列：主队列（Main Dispatch Queue） 所有放在主队列中的任务，都会放到主线程中执行 通过 dispatch_get_main_queue() 获取 全局并发队列对于并发队列，GCD 默认提供了全局并发队列（Global Dispatch Queue） 可以使用 dispatch_get_global_queue 来获取。需要传入两个参数：第一个参数表示队列优先级。第二个参数暂时没用，传 0 即可 优先级有 4 种：High &gt; Default &gt; Low &gt; Background 12// 全局并发队列的获取方法dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 队列和任务的组合使用 同步执行一定不能开新线程 异步执行具备开启新线程的能力 串行队列最多只能开启一个线程 并行队列可开启多个线程 串行队列+同步执行会卡住当前线程，任务在当前线程顺序执行 12345cur start cur 1cur 2cur 3cur end 串行队列+异步执行不会卡住当前线程，开1个新线程，任务在新线程顺序执行 12345cur start cur endnew 1new 2new 3 并发队列+同步执行会卡住当前线程，任务在当前线程顺序执行 12345cur start cur 1cur 2cur 3cur end 并发队列+异步执行不会卡住当前线程，开3个新线程，任务在新线程并发执行 12345cur startcur endnew2 2new1 1new3 3 主队列+同步执行 如果当前是在主线程，则会死锁。主线程等待任务完成，而任务等待主线程 如果当前是在子线程，则会卡住当前线程，任务在主线程顺序执行 串行队列+同步执行，如果当前所在队列和目标队列是同一个，那么就会死锁 主队列+异步执行不会卡住当前线程，任务在主线程顺序执行 常用 APIdispatch_set_target_queue见 dispatch_set_target_queue dispatch_after注意 dispatch_after 并不是再指定时间后执行处理，而只是在指定时间追加任务到 Dispatch Queue 因为主队列在主线程的 RunLoop 中执行，比如该 RunLoop 每 1/60 秒执行一次，则 Block 最快在 3 秒后执行，最慢在 3+1/60 秒后执行，并且如果队列中有其他任务影响，则这个时间会功更长 dispatch_group dispatch_group_notify 使用 dispatch_group_async 添加任务，一旦检测到所有任务执行完毕，dispatch_group_notify 中的任务就被会追加到指定队列中并处理 经典场景：下载多张图片，等它们都下载后，再合成一张图片 12345678dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, queue, ^&#123; /*加载图片1 */ &#125;);dispatch_group_async(group, queue, ^&#123; /*加载图片2 */ &#125;);dispatch_group_async(group, queue, ^&#123; /*加载图片3 */ &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; // 合并图片&#125;); dispatch_group_wait 使用 dispatch_group_wait 可以阻塞当前线程，等待 Group 中的任务执行完成之后，才会解除阻塞 等待无限长时间，直到 Group 中的所有任务完成 1234567dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, queue, ^&#123; /*加载图片1 */ &#125;);dispatch_group_async(group, queue, ^&#123; /*加载图片2 */ &#125;);dispatch_group_async(group, queue, ^&#123; /*加载图片3 */ &#125;); dispatch_group_wait(group, DISPATCH_TIME_FOREVER); // 合并图片 等待 5 秒，如果 5 秒后没完成或者 5 秒内完成，都会解除阻塞，继续执行；返回的 long 值为 0 则全部任务执行完毕，反之没完成 1234567891011121314dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, queue, ^&#123; /*加载图片1 */ &#125;);dispatch_group_async(group, queue, ^&#123; /*加载图片2 */ &#125;);dispatch_group_async(group, queue, ^&#123; /*加载图片3 */ &#125;); long result = dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_SEC)); if (result == 0)&#123; // 成功，合并图片 &#125;else&#123; // 全部任务未执行完毕&#125; dispatch_barrier_asyncdispatch_barrier_async 会在两个操作组间形成栅栏，在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作 为了防止读写冲突，采取同步读取，异步写入，此时就可以使用该方法 123456dispatch_queue_t queue = dispatch_queue_create(\"com.example.forBarrier\", DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, reading1);dispatch_async(queue, reading2);dispatch_barrier_async(queue, writing1);dispatch_async(queue, reading3);dispatch_async(queue, reading4); 执行结果可能为：reading2 -&gt; reading1 -&gt; writing1 -&gt; reading3 -&gt; reading4 writing 之前添加的 reading 任务顺序是不确定的；writing 一定会等到之前添加的所有 reading 任务结束之后才执行；writing 之后添加的任务一定会在 writing 结束之后再执行，如下图 dispatch_barrier_sync 与 dispatch_barrier_async 的区别在于，会等待其队列中的任务执行完毕再返回 dispatch_apply用于重复执行任务，类似 for 循环，参数 Block 是带有 index 参数信息的，注意是同步执行的 123456dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);NSLog(@\"begin\");dispatch_apply(3, queue, ^(size_t index) &#123; NSLog(@\"%@\",index, [NSThread currentThread]);&#125;);NSLog(@\"end\"); 输出结果为 12345begin213end 可以看到，index 的运用和同步执行的性质 dispatch_suspend 和 dispatch_resume12dispatch_suspend(queue);dispatch_resume(queue); 挂起后，已经执行过的任务不会受到影响，而已经追加到队列中但尚未执行的任务将停止执行，直到队列被恢复 什么场景下使用？ 一般在内存警告后取消队列中的操作 为了保证 scorllView 在滚动的时候流畅，通常在滚动开始时，暂停队列中的所有操作，滚动结束后，恢复操作 dispatch_group_enter 和 dispatch_group_leave假如有一个耗时操作 A 和 2 个网络请求 B、C，现在需要等到 ABC 都完成后刷新页面 注意如果网络请求的代码不使用 dispatch_group_enter 而使用 dispatch_group_async 是有问题的 1234567// 错误的示例// B 网络请求dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [self sendRequestWithCompletion:^(id response) &#123; number += 2; &#125;];&#125;); 问题在于，加入队列中的任务是一个网络请求，它是异步的，因此这个任务会被立刻完成（尽管此时网络请求还没回来） 对于 group 多任务中的异步任务，我们需要使用 dispatch_group_enter 和 dispatch_group_leave 实现 1234567891011121314151617181920212223242526272829303132333435363738394041- (void)testGCDEnter&#123; dispatch_group_t group = dispatch_group_create(); __block NSInteger number = 0; // A 耗时操作 dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(3); number += 1; &#125;); // B 网络请求 dispatch_group_enter(group); [self sendRequestWithCompletion:^(id response) &#123; number += 2; dispatch_group_leave(group); &#125;]; // C 网络请求 dispatch_group_enter(group); [self sendRequestWithCompletion:^(id response) &#123; number += 3; dispatch_group_leave(group); &#125;]; dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@\"%zd\", number); &#125;);&#125;- (void)sendRequestWithCompletion:(void (^)(id response))completion&#123; //模拟一个网络请求 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); dispatch_async(dispatch_get_main_queue(), ^&#123; if (completion) completion(nil); &#125;); &#125;);&#125; 当调用 dispatch_group_create 的时候，生成的 group 内部会维护一个信号量。 当调用 dispatch_group_enter 的时候，信号量会减 1； 当调用 dispatch_group_leave 的时候，信号量会加 1；此时会判断信号量是否恢复为初始值；如果是则调用 dispatch_group_notify 当调用 dispatch_group_async 的时候，其内部实际上也调用了 dispatch_group_enter 和 dispatch_group_leave 注意： dispatch_group_enter 必须在 dispatch_group_leave 之前出现 dispatch_group_enter 和 dispatch_group_leave 必须成对出现 更多资料可参考：深入理解GCD之dispatch_group dispatch_once单例 dispatch_semaphore少用，待补充 dispatch iO少用，待补充 相关链接 我的脑图 iOS多线程：『GCD』详尽总结","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"GCD","slug":"iOS/GCD","permalink":"http://yoursite.com/categories/iOS/GCD/"}]},{"title":"","date":"2020-08-15T09:01:57.796Z","path":"iOS/GCD/dispatch_set_target_queue/","text":"基础用法dispatch_set_target_queue 的作用： 改变队列优先级 让多个串行队列之间也能串行地执行任务 改变队列优先级dispatch_queue_create 创建的队列，无论是串行还是并发，其优先级都是 DISPATCH_QUEUE_PRIORITY_DEFAULT，使用 dispatch_set_target_queue 可以改变队列优先级 1234567891011121314151617181920212223242526dispatch_queue_t serialQueue = dispatch_queue_create(\"\", NULL);dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);//变更后 dispatch_async(serialQueue, ^&#123; NSLog(@\"1\"); &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@\"2\"); &#125;); dispatch_set_target_queue(serialQueue, globalQueue);// 变更后dispatch_async(serialQueue, ^&#123; NSLog(@\"3\"); &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@\"4\"); &#125;); // 输出如下// 1// 2// 4// 3 第一个参数如果是主队列或者是全局并发队列则后果未知 让多个串行队列之间也能串行地执行任务如果创建多个串行队列，它们之间其实是并行处理的。如果都对它们分别使用 dispatch_set_target_queue，指定为某一个串行队列，那么它们的任务将在目标串行队列上串行处理 123456789101112131415161718dispatch_queue_t mySerialDispatchQueue1 = dispatch_queue_create(\"com.example.gcd.MySerialDispatchQueue1\", NULL);dispatch_queue_t mySerialDispatchQueue2 = dispatch_queue_create(\"com.example.gcd.MySerialDispatchQueue2\", NULL);dispatch_queue_t targetDispatchQueue = dispatch_queue_create(\"com.example.gcd.TargetDispatchQueue\", NULL);dispatch_set_target_queue(mySerialDispatchQueue1, targetDispatchQueue);dispatch_set_target_queue(mySerialDispatchQueue2, targetDispatchQueue);dispatch_async(mySerialDispatchQueue1, ^&#123; NSLog(@\"1 %@\", [NSThread currentThread]);&#125;);dispatch_async(mySerialDispatchQueue2, ^&#123; NSLog(@\"2 %@\", [NSThread currentThread]);&#125;);// Queue1 和 Queue2 之间有依赖关系，它们的人物会在目标串行队列上串行处理// 输出// 1 targetDispatchQueue 所在的线程// 2 targetDispatchQueue 所在的线程 进阶探究不同串行队列的任务顺序当我们创建队列时，队列会附加到某一个全局队列。默认情况下会附加到默认优先级队列上 当往我们创建的队列添加任务时，这个任务会放到该队列的队尾 当该任务到达队列的头时，会把该任务移动到目标队列进行执行；并继续处理该队列的下一个任务 12345678910111213141516dispatch_queue_t mySerialDispatchQueue1 = dispatch_queue_create(\"com.example.gcd.MySerialDispatchQueue1\", NULL);dispatch_queue_t mySerialDispatchQueue2 = dispatch_queue_create(\"com.example.gcd.MySerialDispatchQueue2\", NULL);dispatch_queue_t targetDispatchQueue = dispatch_queue_create(\"com.example.gcd.TargetDispatchQueue\", NULL);dispatch_set_target_queue(mySerialDispatchQueue1, targetDispatchQueue);dispatch_set_target_queue(mySerialDispatchQueue2, targetDispatchQueue);dispatch_async(mySerialDispatchQueue2, ^&#123; NSLog(@\"1 %@\", [NSThread currentThread]);&#125;);dispatch_async(mySerialDispatchQueue1, ^&#123; NSLog(@\"2 %@\", [NSThread currentThread]);&#125;);dispatch_async(mySerialDispatchQueue2, ^&#123; NSLog(@\"3 %@\", [NSThread currentThread]);&#125;); 执行结果： 1231 targetDispatchQueue所在的线程3 targetDispatchQueue所在的线程2 targetDispatchQueue所在的线程 注意即使任务 3 是在任务 2 之后添加，但是却比任务 2 先执行 以上这个例子中，队列 1 和队列 2 的目标队列都是一个串行队列，主线程执行完毕后，队列 2 有任务 1 和任务 3，队列 1 有任务 2。GCD 开始会优先处理了队列 2 的任务 1，继而继续处理了任务 3；处理完队列 2 之后再处理队列 1 的任务 2 如何利用 GCD 实现一个优先队列123456789101112131415161718192021dispatch_queue_t low = dispatch_queue_create(\"low\",DISPATCH_QUEUE_SERIAL);dispatch_queue_t high = dispatch_queue_create(\"high\",DISPATCH_QUEUE_SERIAL);// low 队列的目标队列指定为 highdispatch_set_target_queue(low, high);// 执行一个 low 任务dispatch_async(low,^&#123; NSLog(@\"Low\");&#125;);// 要分派到高优先级队列，暂停低优先级队列，并且在高优先级块结束后恢复低优先级队列：dispatch_suspend(low);dispatch_async(high,^&#123; NSLog(@\"High1\"); dispatch_resume(low);&#125;);dispatch_suspend(low);dispatch_async(high,^&#123; NSLog(@\"High2\"); dispatch_resume(low);&#125;); dispatch_set_target_queue(low, high) 可以实现将所有的 low 队列的任务全部移到 high 队列处理，因此可以保证，处理 low 队列任务的时候，high 队列中现存的任务一定是优先于 low 队列。解决的是执行 low 的时候，high 的存量问题，保证了 low 一定要排队尾。 dispatch_suspend 保证添加 high 任务时，会暂停 low 队列，直到该任务完成才恢复。解决的是 high 任务的增量问题，保证了 high 可以插队 参考资料 如何利用 GCD 实现一个优先队列","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"GCD","slug":"iOS/GCD","permalink":"http://yoursite.com/categories/iOS/GCD/"}]},{"title":"","date":"2020-08-15T09:01:57.791Z","path":"iOS/Block/Block_面试题/","text":"block 用什么修饰符修饰对于这个问题，得区分 MRC 环境 和 ARC 环境；首先，通过上面小节可知，block 引用了普通外部变量，都是创建在栈区的；对于分配在栈区的对象，我们很容易会在释放之后继续调用，导致程序奔溃，所以我们使用的时候需要将栈区的对象移到堆区，来延长该对象的生命周期。 对于 MRC 环境，使用 copy 修饰 block，会将栈区的 block 拷贝到堆区 对于 ARC 环境，使用 strong、copy 修饰 block，都会将栈区的 block 拷贝到堆区 以下代码输出12345678910- (void)blockDemo3&#123; NSMutableString *strM= [NSMutableString stringWithString:@\"hello\"]; void (^block)() = ^ &#123; [strM appendString:@\"123\"]; &#125;; block();&#125; 输出 hello123，详细请看截获对象小节 下面代码在 MRC 环境 和 ARC 环境运行的情况1234567void exampleA() &#123; char a = 'A'; ^&#123; printf(\"%cn\", a); &#125;();&#125;//调用：exampleA(); 首先这个 Block 引用了普通外部变量，所以这个 Block 是在栈上面创建的；Block 是在 exampleA() 函数内创建的，然后创建完马上调用，这个时候 exampleA() 并没有执行完，所以这个栈 Block 是存在的，不会被 pop 出栈。故在 MRC 和 ARC 上面都可以正确执行 下面代码在 MRC 环境 和 ARC 环境运行的情况123456789101112131415void exampleB_addBlockToArray(NSMutableArray *array) &#123; char b = 'B'; [array addObject:^&#123; printf(\"%cn\", b); &#125;];&#125; void exampleB() &#123; NSMutableArray *array = [NSMutableArray array]; exampleB_addBlockToArray(array); void (^block)() = [array objectAtIndex:0]; block();&#125; //调用：exampleB() ARC 正常，MRC 崩溃。修复方法就是加 copy，如果不懂点这里 下面代码在 MRC 环境 和 ARC 环境运行的情况1234567891011121314void exampleC_addBlockToArray(NSMutableArray *array) &#123; array addObject:^&#123; printf(\"Cn\"); &#125;];&#125; void exampleC() &#123; NSMutableArray *array = [NSMutableArray array]; exampleC_addBlockToArray(array); void (^block)() = [array objectAtIndex:0]; block();&#125; //调用：exampleC(); 全局 Block，没有任何问题 下面代码在 MRC 环境 和 ARC 环境运行的情况1234567891011typedef void (^dBlock)();dBlock exampleD_getBlock() &#123; char d = 'D'; return ^&#123; printf(\"%cn\", d); &#125;;&#125;void exampleD() &#123; exampleD_getBlock()();&#125;//调用：exampleD(); MRC 编译器可检查出来，会编译失败；ARC 没问题 下面代码在 MRC 环境 和 ARC 环境运行的情况12345678910111213typedef void (^eBlock)();eBlock exampleE_getBlock() &#123; char e = 'E'; void (^block)() = ^&#123; printf(\"%cn\", e); &#125;; return block;&#125;void exampleE() &#123; eBlock block = exampleE_getBlock(); block()&#125;//调用：exampleE(); MRC 编译通过，调用异常；ARC 没问题 ARC 环境下输入结果123456789101112131415 __block NSString *key = @\"AAA\";objc_setAssociatedObject(self, &amp;key, @1, OBJC_ASSOCIATION_ASSIGN);id a = objc_getAssociatedObject(self, &amp;key);void (^block)(void) = ^ &#123; objc_setAssociatedObject(self, &amp;key, @2, OBJC_ASSOCIATION_ASSIGN);&#125;;id m = objc_getAssociatedObject(self, &amp;key);block();id n = objc_getAssociatedObject(self, &amp;key);objc_setAssociatedObject(self, &amp;key, @3, OBJC_ASSOCIATION_ASSIGN);id p = objc_getAssociatedObject(self, &amp;key);NSLog(@\"%@ --- %@ --- %@ --- %@\",a,m,n,p); 答：输入结果：1 — (null) — 2 — 3，代码执行过程如下： __block 修饰的 key，创建在栈区，访问变量 key 为：&amp;(结构体-&gt;forwarding-&gt;key) ，key 在栈区，此时利用栈区地址作为 Key 来存值 变量 a 使用栈区地址取值，故 a 的值为 1 声明一个 block，引用到了外部变量 key，此时将 block 从栈拷贝堆，访问变量 key 为：&amp;(结构体-&gt;forwarding-&gt;key) ，key 在堆区 变量 m 用堆区地址来取值，故为 null 执行 block，用堆区地址将 2 存进去 变量 n 用堆区地址来取值，故为 2 再用堆区地址将 3 存进去 变量 p 用堆区地址来取值，故为 3 使用block和使用delegate完成委托模式有什么优点委托模式在设计模式中是适配器模式中的对象适配器，Objective-C 中使用 id 类型指向一切对象，使委托模式在 iOS 中的实现更为方便 使用block实现委托模式，其优点是回调的 block 代码块定义在委托对象函数内部，使代码更为紧凑 适配对象不再需要实现具体某个 protocol，代码更为简洁 以下代码有问题吗12345int a = 7;void (^myBlock)(void) = ^() &#123; a = 8;&#125;;printf(\"%d\", myBlock()); 有问题，会出现 2 处编译错误，第一处是 a 不能被赋值，除非添加 __block；第二处是 myBlock 没有返回值，无法被打印 以下代码有问题吗12345id ret;dispatch_sync(self.concurrentQueue, ^&#123; ret = @\"1\";&#125;);NSLog(@\"%@\", ret) 会有编译错误，必须添加 __block，这样对象才可以在 block 中被重新赋值","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"Block","slug":"iOS/Block","permalink":"http://yoursite.com/categories/iOS/Block/"}]},{"title":"","date":"2020-08-15T09:01:57.789Z","path":"iOS/Block/Block/","text":"[toc] 什么是 Block Block 是带有自动变量（局部变量）的匿名函数 ——《Objective-C 高级编程》 Block 是 Objective-C 对于闭包的实现，本质是一个封装了函数以及函数上下文的对象 可以定义在函数内或函数外 本质是对象 Block 的写法Block 的定义 无参数无返回值 1234void (^MyBlockOne)(void) = ^(void)&#123; NSLog(@\"无参数，无返回值\");&#125;;MyBlockOne(); // Block的调用 有参数无返回值 1234void (^MyblockTwo)(int a) = ^(int a)&#123; NSLog(@\"@ = %d我就是Block，有参数，无返回值\",a);&#125;; MyblockTwo(100); 有参数有返回值 123456// 声明时可以省略参数的名字int (^MyBlockThree)(int,int) = ^(int a,int b)&#123; NSLog(@\"%d我就是Block，有参数，有返回值\",a + b); return a + b;&#125;; int ret = MyBlockThree(12,56); 无参数有返回值(很少用到) 12345int (^MyblockFour)(void) = ^&#123; NSLog(@\"无参数，有返回值\"); return 45;&#125;;int ret = MyblockFour(); Block 的省略写法以上等式的右半部分是 Block 的写法，以下是 Block 的语法，其中表达式就是 Block 的函数内容 12^ 返回值类型 参数列表 表达式^int(int a, int b) &#123;return a+b;&#125; 其中返回值类型可以被省略。省略返回值类型时，如果有 return 语句就使用该返回值的类型，如果有多条 return 语句则它们的类型必须相同，如果没有 return 则为 void 12^ 参数列表 表达式^(int a, int b) &#123;return a+b;&#125; 参数列表也可以被省略，前提是这个 Block 没有参数（而有返回值的时候依然可以省略返回值） 12^ 表达式^&#123;return @\"Hello\";&#125; typedef实际开发中常用 typedef 定义 Block 12345678910// 最好不要省略参数的名字typedef int (^MyBlock)(int a, int b);// 注意这里不是指针@property (nonatomic, copy) MyBlock myBlock;// 注意与直接定义 Block 不同，等号右边的返回值是写出来的self.myBlock = ^int(int a,int b)&#123;&#125; 使用 typedef 定义的时候，最好不要省略参数的名字 Block 虽然是对象，但是作为属性一般不是指针类型 截获外界变量截获自动变量（局部变量）值Block 只捕获在 Block 内部使用的自动变量（局部变量），是值复制而非引用，特别要注意的是默认情况下 Block 只能访问不能修改局部变量的值 1234567int age = 10;MyBlock block = ^&#123; NSLog(@\"age = %d\", age); //age = 11; 会导致编译错误&#125;;age = 18;block(); // age = 10 全局变量、静态全局变量和静态局部变量如果是这些类型，则 Block 直接可以访问到该变量自身，不需要进行拷贝，因此修改生效 123456789101112131415int global_val = 10;static int static_global_val = 10;int main()&#123; static int static_val = 10; myBlock block = ^&#123; printf(\"%d\\n\", global_val); printf(\"%d\\n\", static_global_val); printf(\"%d\\n\", static_val); &#125;; global_val = 18; static_global_val = 18; static_val = 18; block(); // 18,18,18&#125; __block 修饰的外部变量对于用 __block 修饰的外部变量（称为 __block 变量），Block 是复制其引用地址来实现访问的。Block 可以修改 __block 修饰的外部变量的值 123456__block int age = 10;myBlock block = ^&#123; NSLog(@\"age = %d\", age);&#125;;age = 18;block(); // age = 18 注意： __block 变量就是用 __block 修饰的局部变量 Block 的实现123456int main()&#123; void (^blk)(void) = ^&#123;printf(\"Block\\n\");&#125;; blk();&#125; 通过 clang -rewrite-objc MyBlock.c 可以转化为 C 语言的源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct __main_block_impl_0&#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself)&#123; printf(\"Block\\n\");&#125;struct __block_impl&#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;static struct __main_block_desc_0&#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main()&#123; // 以下语句等同于 // void (^blk)(void) = ^&#123;printf(\"Block\\n\");&#125;; struct __main_block_impl_0 tmp = __main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA); struct __main_block_impl_0 *blk = &amp;tmp; // 以下语句等同于 // blk() void *fun = blk-&gt;impl.FuncPtr; // void * 转换为函数指针进行调用 (*((void(*)(__main_block_impl_0 *))(fun)))(blk);&#125; __main_block_impl_0 的指针，其命名规则是由函数名（main）和 Block 出现的位置（第 0 个）决定的 Block 其实是一个 __main_block_impl_0 的指针，其主要包含一个 __block_impl，__block_impl 主要存储了一个函数指针，指向 Block 的内容 Block 的调用就是利用函数指针进行函数调用 为什么说 Block 是一个 Objective-C 对象？12345678910111213141516171819// Objective-C 对象的结构体struct class_t&#123; struct class_t *isa; struct class_t *superclass; Cache cache; IMP *vtable; uintptr_t data_NEVER_USE;&#125;;// 展开 __block_impl 后，Block 可以表示为以下结构体struct __main_block_impl_0 &#123; void *isa; int Flags; int Reserved; void *FuncPtr struct __main_block_desc_0* Desc;&#125;; __main_block_impl_0 相当于基于 objc_object 的 Objective-C 类对象的结构体，所以说 Block 是一个 Objective-C 对象 其中，Block 的 isa 的取值可能为 _NSConcreteGlobalBlock/_NSConcreteStackBlock/_NSConcreteMallocBlock 截获自动变量（局部变量）的实质12345678int main()&#123; int val = 5; void (^blk)(void) = ^&#123;printf(\"%d\\n\", val);&#125;; blk();&#125; 转换后的代码与之前的差别是 12345678910111213141516171819struct __main_block_impl_0&#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int val; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _val, int flags=0):val(_val) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself)&#123; int val = __cself-&gt;val; printf(\"%d\\n\", val);&#125; 最主要的差别就是 __main_block_impl_0 自动增加了一个 val 的成员变量，构造函数也发生了相应的变化。注意这里是值复制，这样就可以解释为什么 Block 截获局部变量，在执行 Block 内容时修改其值并不会影响原来的值。同时，因为这种实现无法改变被截获的局部变量的值，所以当在一个 Block 内对一个局部变量进行赋值的时候，编译器就会报错 截获全局变量、静态全局变量、静态局部变量的实质123456789101112131415int global_val = 10;static int static_global_val = 10;int main()&#123; static int static_val = 10; void (^blk)(void) = ^&#123; printf(\"%d\\n\", global_val); printf(\"%d\\n\", static_global_val); printf(\"%d\\n\", static_val); &#125;; global_val = 18; static_global_val = 18; static_val = 18; blk(); // 18,18,18&#125; 转换后的代码与之前的差别是 12345678910111213141516171819202122232425262728293031int global_val = 10;static int static_global_val = 10;struct __main_block_impl_0&#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int *static_val; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_val, int flags=0):static_val(_static_val) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself)&#123; int staic_val = *(__cself-&gt;staic_val); printf(\"%d\\n\", global_val); printf(\"%d\\n\", static_global_val); printf(\"%d\\n\", staic_val);&#125;int main()&#123; static int static_val = 10; struct __main_block_impl_0 tmp = __main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_val); // 下同，省略&#125; 对于全局变量和静态全局变量，转换后的代码依然可以访问到，因此在 __main_block_impl_0 内部并不会新增多余的成员变量 对于静态变量，Block 存储了其地址，从而达到可以修改其值的目的。其实普通局部变量也可以通过传地址的方式来达到在 Block 执行时可以修改其值的目的，但为什么没这么做呢？因为即使保存了普通局部变量的地址，当该变量的作用域失效的时候，那么这个地址也是非法的。而静态局部变量的作用域是一直有效，因此采用存储的地址的方法 截获 __block 变量12345678910int main()&#123; __block int val = 10; void (^blk)(void) = ^&#123;printf(\"%d\\n\", val);&#125;; val = 1; blk(); // 1&#125; 转换后的代码与之前的差别是 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct __Block_byref_val_0 &#123; void *__isa; __Block_byref_val_0 *__forwarding; // 实例本身 int __flags; int __size; int val;&#125;;struct __main_block_impl_0&#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_val_0 *val; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, int flags=0):val(_val) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself)&#123; __Block_byref_val_0 *val = __cself-&gt;val; printf(\"%d\\n\", val-&gt;_forwording-&gt;val);&#125;static void __main_block_copy_0(struct __main_block_impl_0 *dst,struct __main_block_impl_0 *src) &#123; _Block_object_assign(&amp;dst-&gt;val, src-&gt;val, BLOCK_FIELD_IS_BYREF);&#125;static void __main_block_dispose_0(struct __main_block_impl_0 *src) &#123; _Block_object_dispose(src-&gt;val, BLOCK_FIELD_IS_BYREF);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main()&#123; __Block_byref_val_0 val = &#123;0, &amp;val, 0, sizeof(__Block_byref_val_0), 10&#125;; struct __main_block_impl_0 *blk = &amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;val, 0x22000000); (val.__forwarding-&gt;val) = 1; // 下同，省略&#125; main 函数中，__block 变量已经被转化为 __Block_byref_val_0，注意转换后的代码没有一个叫做 val 的基本类型的值 __Block_byref_val_0 最后一个参数表示 __block 变量的值，这意味着该结构体持有着与原局部变量值相同的成员变量 main 函数中，__Block_byref_val_0 的构造函数中，第二个参数传的是它自己（原本是 __block 变量）的地址 修改 val 的值是通过 __forwording 来实现的，这个例子中 __forwording 指向它自己 为什么 __Block_byref_val_0 不是在 Block 内部创建呢，而是定义在 Block 的外部？这是为了如果有两个 Block 同时截获同一个局部变量，这两个 Block 需要同时引用这个值，如此才能实现多个 Block 能够修改同一个 __block 变量的值 新增了 __main_block_copy_0 和 __main_block_dispose_0 函数，而这两个函数没有被显式调用，只是作为参数传给了 __main_block_desc_0 构造函数，这两个是为了实现正确的引用计数 因为 __block 变量被转化为一个带原值的对象，这个对象以指针的形式传到了 Block 内部，因此在 Block 内部修改其值就得以实现 注意：__block 变量与 Block 的区别：__block 变量是栈上的结构体实例，而 Block 是栈上块的结构体实例 截获对象__strong 类型的对象123456789101112blk_t blk;&#123; id array = [NSMutableArray new]; blk = [^(id object)&#123; [array addObject:object]; NSLog(@\"array count = %ld\",[array count]); &#125; copy];&#125; blk([NSObject new]); // array count = 1blk([NSObject new]); // array count = 2blk([NSObject new]); // array count = 3 array 是局部变量，看起来应该会被释放，但是实际上却是被 Block 截获了 转换后的关键代码如下 12345678910111213141516struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; id __strong array; ...&#125;static void __main_block_copy_0(...)&#123; _Block_object_assign(...);&#125;static void __main_block_dispose_0(...) &#123; _Block_object_dispose(...);&#125; 截获对象时，Block 内部的成员变量是用 strong 修饰，因此才能使 array 不被释放 __main_block_copy_0 相当于 retain，会在栈 Block 被复制到堆时被系统调用，使对象的引用计数+1 __main_block_dispose_0 相当于 release，堆上的 Block 被释放，使对象的引用计数-1 如果以上代码不对 Block 进行 copy，那么虽然 Block 可以捕获 array 并强持有，但是由于还是在栈上，超出其作用域之后，Block 被释放，array 也跟着被释放，后续的 Block 调用会 Crash __block + __strong 类型的对象注意，如果是被 __block 和 __strong 同时修饰的对象，那么区别在于 __main_block_impl_0 持有的对象不再是 id __strong array 而是 __Block_byref_obj_0 123456789struct __Block_byref_obj_0 &#123; void *__isa;__Block_byref_obj_0 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); __strong id obj;&#125;; 除此之外，其结果基本与 __strong 类型的对象一致 __block 使得对象可以在 Block 内被赋值，否则会编译失败 __weak 类型的对象无论是有没有被 __block 修饰，__weak 类型的对象并不会增加对象的引用计数，所以对象依然会作用域结束时被释放，nil 被赋值给被截获的对象 Block 的类型我们先来看看一个由 C/C++/OBJC 编译的程序占用内存分布的结构： block有三种类型： 全局块(_NSConcreteGlobalBlock) 栈块(_NSConcreteStackBlock) 堆块(_NSConcreteMallocBlock) 它们的内存分配如上图 全局块存在于全局内存中，相当于单例 栈块存在于栈内存中，超出其作用域则马上被销毁 堆块存在于堆内存中，是一个带引用计数的对象，需要自行管理其内存 简而言之，存储在栈中的 Block 就是栈块、存储在堆中的就是堆块、既不在栈中也不在堆中的块就是全局块 _NSConcreteGlobalBlock以下情况均为全局块： 定义在函数之外（即写全局变量的地方） 没有截获任何局部变量（即使定义在函数内部） _NSConcreteStackBlock 栈上的 Block，如果其作用域结束，该 Block 就被废弃，如同一般的局部变量。同时，因为 __block 变量是被 Block 持有，所以它也会跟着 Block 一起被废弃 _NSConcreteMallocBlock 为了解决栈块在其变量作用域结束之后被废弃（释放）的问题，我们可以把 Block 复制到堆中延长其生命周期 开启 ARC 时，大多数情况下编译器会恰当地进行判断，自动生成将 Block 从栈上复制到堆上的代码 Block 的复制操作执行的是 copy 方法。只要调用了 copy 方法，栈块就会变成堆块 举个例子，编译器会自动 copy 返回的 Block 12345typedef int (^blk_t)(int);blk_t func(int rate) &#123; return ^(int count) &#123; return rate * count; &#125;;&#125; 将 Block 从栈上复制到堆上相当消耗 CPU，所以当 Block 设置在栈上也能够使用时，就不要复制了，因为此时的复制只是在浪费 CPU 资源 栈 Block 复制到堆之后，它的 __forwarding 指针会指向堆 Block 通过 __forwarding, 无论是在 Block 中还是 Block 外访问 __block 变量, 也不管该变量在栈上或堆上, 都能顺利地访问同一个 __block 变量 1234567__block int val = 0;void (^blk)(void) = [^&#123;++val;&#125; copy];++val;blk(); 其中 ^{++val;} 和 ++val 转换后的代码如下 12// val 是 __block 变量变成的结构体，它含有 __forwarding 指针++(val.__forwarding-&gt;val); 对各种类型的 Block 执行 copy 操作 编译器自动 copy 和不自动 copy 的情况自动 copy 的情况 Block 作为函数返回值返回的时候 Cocoa 框架的方法，方法中含有 usingBlock 等（如 NSArray 的 enumerateObjectUsingBlock） GCD 的 API 不自动 copy 的情况： 向函数参数传递 Block 12345678910111213141516171819202122- (NSArray *)getBlockArray&#123; int val = 10; // 不会自动 copy return [NSArray arrayWithObjects:^&#123;NSLog(@\"%d\", val);&#125;, ^&#123;NSLog(@\"%d\", val);&#125;, nil]; // 手动 copy // return [NSArray arrayWithObjects:[^&#123;NSLog(@\"%d\", val);&#125; copy], [^&#123;NSLog(@\"%d\", val);&#125; copy], nil]; // 会自动 copy // return @[^&#123;NSLog(@\"%d\", val);&#125;, ^&#123;NSLog(@\"%d\", val);&#125;];&#125;- (void)main&#123; NSArray *array = [self getBlockArray]; typedef void (^blk_t)(void); blk_t blk = (blk_t)[array firstObject]; blk();&#125; arrayWithObjects 这个方法返回的数组，将不会包含有效的 Block，执行 blk() 时会 crash 手动 copy 将可以解决 crash 问题 字面量的写法返回的数组，将不会导致 crash（实测如此，待求证） 栈 Block 何时会从栈复制到堆 对 Block 调用 copy Block 作为函数返回值返回的时候（编译器自动复制） Cocoa 框架的方法，方法中含有 usingBlock 等（如 NSArray 的 enumerateObjectUsingBlock）（编译器自动复制） GCD 的 API（编译器自动复制） 将 Block 赋值给类的 strong 成员变量 多次 copy Block无论是什么类型的 Block，对 Block 进行多次 copy 都不会有问题。在不确定时调用 copy 方法即可 12blk = [[blk copy] copy];// 经过多次复制，变量 blk 仍然持有 Block 的强引用，该 Block 不会被废弃 改代码等价为 123456789// 翻译后的代码&#123; blk_t tmp = [blk copy]; blk = tmp; &#125;&#123; blk_t tmp = [blk copy]; blk = tmp; &#125; 12345678910111213141516171819202122// 翻译后的代码+注释&#123; // 初识时，blk 指向一个栈块 blk_t tmp = [blk copy]; // 第一次 copy 会将栈块变为堆块，赋值给 tmp，tmp 此时强持有堆块 blk = tmp; // blk 和 tmp 都强持有堆块，blk 原来指向的栈块将会在整个函数结束时被释放&#125;// tmp 被释放，此时堆块只被 blk 持有&#123; blk_t tmp = [blk copy]; // 第二次 copy 会导致堆块的引用计数+1，tmp 强持有堆块 blk = tmp; // 赋值导致 blk 原有的指向失效，堆块引用计数-1，但此时 tmp 强持有，所以堆块不会被释放 // blk 再次指向堆块，此时 blk 和 tmp 同时强持有堆块&#125;// tmp 被释放，此时堆块只被 blk 持有，引用计数为 1 Block 循环引用使用 Block 成员变量引起的循环引用1234567891011121314151617181920212223242526272829303132typedeft void (^blk_t)(void);@interface MyObject : NSObject&#123; blk_t blk_;&#125;@end@implementation MyObject- (id)init&#123; self = [super init]; blk_ = ^&#123;NSLog(@\"self = %@\", self);&#125;; return self;&#125;- (void)dealloc&#123; NSLog(@\"dealloc\");&#125;@endint main()&#123; id o = [[MyObject alloc] init]; NSLog(@\"%@\", o); return 0;&#125; 以上代码引起循环引用，self 强引用 Block，Block 强引用 self Block 截获了类的成员变量时，即使没有使用 self，也会同样截获 self 12345678910111213141516@interface MyObject : NSObject&#123; blk_t blk_; id obj_;&#125;@end@implementation MyObject- (id)init&#123; self = [super init]; blk_ = ^&#123;NSLog(@\"obj_ = %@\", obj_);&#125;; return self;&#125; 对编译器来说，等价于 1blk_ = ^&#123;NSLog(@\"obj_ = %@\", self-&gt;obj_);&#125;; 破解方法：使用 weak 修饰符 12345678910- (id)init&#123; self = [super init]; id __weak weakSelf = self; blk_ = ^&#123;NSLog(@\"self = %@\", weakSelf);&#125;; return self;&#125; 使用 __block 变量引起的循环引用1234567891011121314151617- (instancetype)init&#123; self = [super init]; __block id temp = self;//temp持有self //self持有blk_ blk_ = ^&#123; NSLog(@\"self = %@\",temp);//blk_持有temp temp = nil; &#125;; return self;&#125;- (void)execBlc&#123; blk_();&#125; 该源代码没有引起循环引用。但是，如果不调用 execBlock 实例方法（即不执行赋值给成员变量 blk_ 的 Block），便会循环引用并引起内存泄露 破解方法：执行 Block 将 __block 变量置空 两种方法的比较相比使用 Block 成员变量，使用 __block 变量的优点如下： 通过 __block 变量可控制对象的持有期间（即不会在执行 Block 之前被释放，不过使用 Block 成员变量可以通过 Strong-Weak Dance 来解决被截获对象被提早释放的问题） 缺点如下： 为避免循环引用必须执行 Block 相关链接 之前写的关于 Block 的笔记 Strong-Weak Dance iOS Block 详解","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"Block","slug":"iOS/Block","permalink":"http://yoursite.com/categories/iOS/Block/"}]},{"title":"","date":"2020-08-15T09:01:57.787Z","path":"iOS/Block/Block 的实现（简化版）/","text":"不捕获任何变量12345int main()&#123; void (^blk)(void) = ^&#123;printf(\"Block\\n\");&#125;; blk();&#125; 1234567891011121314151617181920212223// block 转化后的类struct block_struct&#123; // 构造函数传入函数实现 block_struct(void *fp) &#123; this.FuncPtr = fp; // 函数实现 &#125;&#125;;// block 的内容被转化为 1 个全局函数static void block_imp(block_struct *self)&#123; printf(\"Block\\n\");&#125;int main()&#123; // 以下语句等同于 void (^blk)(void) = ^&#123;printf(\"Block\\n\");&#125;; block_struct blk(block_imp); // 以下语句等同于 blk() blk.FuncPtr(blk);&#125; Block 的内容被转化为 1 个全局函数 Block 本身被转为一个 struct，其构造函数传入这个全局函数的地址 Block 的调用等同于，调用 struct 的函数实现，参数是自身 捕获局部变量123456int main()&#123; int val = 5; void (^blk)(void) = ^&#123;printf(\"%d\\n\", val);&#125;; blk();&#125; 1234567891011121314151617181920struct block_struct&#123; int val; // 多了变量 block_struct(void *fp, int _val):val(_val) // 构造函数多了个参数 &#123; this.FuncPtr = fp; &#125;&#125;;static void block_imp(block_struct *self)&#123; printf(\"%d\\n\", self-&gt;val);&#125;int main()&#123; int val = 5; block_struct blk(block_imp, val); blk.FuncPtr(blk);&#125; 不同之处是转换后的结构体多了一个 int 的成员变量，构造函数和函数实现也相应的变化了 因为是值复制，所以无法在 Block 对捕获的简单类型值进行赋值 捕获全局变量、静态全局变量、静态局部变量123456789101112131415int global_val = 10;static int static_global_val = 10;int main()&#123; static int static_val = 10; void (^blk)(void) = ^&#123; printf(\"%d\\n\", global_val); printf(\"%d\\n\", static_global_val); printf(\"%d\\n\", static_val); &#125;; global_val = 18; static_global_val = 18; static_val = 18; blk(); // 18,18,18&#125; 123456789101112131415161718192021222324252627int global_val = 10;static int static_global_val = 10;struct block_struct&#123; int *static_val; // 指针 block_struct(void *fp, int _static_val):static_val(_static_val) &#123; this.FuncPtr = fp; &#125;&#125;;static void block_imp(block_struct *self)&#123; printf(\"%d\\n\", global_val); printf(\"%d\\n\", static_global_val); printf(\"%d\\n\", *(self-&gt;staic_val));&#125;int main()&#123; static int static_val = 10; block_struct blk(block_imp, &amp;static_val); global_val = 18; static_global_val = 18; static_val = 18; blk.FuncPtr(blk);&#125; 对于全局变量，block_struct 没有增加变量；对于局部静态变量，存储的是指针 这样就可以在 Block 内部任意的修改这些值 捕获 __block 变量1234567int main()&#123; __block int val = 10; void (^blk)(void) = ^&#123;printf(\"%d\\n\", val);&#125;; val = 1; blk(); // 1&#125; 123456789101112131415161718192021222324252627struct block_struct&#123; block_val *val; // 多了变量 block_struct(void *fp, int _val):val(_val) // 构造函数多了个参数 &#123; this.FuncPtr = fp; &#125;&#125;;struct block_val&#123; block_val *forwarding; int val;&#125;;static void block_imp(block_struct *self)&#123; printf(\"%d\\n\", self-&gt;val-&gt;forwarding-&gt;val);&#125;int main()&#123; block_val val(&amp;val, 10); block_struct blk(block_imp, val); (val.forwarding-&gt;val) = 1; blk.FuncPtr(blk); // 1&#125; __block 变量被转为一个类 无论是 Block 内还是外，访问值都得通过 forwarding 指针 Block 得到的是一个对象的指针，因此读写方面可以和 Block 外部的值保持一致 这个例子中 forwarding 指针都是自己，不能体现其意义，那么 forwarding 指针有什么用呢？ 我们知道，当对一个栈 Block 进行 copy 时，copy 函数会返回一个堆 Block。 copy 调用的时候，会将此堆 Block 访问到的 block_val 的 forwarding 指针，指向堆 Block 新生成的 block_val，而堆 Block 自己的 block_val 的 forwarding 指针会指向自己 这样原本在栈上的 block_val，或者是堆 Block 的 block_val，访问到的对象都会是同一个 1234__block int val = 0;void (^blk)(void) = [^&#123;++val;&#125; copy];++val; //1blk(); //2 12345block_val val(&amp;val, 0); // 这是一个在栈上的 block_valblock_struct temp(block_imp, val); // 这是一个在栈上的 Blockblock_struct blk = _Block_copy(temp); // 这是一个在堆上的 Block，会新生成一个新的 block_val，同时这个过程会修改 block_val 的 forwarding 指向这个新的 block_val(val.forwarding-&gt;val)++; // 对栈上的 block_val 操作是通过 forwarding，此时其指向的是堆上的 block_valblk.FuncPtr(blk); // 堆 Block 内部操作的是自己的 block_val，其 forwarding 指向自己 捕获对象__strong 类型的对象1234567int main()&#123; id array = [NSMutableArray new]; void (^blk)(void) = ^&#123;NSLog(@\"array count = %ld\",[array count]);&#125;; [array addObject:[NSObject new]]; blk(); // 1&#125; 123456789101112131415161718192021struct block_struct&#123; id __strong array; block_struct(void *fp, int _array):array(_array) &#123; this.FuncPtr = fp; &#125;&#125;;static void block_imp(block_struct *self)&#123; NSLog(@\"array count = %ld\",[self-&gt;array count]);&#125;int main()&#123; id array = [NSMutableArray new]; block_struct blk(block_imp, array); [array addObject:[NSObject new]]; blk.FuncPtr(blk); // 1&#125; 截获对象时，Block 内部的成员变量是用 strong 修饰，会使变量的引用计数加 1 Block 释放时，自然也会对使该变量的引用计数 -1 如果对这个 Block 进行 copy，那么栈 Block 会变成堆 Block，Block 本身的引用计数会 +1，不过这个例子没有体现 __block + __strong 类型的对象1234567int main()&#123; __block id array = [NSMutableArray new]; void (^blk)(void) = ^&#123;NSLog(@\"array count = %ld\",[array count]);&#125;; [array addObject:[NSObject new]]; blk(); // 1&#125; 12345struct block_val&#123; block_val *forwarding; id array;&#125;; 和捕获 __block 一样，只是 block_val 内部维护的是一个对象","tags":[],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"Block","slug":"iOS/Block","permalink":"http://yoursite.com/categories/iOS/Block/"}]},{"title":"","date":"2020-08-15T09:01:57.779Z","path":"C++/unordered_map 与 map 的区别/","text":"map 是基于红黑树实现，O(lgn) 的时间复杂度完成查找、插入和删除，内部是有序的 unordered_map 是基于 hash_table 实现 map unordered_map 实现原理 红黑树 hash_table 有序性 有序 无序 时间复杂度 查找、插入和删除都是 O(lgn) 查找、插入和删除平均 O(1)，最坏 O(n) 内存占用 更少 更多 使用场景 需要数据有序；对内存敏感 大多数情况下选择 unordered_map，特别是需要查找的情况","tags":[],"categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"","date":"2020-08-15T09:01:57.777Z","path":"C++/static变量与static函数/","text":"今天遇到一个 crash，追溯到最后竟然是因为在两个 .cpp 文件中声明了2个相同名称的全局变量，改用 staitc 修饰它们为静态全局变量就解决问题 1234567pair&lt;string, VN_CSS_TYPE_ALIAS_PAESER&gt; pairArray[] = &#123; make_pair(\"src\", VN_RICH_CSS_VIDEO_SRC_ALIAS_PARSER)&#125;;ClassA::fun()&#123;&#125; 改为 1234567static pair&lt;string, VN_CSS_TYPE_ALIAS_PAESER&gt; pairArray[] = &#123; make_pair(\"src\", VN_RICH_CSS_VIDEO_SRC_ALIAS_PARSER)&#125;;ClassA::fun()&#123;&#125; static 变量的特征： static 变量被放在程序的全局存储区中，这样在下一次调用的时候还可以保持原来的赋值 static 变量仅在其作用范围内可见。这一点是它与全局变量的区别。 Tips: 若全局变量仅在单个文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度； 若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度； 函数前加 static 使得函数成为静态函数。是指对函数的作用域仅局限于本文件(所以又称内部函数)。使用内部函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其它文件中的函数同名 全局变量、静态全局变量、静态局部变量和局部变量的区别变量可以分为 全局变量（外部变量） 静态全局变量 静态局部变量 局部变量 按存储区域分，全局变量、静态全局变量和静态局部变量都存放在内存的静态存储区域，局部变量存放在内存的栈区。 按作用域分，全局变量在整个工程文件内都有效；静态全局变量只在定义它的文件内有效；静态局部变量只在定义它的函数内有效，并且程序仅分配一次内存，函数返回后，该变量不会消失；局部变量在定义它的函数内有效，但是函数返回后失效 全局变量前再冠以 static 就构成了静态全局变量。 全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数用，因此可以避免在其它源文件中引起错误 从以上分析可以看出，把局部变量改变为静态局部变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态全局变量后是改变了它的作用域，限制了它的使用范围 全局变量、静态局部变量和静态全局变量如果没有手工初始化，则由编译器初始化为0。局部变量的值不可知","tags":[],"categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"dynamic_cast","date":"2020-08-15T09:01:57.775Z","path":"C++/dynamic_cast/","text":"C++ 中 如果是子类指针强制转换父类指针，则称为上行转换（upcasting） 如果是父类指针强制转换子类指针，则称为下行转换（downcasting） 例子123456789101112131415161718classB&#123;public: int m_iNum; virtual void foo();&#125;;classD : public B&#123;public: char *m_szName[100];&#125;;void func(B *pb)&#123; D *pd1 = static_cast&lt;D *&gt;(pb); D *pd2 = dynamic_cast&lt;D *&gt;(pb);&#125; 在上面的代码段中，如果 pb 指向一个 D 类型的对象，pd1 和 pd2 是一样的，并且对这两个指针执行 D 类型的任何操作都是安全的； 但是，如果 pb 指向的是一个 B 类型的对象，那么 pd1 将是一个指向该对象的指针，对它进行 D 类型的操作将是不安全的（如访问 m_szName），而 pd2 将是一个空指针，因而 dynamic_cast 更安全 结论如果进行上行转换，则使用 dynamic_cast 和 static_cast 的效果一样，都能得到正确的转换结果 如果进行下行转换，dynamic_cast 具有类型检查的功能，比 static_cast 更安全；如果类的关系是对的，则转换成功，返回一个指向子类的指针，否则返回 NULL 指针 注意dynamic_cast 转化时，如果父类不是一个多态类，也就是没有虚函数，那么编译失败，因此如果要实现 dynamic_cast 的转换，至少把父类的析构函数声明为虚函数（不必须是纯虚函数）；而 static_cast 会编译成功，不安全 为什么需要虚函数呢：从意义上说，类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。从技术上说，这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表","tags":[],"categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"","date":"2020-08-15T09:01:57.771Z","path":"C++/C++默认参数/","text":"C++ 可以给参数设置默认值，当参数缺省的时候，使用默认值如果没有设置默认值，则调用的时候不能省略参数 12345678910111213void f(int i = 1, float f = 2.0f, double d = 3.0)&#123; cout &lt;&lt; i &lt;&lt; \", \" &lt;&lt; f &lt;&lt; \", \" &lt;&lt; d &lt;&lt; endl ;&#125;int main(void)&#123; f() ; // 1, 2, 3 f(10) ; // 10, 2, 3 f(10, 20.0f) ; // 10, 20, 3 f(10, 20.0f, 30.0) ; // 10, 20, 30 return 0 ;&#125; 参数默认值可以是一个函数123456789static int getValue()&#123; return 1;&#125;int f(int a, int b = getValue())&#123; return b;&#125; 如果某个参数是默认参数，那么它后面的参数必须都是默认参数所有有歧义的都是非法的 以下定义是非法的，因为有歧义。因为一旦只有两个参数，那么缺省的是第二个还是第三个呢？ 1void f(int i, float f = 2.0f, double d); 函数重载时谨慎使用默认参数值以下定义是非法的，因为有歧义。一旦只有一个参数，那么应该调用第一个函数还是第二个呢？ 123456789int f(int a)&#123; return a;&#125;int f(int a, int b = 1)&#123; return a + b;&#125;","tags":[],"categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"","date":"2020-08-15T09:01:57.769Z","path":"C++/C++拾遗/","text":"虚函数相关 定义一个函数为虚函数，不代表函数为不被实现的函数。 定义基类的函数为虚函数是为了允许用基类的指针来调用子类的这个函数（多态） 定义一个函数为纯虚函数，才代表函数没有被实现，规范继承这个类的子类必须实现这个函数 抽象类的定义：称带有纯虚函数的类为抽象类 抽象类无法实例化 继承抽象类的子类如果没有实现纯虚函数，则该子类也是抽象类 虚析构函数 v.s. 纯虚析构函数 实现多态时，父类的析构函数必须为虚析构函数，否则 delete 的时候父类的析构函数不会被调用 如果想实现一个抽象类，如果其中没有其他合适的函数，可以把析构函数定义为纯虚的 纯虚函数通常都不需要函数体，因为我们一般不会调用抽象类的这个函数，但是不代表不能有函数体 无论是虚析构函数还是纯虚析构函数，都必须有函数体。因为即使是抽象类，其析构函数也应该需要被调用到（会被子类的析构函数隐式调用到） 123456class Base&#123;public: Base()&#123;&#125; virtual ~Base()= 0;&#125;; 这段代码会编译错误，因此析构函数一定需要函数体，但是对于纯虚函数不能把实现和 =0 写在一起，因此需要改为这样 123456789101112class Base&#123;public: Base() &#123; &#125; virtual ~Base() = 0;&#125;;Base::~Base()&#123;&#125; virtual 的隐式继承virtual 修饰符是会隐式继承的：基类是 virtual 函数，子类不写 virtual 关键字，其函数依然是 virtual delete [] 和 delete 数组对象使用 delete 的话，虽然这块内存会正确地归还，但只会针对数组内的第一个对象执行析构函数，后续的对象的析构函数都无法被执行 基本类型的对象没有析构函数，所以回收基本类型组成的数组空间用 delete 和 delete[] 都是应该可以的 但是对于类对象数组，只能用 delete[]。对于 new 的单个对象，只能用 delete 不能用 delete[] 回收空间 所以一个简单的使用原则就是：new 和 delete、new[] 和 delete[] 对应使用 混编 OC 的 .h 和 .m 包含 C++ 类，它作为属性 C++ 的 .h 和 .cpp 包含 OC 类，它作为变量 C++类与 void的转换，OC 类与 void的转换 OC 类在 C++ 之间传递，用 void *、bridge【QVNImplementationUtils】 C++ 类在 OC 之间传递，用 void * C++ 类，有一个 OC 变量，OC 的生成和释放都是 ARC 管理的 写了 inline 就一定会内联吗？不写 inline 一定不会内联吗inline 仅仅是一个对编译器的建议，最后能否真正内联取决于编译器，它如果认为你的函数不复杂，能在调用点展开，并不是说声明了内联就会内联；同理，没有声明 inline 的也不一定不会内联，如下代码 比如以下代码极有可能会被内联 123static int Inc(int i) &#123;return i+1&#125;;int i;for (i=0; i&lt;999999; i = Inc(i)) &#123;&#125;; 变为 123static int Inc(int i) &#123;return i+1&#125;;int i;for (i=0; i&lt;999999; i = i+1) &#123;&#125;; inline 写在函数声明的地方是无效的如下风格的函数 Foo 不能成为内联函数： 12inline void Foo(int x, int y); // inline 仅与函数声明放在一起void Foo(int x, int y)&#123;&#125; 而如下风格的函数Foo 则成为内联函数： 12void Foo(int x, int y);inline void Foo(int x, int y) &#123;&#125;// inline 与函数定义体放在一起 所以说，inline 是一种 “用于实现的关键字”，而不是一种 “用于声明的关键字” 全局的 inline 函数要把实现写在头文件首先 inline 写在函数声明处是无效的；其次如果只在 .c 中声明 inline，.h 不声明，那么其他文件引用该 .h 的时候，根本不知道该函数是一个内联函数，所以只能把实现和 inline 关键字写在头文件 其次，定义在头文件中的 inline 需要配合 static 如果没有 static，那么编译器会认为该内联函数是全局的，会把该函数进行编译（即当成普通的全局函数而不是在调用处展开），那么就失去了内联的效果 https://medium.com/@hauyang/%E6%88%91%E6%9C%89%E6%89%80%E4%B8%8D%E7%9F%A5%E7%9A%84-static-inline-b363892b7450 C++ 的枚举写法有坑12345678910111213vector&lt;vector&lt;int&gt;&gt; ret;// 这种写法，修改 v 不会影响 ret，因为 v 是拷贝构造了for (auto v : ret) v.pop_back();// 这种写法，修改 v 会影响 ret，因为 v 是引用for (auto &amp;v : ret) v.pop_back();// 加引用的写法等同于这个写法for (int i = 0; i &lt; ret.size(); ++i) ret[i].pop_back(); C++变量的初始化 全局变量、静态变量：0 局部变量：随机 类的成员变量 全局：0 静态：0 局部：随机 123456789101112int g_var;int *g_pointer;static int g_static;int main()&#123; int l_var; int *l_pointer; static int l_static; cout&lt;&lt;g_var&lt;&lt;endl&lt;&lt;g_pointer&lt;&lt;endl&lt;&lt;g_static&lt;&lt;endl; // 0 0 0 cout&lt;&lt;l_var&lt;&lt;endl&lt;&lt;l_pointer&lt;&lt;endl&lt;&lt;l_static&lt;&lt;endl; // 非0 非0 0&#125;; 123456789101112class A&#123;public: int v;&#125;;A g_var;int main()&#123; A l_var; static A l_static; cout&lt;&lt;g_var.v&lt;&lt;' '&lt;&lt;l_var.v&lt;&lt;' '&lt;&lt;l_static.v&lt;&lt;endl; // 0 2407223 0 return 0;&#125; 一个类型转换的问题（待解决）123456789101112131415161718192021222324252627class A&#123;public: virtual void doA() = 0; virtual ~A()&#123;printf(\"~A\\n\");&#125;;&#125;;class B&#123;public: virtual void doB() = 0; virtual void doC() = 0; virtual ~B()&#123;printf(\"~B\\n\");&#125;;&#125;;class SubClass: public A, public B&#123;public: void doA() override; void doB() override; void doC() override; ~SubClass()&#123;printf(\"~SubClass\\n\");&#125;;&#125;;void SubClass::doA()&#123;printf(\"doA\\n\");&#125;;void SubClass::doB()&#123;printf(\"doB\\n\");&#125;;void SubClass::doC()&#123;printf(\"doC\\n\");&#125;; 测试代码如下 1234567891011121314151617181920212223A *a = new SubClass();a-&gt;doA(); // doAB *b = (B *)a;b-&gt;doB(); // doAb-&gt;doC(); // ~SubClass ~B ~AA *a = new SubClass();a-&gt;doA(); // doAB *b = (B *)a;b-&gt;doC(); // ~SubClass ~B ~Ab-&gt;doB(); // Crash:libc++abi.dylib: Pure virtual function called!A *a = new SubClass();a-&gt;doA(); // doASubClass *sub = dynamic_cast&lt;SubClass *&gt;(a);sub-&gt;doB(); // doBsub-&gt;doC(); // doCA *a = dynamic_cast&lt;A*&gt;(new SubClass());a-&gt;doA(); // doAB *b = dynamic_cast&lt;B*&gt;(a);b-&gt;doB(); // doBb-&gt;doC(); // doC A *a = new SubClass(); 这种写法和 A *a = dynamic_cast&lt;A*&gt;(new SubClass()); 本质上没有区别 但是 B *b = (B *)a; 和 SubClass *sub = dynamic_cast&lt;SubClass *&gt;(a); 是有区别的 注意以上代码都不应该打印析构函数的内容，因为没有调用 delete","tags":[],"categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"","date":"2020-08-15T09:01:57.768Z","path":"C++/C++头文件的全局变量/","text":"[TOC] 变量的定义与声明1234extern int a; // 声明一个全局变量aint a; // 定义一个全局变量aextern int a = 0; // 定义一个全局变量a并给初值int a = 0; // 定义一个全局变量a并给初值 定义只能有1处，但声明可以有多处 定义引起内存分配，声明则不会 注意变量和函数的声明默认就是 extern 函数的定义与声明函数的定义和声明是有区别的，定义函数要有函数体，声明函数没有函数体，所以函数定义和声明时都可以将 extern 省略掉 12int a; // 这是一个变量的定义int fun(void); // 这是一个函数的声明，省略了extern，完整些是extern int fun(void); 头文件中的全局变量1234567891011121314151617181920212223242526// test.h#ifndef _TEST_H_ #define _TEST_H_ // 这是可行的，在编译阶段，每个包含 test.h 的文件会生成一个 static int a = 0; // 存放在不同的地址，不是全局变量static int a = 0;// 这是可行的，在编译阶段，每个包含 test.h 的文件会生成一个 const int b = 0; // 存放在不同的地址，不是全局变量，与 static 一样const int b = 1;// 这是可行的，在编译阶段，每个包含 test.h 的文件会生成一个 extern int c; // 存放在同一个地址，是全局变量 // 使用的时候必须在其中一个\".cpp\"文件定义 int c; 之后才可以正确运行// 因为 extern 的含义是变量定义在别的位置extern int c;// 这是危险的，相当于int d = 0// 存放在同一个地址，是全局变量 // 多个头文件包含是会发生重定义问题！！！extern int d = 0;// vector 同理// p.s. 对于 const 的迭代器访问，需要使用 const_iterator 而不是 iteratorconst std::vector&lt;std::string&gt; VN_MULTICELLTYPE = &#123;\"1\", \"2\"&#125;;#endif 注意全局 const 默认为该编译单元的局部变量（内部链接性），即类似 static 修饰（C 和 C++ 不同，const 常量在 C 中依旧是外部链接性的 ） 在头文件中定义 static/const 变量会造成变量多次定义，造成内存空间的浪费，而且也不是真正的全局变量。应该避免使用这种定义方式 正确的方式是在头文件中使用声明，在某一个实现文件中定义，其他实现文件引用即可 1234567891011121314//tesh.h#ifndef _TEST_H_#define _TEST_H_extern int a; // 此处声明#endif// a.cpp#include \"test.h\"a = 2; // 此处定义cout &lt;&lt; a &lt;&lt; endl;// b.cpp#include \"test.h\"cout &lt;&lt; a &lt;&lt; endl; // 输出2 参考文章 NSNotification Name 最佳写法 const、static、extern 在头文件中似的情况小结 勿在头文件中定义static变量","tags":[],"categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"","date":"2020-08-15T09:01:57.765Z","path":"C++/C++头文件如何正确定义全局变量/","text":"背景我们项目里看到一个头文件，是专门定义各种常量的，有一天发现这里的常量定义既使用了 static，又使用了 const，这个文件没有类，全部都是字符串的定义 12345678// QVNDefine.h#ifndef QVNDefine_h#define QVNDefine_hconst string VN_LIST = \"list\";const string VN_CELL = \"cell\";const string VN_VIEWPAPER = \"view-pager\";static vector&lt;string&gt; VN_MULTICELLTYPE = &#123;VN_LIST, VN_VIEWPAPER&#125;;#endif /* QVNDefine_h */ 此时我们有一番讨论，松哥觉得应该在头文件里声明，在实现文件里定义会更好，即类似 12345// QVNDefine.h#ifndef QVNDefine_h#define QVNDefine_hextern const string VN_LIST;#endif /* QVNDefine_h */ 123// QVNDefine.cpp#include \"QVNDefine.h\"extern const string VN_LIST = \"list\"; 虽然是自己写的代码，但其实自己对这里的知识不太熟悉，习惯性就写了 const，又不知道为什么写了 static，所以找了一下资料系统学习一下 声明与定义我们的问题是在 C++ 头文件中如何正确定义全局变量，首先要理解变量的声明和定义的区别是什么，翻了一下之前的笔记 1234extern int a; // 声明一个全局变量aint a; // 定义一个全局变量aextern int a = 0; // 定义一个全局变量a并给初值int a = 0; // 定义一个全局变量a并给初值 注意一下在 C++ 中 定义只能有1处，但声明可以有多处，这就是 ODR（定义与单一定义）规则 定义引起内存分配，声明则不会 注意变量的声明默认就是 extern 以上是针对变量的，如果是函数，还有点微妙的区别 函数的定义和声明一样是有区别的，定义函数要有函数体，声明函数没有函数体 所以与变量的区别就是没有函数体的函数是声明，而不是定义，如下例 12int a; // 这是一个变量的定义int fun(void); // 这是一个函数的声明，省略了extern，完整些是extern int fun(void); 头文件定义全局变量几种方式的比较根据以上信息，我们有以下几种定义全局变量的方式 第一种方法，直接定义12345// QVNDefine.h#ifndef QVNDefine_h#define QVNDefine_hextern int a = 0;#endif /* QVNDefine_h */ 这是危险的，相当于 int a = 0，变量存放在同一个地址，是全局变量，多个实现文件包含该头文件是会发生重复定义问题，违背了 ODR 规则！ 第二种方法，使用 static12345// QVNDefine.h#ifndef QVNDefine_h#define QVNDefine_hstatic int a = 0;#endif /* QVNDefine_h */ 这是可行的，在编译阶段，每个包含该头文件的 .cpp 会生成一个 static int a = 0，变量存放在不同的地址，不是全局变量 第三种方法，使用 const12345// QVNDefine.h#ifndef QVNDefine_h#define QVNDefine_hconst int a = 0;#endif /* QVNDefine_h */ 这是可行的，在编译阶段，每个包含该头文件的 .cpp 会生成一个 const int a = 0，变量存放在不同的地址，不是全局变量，与 static 效果一样 第四种方法，使用 extern const 声明 + 实现文件定义12345// QVNDefine.h#ifndef QVNDefine_h#define QVNDefine_hextern const int a;#endif /* QVNDefine_h */ 123// QVNDefine.cpp#include \"QVNDefine.h\"extern const int a = 1; 这是可行的，在编译阶段，其他包含该头文件的 .cpp 会生成一个 extern const int a，存放在同一个地址，是全局变量 除了方法一，其他方法都是可行的。那么它们有什么区别呢，谁才是最佳方式？ 先说结论，大多数情况下，方法三最好 先聊聊 static这里只阐述全局变量有无被 static 修饰的区别 一个全局变量（无论是定义在 .h 还是 .cpp），如果没有被 static 修饰，那么它是全局性的，假如该头文件被多次 include，在编译时就会产生重复链接的报错 而如果添加了 static，该全局变量就会变成静态全局变量，其作用域只在当前编译单元（比如 include 了该头文件的 .cpp）生效 所以实现文件的全局函数一般都要添加 static，这样不同的人编写不同的实现文件时，不用担心自己定义的函数，是否会与其它文件中的函数同名 根据这个特点，假如有一百个实现文件包含了该头文件，那么这个全局变量就会被定义一百次，这个会造成内存空间的浪费，应该避免使用这种方式 此时我们可以使用 extern 声明 + 实现文件定义的方法来解决多次定义的浪费问题 再聊聊 const const 的最初动机是取代预处理器 #define 来进行值替代，后来还被用于指针、函数变量、返回类型、类对象以及成员函数——《C++ 编程思想》 这里我们只阐述头文件中的 const 有什么特点 const 在 C++ 中默认为内部链接（这一点与 C 不同，注意），即只对包含该定义的文件里是可见的，而不会被其他编译单元看到，故不是一个全局变量（与 static 类似），这个特点保证了不会有重复定义的错误 既然 const 与 static 类似，那么是否一样会有多次定义的浪费问题呢？以及为什么比方法四（extern 声明 + 实现文件定义）好？答案都在书里 通常 C++ 编译器并不为 const 创建存储空间，相反它把这个定义保存在它的符号表里。大部分场合使用内部数据类型的情况，包括常量表达式，编译都能执行常量折叠——《C++ 编程思想》 不过以下情况，编译器会进行存储空间的分配： extern 成为 const 变量定义的一部分 取一个 const 的地址 const 修饰的是一个复杂的对象 如果 extern 成为 const 变量定义的一部分的时候，那么编译器会为强制进行了存储空间分配，extern 意味着使用外部连接，因此必须分配存储空间，这也就是说有几个不同的编译单元应当能够引用它，所以它必须存储空间 常量折叠何为常量折叠？常量折叠（Constant folding）和常量传播（constant propagation）都是一种编译器最佳化技术 常量折叠表面上的效果和宏替换是一样的，只是 “效果上是一样的”，而两者真正的区别在于，宏是字符常量，在预编译完宏替换完成后，该宏名字会消失，所有对宏的引用已经全部被替换为它所对应的值，编译器当然没有必要再维护这个符号 而常量折叠发生的情况是，对常量的引用全部替换为该常量的值，但是，常量名并不会消失，编译器会把他放入到符号表中 1i = 320 * 200 * 32; 比如上面的代码中，编译器通常会在编译时直接计算出320 * 200 * 32的值，而不会在此生成2个乘法指令 结论所以如果定义的都是内部数据类型，我们只要保证不对 const 变量进行取址操作（事实上也很少这样做），那么使用 const 的方式是最佳的，因为可以借助编译器的力量进行优化。最后回归背景问题，我们需要将 static 替换为 const 即可 参考文章 Defining global constant in C++ const、static、extern 在头文件中似的情况小结 《C++ 编程思想》第二版 8.1.1 头文件里的 const C++常量折叠（这一篇关于分配空间的说法有失偏颇）","tags":[],"categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"","date":"2020-08-15T09:01:57.763Z","path":"C++/C++多态/","text":"多态父类指针指向一个子类对象，调用父类声明的方法后，实际上调用的是子类的实 1234567891011121314151617class A&#123;public: virtual void f()&#123;&#125;; virtual void g()&#123;&#125;; int a;&#125;;class B : public A&#123;public: void g()&#123;&#125;; int b;&#125;;A *pA = new B();pA-&gt;g(); 多态的实现原理（虚函数的实现原理）多态是通过虚函数实现的，如果不声明 virtual 的情况下，无法正确调用到子类的实现： 编译器编译时需要确定每个对象调用的函数（非虚函数）的地址，这称为早期绑定，当子类对象的地址赋给父类指针后，C++ 编译器进行了类型转换，将子类对象当成父类处理，从而调用了父类的函数实现。 实现原理：虚函数表+虚表指针 每个类使用一个虚函数表，每个类对象用一个虚表指针。（注意对象和类的区别） 基类对象包含一个虚表指针，指向基类中的虚函数表。子类对象也将包含一个虚表指针，指向子类虚函数表 如果子类重写了基类的虚函数，该子类的虚函数表将保存重写的虚函数地址，而不是基类的虚函数地址 如果子类没有重写基类的虚函数，该子类的虚函数表将保存基类的虚函数地址。如果子类定义了新的虚函数，则该虚函数地址会被添加到子类的虚函数表中 内存布局： A 类的虚函数表（注意是类，而不是对象）： 12A::f 的地址A::g 的地址 B 类的虚函数表（注意是类，而不是对象）： 12A::f 的地址B::g 的地址 // 存放了重写的地址 如果执行 B b;，b 的内存布局如下 123vptr： 指向 B 的虚表 vtableB // 虚表指针int a： 继承 A 的成员 // 继承了 A，所以有 aint b： B 自己的成员 // 自己的成员变量 如果执行 A *pA = new B(); pA 的内存布局同普通的 A 对象一致，除了虚函数指针，如下 12vptr： 指向 B 的虚表 vtableB // 虚表指针int a： A 的成员 这种情况下 pA 是无法访问到定义在 B 中的 b 对象的 执行 pA-&gt;g(); 时，编译器知道的是，g 是一个声明为 virtual 的成员函数，而且其入口地址放在虚表的第二个（无论是A 的虚表还是B 的虚表），那么编译器就会去 B 的虚表中查找，得到了 B::g 的地址，从而实现了多态","tags":[],"categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"","date":"2020-08-15T09:01:57.760Z","path":"C++/C++ 与 Objetive-C 的区别/","text":"重载在 C++ 中，重载指的是函数名相同，但是参数类型或参数个数不同的函数；而在 OC 中是不支持重载的 C++ 区别函数是通过函数签名，函数签名包括函数名、参数类型和参数个数（注意没有返回值，因为只有返回值不同的函数编译器是无法确定应该调用哪个函数） OC 中 Method 的 key 是 Selector，这个只有方法名，不含参数类型和参数个数，因此无法支持重载 多态（重写） C++：子类的函数覆盖了父类的 virtual 同名函数；通过虚函数表、虚函数指针来实现，子类和父类有不同的虚函数表。单纯创建一个子类对象时，其类的内存布局是子类的，虚函数指针会指向子类虚函数表；而创建一个父类指针指向的子类对象时，其类的内存布局是父类的，其虚函数指针会指向子类的虚函数表 OC：objc_msgSend 过程中通过 isa 指针找到对应的类对象/元类对象，查找其方法列表，如果找不到则往继承链向上找 如果真的要联系对比，那么 C++ 中父类的虚函数表就好比 OC 中父类类对象的方法列表，表明其内存结构；而 C++ 中的虚函数指针就好比 OC 中的 isa 指针，表明真正指向的类 延伸阅读 C++多态 重定义 C++：子类的函数覆盖了父类的非 virtual 函数；此时子类的函数中将会屏蔽父类的同名函数 OC：同多态小节，OC 中的重写和重定义本质上都是消息发送，都是通过 isa 指针查找方法 在 C++ 中，区分重写和重定义的关键是看父类同名函数是否声明了 virtual，而由于在 OC 中没有 virtual 关键字，因此 OC 中没有重写和重定义的概念，只有在消息发送的时候利用 isa 指针去查找类/元类的方法列表 多重继承 C++ 支持多继承 OC 不支持多重继承，可以实现多个协议来完成多重继承的效果 虚基类 C++ 中的虚基类是为了消除多重继承时的歧义 C++虚继承和虚基类 OC 没有虚基类，因为不需要","tags":[],"categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}]},{"title":"工具书签","date":"2020-08-15T09:01:57.754Z","path":"index/","text":"iPhone 尺寸 iPhone 设备一览 C++ 整型大小","tags":[],"categories":[]},{"title":"","date":"2019-08-14T16:00:00.000Z","path":"不务正业/前端/JS 模块化/","text":"模块化模块通常是指编程语言所提供的代码组织机制，利用此机制可将程序拆解为独立且通用的代码单元。所谓模块化主要是解决代码分割、作用域隔离、模块之间的依赖管理以及发布到生产环境时的自动化打包与处理等多个方面 模块化的优点如下： 可维护性。 因为模块是独立的，一个设计良好的模块会让外面的代码对自己的依赖越少越好，这样自己就可以独立去更新和改进 命名空间。 在 JavaScript 里面，如果一个变量在最顶级的函数之外声明，它就直接变成全局可用。因此，常常不小心出现命名冲突的情况。使用模块化开发来封装变量，可以避免污染全局环境 重用代码。 我们有时候会喜欢从之前写过的项目中拷贝代码到新的项目，这没有问题，但是更好的方法是，通过模块引用的方式，来避免重复的代码库 CommonJS 和 AMD 是 JS 中关于模块化的 2 个规范 CommonJS在 CommonJS 中，每个 JavaScript 文件就是一个独立的模块上下文（module context），在这个上下文中默认创建的属性都是私有的。也就是说，在一个文件定义的变量、函数和类，都是私有的，对其他文件是不可见的 CommonJS 有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global 注意 exports 要与 ES6 的 import &amp; export 区别开 实际使用时，用 module.exports 定义当前模块对外输出的接口（不推荐直接用 exports），用 require 加载模块 123456789// 定义模块 math.jsvar basicNum = 0;function add(a, b) &#123; return a + b;&#125;module.exports = &#123; // 在这里写上需要向外暴露的函数、变量 add: add, basicNum: basicNum&#125; 1234567// 引用自定义的模块时，参数包含路径，可省略. jsvar math = require('./math');math.add(2, 5);// 引用核心模块时，不需要带路径var http = require('http');http.createService(...).listen(3000); CommonJS 的 require 方法是同步的。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，数据需要从服务器获取，受限于网络速度，更合理的方案是使用异步加载 注意 module.exports 和 exports 的区别 123456789101112131415161718192021222324var basicNum = 0;function add(a, b) &#123; return a + b;&#125;// 方案 1：使用 module.exports 一个个导出（正确）module.exports.add = addmodule.exports.basicNum = basicNum// 方案 2：使用 exports 一个个导出（正确）exports.add = addexports.basicNum = basicNum// 方案 3：使用 module.exports 整体导出（正确）module.exports = &#123; add: add, basicNum: basicNum&#125;// 方案 4：使用 exports 整体导出（错误）exports = &#123; add: add, basicNum: basicNum&#125; 方案 4 是错误的，可以理解为在模块开始前 exports = module.exports，因为赋值之后 exports 失去了 对 module.exports 的引用，成为了一个模块内的局部变量 AMDAsynchronous Module Definition 规范，意为 “异步模块定义” AMD 定义了一套 JavaScript 模块依赖异步加载标准，来解决同步加载的问题。主要包含 define 和 require 两个方法 模块化使得不会污染全局环境，能够清楚地显示依赖关系，允许异步加载模块，也可以根据需要动态加载模块 define：定义模块define 方法用于模块的定义 12345define( module_id /* 可选 */, [dependencies] /* 可选 */, factory: Function|Object /* 用来初始化模块或对象的函数 */); 第一个参数 id 参数被省略的时候，我们说这个模块是匿名的 第二个参数 dependencies 参数代表了一组对所定义的模块来说必须的依赖项；如果没有指定 dependencies，那么它的默认值是 [“require”, “exports”, “module”] 第三个参数 factory，既可以是函数，也可以是对象。如果是对象，此对象应该为模块的输出值。如果是一个函数，它应该只被执行一次；包裹着模块的具体实现，等到依赖加载完成之后，它才会运行。注意 Function 的参数是各个依赖项的输出，顺序与依赖项一一对应，返回值就是该新定义模块的输出 当第三个参数是 Object 的时候，如下例，生成了一个拥有 method1、method2 两个方法的模块 1234define(&#123; method1: function() &#123;&#125;, method2: function() &#123;&#125;&#125;); 当第三个参数是 Function 的时候，等价的写法如下，这种写法的自由度更高一点，可以在函数体内写一些模块初始化代码 123456define(function () &#123; return &#123; method1: function() &#123;&#125;, method2: function() &#123;&#125; &#125;;&#125;); 一个更具体的例子 1234567891011121314151617181920212223define('myModule', ['foo', 'bar'], // 模块定义函数 // 依赖项（foo 和 bar）被映射为函数的参数 function (foo, bar) &#123; // 返回一个定义了模块导出接口的值 // （也就是我们想要导出后进行调用的功能） // 在这里创建模块 var myModule = &#123; doStuff:function()&#123; console.log('Yay! Stuff'); &#125; &#125; return myModule; &#125;); // 另一个例子可以是...define('myModule', ['jquery', './math.js', 'foo'], function($, math, foo) &#123; // $ 是 jquery 模块的输出 $('body').text('hello world');&#125;); 一个使用了简单 CommonJS 转换的模块定义：没有 return 值，输出使用 exports 123456define(function (require, exports, module) &#123; var a = require(&apos;a&apos;), b = require(&apos;b&apos;); exports.action = function () &#123;&#125;;&#125;); require：加载模块AMD 也采用 require() 语句加载模块，但是不同于 CommonJS，它是异步的，所以多了一个 callback 方法： require([module], callback); 第一个参数是一个数组，里面的成员就是要加载的模块 第二个参数 callback，等加载的模块全部加载成功之后的回调函数 1234567// 假设'foo' 和'bar' 是两个外部模块// 在本例中，这两个模块被加载后的'exports' 被当做两个参数传递到了回调函数中// 所以可以像这样来访问他们require(['foo', 'bar'], function (foo, bar) &#123; // 这里写其余的代码 foo.doSomething();&#125;); require 方法也可以放在 define 内部，比如当 define 的依赖项很多时，参数与模块一一对应的写法非常麻烦 123456define( ['dep1', 'dep2', 'dep3', 'dep4', 'dep5', 'dep6', 'dep7', 'dep8'], function(dep1, dep2, dep3, dep4, dep5, dep6, dep7, dep8)&#123; ... &#125;); 为了避免像上面代码那样繁琐的写法，RequireJS 提供一种更简单的写法 12345678910111213define( function (require) &#123; var dep1 = require('dep1'), dep2 = require('dep2'), dep3 = require('dep3'), dep4 = require('dep4'), dep5 = require('dep5'), dep6 = require('dep6'), dep7 = require('dep7'), dep8 = require('dep8'); ... &#125;); 动态加载模块12345678910111213define(function ( require ) &#123; var isReady = false, foobar; require(['foo', 'bar'], function (foo, bar) &#123; isReady = true; foobar = foo() + bar(); &#125;); return &#123; isReady: isReady, foobar: foobar &#125;;&#125;); 上面代码所定义的模块，内部加载了 foo 和 bar 两个模块，在没有加载完成前，isReady 属性值为 false，加载完成后就变成了 true。因此，可以根据 isReady 属性的值，决定下一步的动作 ES6 模块export 和 importES6 的模块功能主要由两个命令构成：export 和 import 定义模块 math.js，并输出两个对象 12345var basicNum = 0;var add = function (a, b) &#123; return a + b;&#125;;export &#123; basicNum, add &#125;; 12345/** 引用模块 **/import &#123; basicNum, add &#125; from './math';function test(ele) &#123; ele.textContent = add(99 + basicNum);&#125; export defaultES6 还提供了 export default 命令，为模块指定默认输出，对应的 import 语句不需要使用大括号 12345678/** export default **/// 定义输出export default &#123; basicNum, add &#125;;// 引入import math from './math';function test(ele) &#123; ele.textContent = math.add(99 + math.basicNum);&#125; ES6 与 CommonJS 的模块差异 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用 CommonJS 一旦输出一个值，模块内部的变化就影响不到这个值 ES6 中，JS 引擎编译时遇到模块加载命令 import，就会生成一个只读引用，模块内部的变化会影响已输出的值 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为 “运行时加载” 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import 时采用静态命令的形式。即在 import 时可以指定加载某个输出值，而不是加载整个模块，这种加载称为 “编译时加载” 参考文章 《前端模块化：CommonJS,AMD,CMD,ES6》 《Javascript 模块化编程（二）：AMD 规范》 《AMD 规范》 《使用 AMD、CommonJS 及 ES Harmony 编写模块化的 JavaScript》 《RequireJS 和 AMD 规范》 《AMD (中文版)》)","tags":[],"categories":[{"name":"不务正业","slug":"不务正业","permalink":"http://yoursite.com/categories/不务正业/"},{"name":"前端","slug":"不务正业/前端","permalink":"http://yoursite.com/categories/不务正业/前端/"}]}]}